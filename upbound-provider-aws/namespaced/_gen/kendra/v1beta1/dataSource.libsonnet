{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='dataSource', url='', help='"DataSource is the Schema for the DataSources API."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of DataSource', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'kendra.aws.m.upbound.io/v1beta1',
    kind: 'DataSource',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"DataSourceSpec defines the desired state of DataSource"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#configuration':: d.obj(help="\"A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.\""),
      configuration: {
        '#s3Configuration':: d.obj(help='"(Deprecated, Required if type is set to S3) A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below."'),
        s3Configuration: {
          '#accessControlListConfiguration':: d.obj(help='"A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below."'),
          accessControlListConfiguration: {
            '#withKeyPath':: d.fn(help='"Path to the AWS S3 bucket that contains the ACL files."', args=[d.arg(name='keyPath', type=d.T.string)]),
            withKeyPath(keyPath): { spec+: { forProvider+: { configuration+: { s3Configuration+: { accessControlListConfiguration+: { keyPath: keyPath } } } } } },
          },
          '#bucketNameRef':: d.obj(help='"Reference to a Bucket in s3 to populate bucketName."'),
          bucketNameRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { policy+: { resolution: resolution } } } } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { policy+: { resolve: resolve } } } } } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { name: name } } } } } },
            '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { namespace: namespace } } } } } },
          },
          '#bucketNameSelector':: d.obj(help='"Selector for a Bucket in s3 to populate bucketName."'),
          bucketNameSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { policy+: { resolution: resolution } } } } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { policy+: { resolve: resolve } } } } } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchControllerRef: matchControllerRef } } } } } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchLabels: matchLabels } } } } } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchLabels+: matchLabels } } } } } },
            '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { namespace: namespace } } } } } },
          },
          '#documentsMetadataConfiguration':: d.obj(help='"A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below."'),
          documentsMetadataConfiguration: {
            '#withS3Prefix':: d.fn(help='"A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files."', args=[d.arg(name='s3Prefix', type=d.T.string)]),
            withS3Prefix(s3Prefix): { spec+: { forProvider+: { configuration+: { s3Configuration+: { documentsMetadataConfiguration+: { s3Prefix: s3Prefix } } } } } },
          },
          '#withBucketName':: d.fn(help='"The name of the bucket that contains the documents."', args=[d.arg(name='bucketName', type=d.T.string)]),
          withBucketName(bucketName): { spec+: { forProvider+: { configuration+: { s3Configuration+: { bucketName: bucketName } } } } },
          '#withExclusionPatterns':: d.fn(help='"A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples."', args=[d.arg(name='exclusionPatterns', type=d.T.array)]),
          withExclusionPatterns(exclusionPatterns): { spec+: { forProvider+: { configuration+: { s3Configuration+: { exclusionPatterns: if std.isArray(v=exclusionPatterns) then exclusionPatterns else [exclusionPatterns] } } } } },
          '#withExclusionPatternsMixin':: d.fn(help='"A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='exclusionPatterns', type=d.T.array)]),
          withExclusionPatternsMixin(exclusionPatterns): { spec+: { forProvider+: { configuration+: { s3Configuration+: { exclusionPatterns+: if std.isArray(v=exclusionPatterns) then exclusionPatterns else [exclusionPatterns] } } } } },
          '#withInclusionPatterns':: d.fn(help='"A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples."', args=[d.arg(name='inclusionPatterns', type=d.T.array)]),
          withInclusionPatterns(inclusionPatterns): { spec+: { forProvider+: { configuration+: { s3Configuration+: { inclusionPatterns: if std.isArray(v=inclusionPatterns) then inclusionPatterns else [inclusionPatterns] } } } } },
          '#withInclusionPatternsMixin':: d.fn(help='"A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inclusionPatterns', type=d.T.array)]),
          withInclusionPatternsMixin(inclusionPatterns): { spec+: { forProvider+: { configuration+: { s3Configuration+: { inclusionPatterns+: if std.isArray(v=inclusionPatterns) then inclusionPatterns else [inclusionPatterns] } } } } },
          '#withInclusionPrefixes':: d.fn(help='"A list of S3 prefixes for the documents that should be included in the index."', args=[d.arg(name='inclusionPrefixes', type=d.T.array)]),
          withInclusionPrefixes(inclusionPrefixes): { spec+: { forProvider+: { configuration+: { s3Configuration+: { inclusionPrefixes: if std.isArray(v=inclusionPrefixes) then inclusionPrefixes else [inclusionPrefixes] } } } } },
          '#withInclusionPrefixesMixin':: d.fn(help='"A list of S3 prefixes for the documents that should be included in the index."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inclusionPrefixes', type=d.T.array)]),
          withInclusionPrefixesMixin(inclusionPrefixes): { spec+: { forProvider+: { configuration+: { s3Configuration+: { inclusionPrefixes+: if std.isArray(v=inclusionPrefixes) then inclusionPrefixes else [inclusionPrefixes] } } } } },
        },
        '#templateConfiguration':: d.obj(help='"A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below."'),
        templateConfiguration: {
          '#withTemplate':: d.fn(help='"JSON string containing a data source template schema."', args=[d.arg(name='template', type=d.T.string)]),
          withTemplate(template): { spec+: { forProvider+: { configuration+: { templateConfiguration+: { template: template } } } } },
        },
        '#webCrawlerConfiguration':: d.obj(help='"(Deprecated, Required if type is set to WEBCRAWLER) A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below."'),
        webCrawlerConfiguration: {
          '#authenticationConfiguration':: d.obj(help='"A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\" and the port is 443, the standard port for HTTPS. Detailed below."'),
          authenticationConfiguration: {
            '#basicAuthentication':: d.obj(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\""),
            basicAuthentication: {
              '#credentialsRef':: d.obj(help='"Reference to a Secret in secretsmanager to populate credentials."'),
              credentialsRef: {
                '#policy':: d.obj(help='"Policies for referencing."'),
                policy: {
                  '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                  withResolution(resolution): { credentialsRef+: { policy+: { resolution: resolution } } },
                  '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                  withResolve(resolve): { credentialsRef+: { policy+: { resolve: resolve } } },
                },
                '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { credentialsRef+: { name: name } },
                '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { credentialsRef+: { namespace: namespace } },
              },
              '#credentialsSelector':: d.obj(help='"Selector for a Secret in secretsmanager to populate credentials."'),
              credentialsSelector: {
                '#policy':: d.obj(help='"Policies for selection."'),
                policy: {
                  '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                  withResolution(resolution): { credentialsSelector+: { policy+: { resolution: resolution } } },
                  '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                  withResolve(resolve): { credentialsSelector+: { policy+: { resolve: resolve } } },
                },
                '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
                withMatchControllerRef(matchControllerRef): { credentialsSelector+: { matchControllerRef: matchControllerRef } },
                '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { credentialsSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { credentialsSelector+: { matchLabels+: matchLabels } },
                '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { credentialsSelector+: { namespace: namespace } },
              },
              '#withCredentials':: d.fn(help='"Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials."', args=[d.arg(name='credentials', type=d.T.string)]),
              withCredentials(credentials): { credentials: credentials },
              '#withHost':: d.fn(help='"The name of the website host you want to connect to via a web proxy server. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\"."', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { host: host },
              '#withPort':: d.fn(help='"The port number of the website host you want to connect to via a web proxy server. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS."', args=[d.arg(name='port', type=d.T.number)]),
              withPort(port): { port: port },
            },
            '#withBasicAuthentication':: d.fn(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\"", args=[d.arg(name='basicAuthentication', type=d.T.array)]),
            withBasicAuthentication(basicAuthentication): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { authenticationConfiguration+: { basicAuthentication: if std.isArray(v=basicAuthentication) then basicAuthentication else [basicAuthentication] } } } } } },
            '#withBasicAuthenticationMixin':: d.fn(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='basicAuthentication', type=d.T.array)]),
            withBasicAuthenticationMixin(basicAuthentication): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { authenticationConfiguration+: { basicAuthentication+: if std.isArray(v=basicAuthentication) then basicAuthentication else [basicAuthentication] } } } } } },
          },
          '#proxyConfiguration':: d.obj(help='"Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below."'),
          proxyConfiguration: {
            '#credentialsRef':: d.obj(help='"Reference to a Secret in secretsmanager to populate credentials."'),
            credentialsRef: {
              '#policy':: d.obj(help='"Policies for referencing."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { policy+: { resolution: resolution } } } } } } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { policy+: { resolve: resolve } } } } } } } },
              },
              '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { name: name } } } } } } },
              '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { namespace: namespace } } } } } } },
            },
            '#credentialsSelector':: d.obj(help='"Selector for a Secret in secretsmanager to populate credentials."'),
            credentialsSelector: {
              '#policy':: d.obj(help='"Policies for selection."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { policy+: { resolution: resolution } } } } } } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { policy+: { resolve: resolve } } } } } } } },
              },
              '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
              withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchControllerRef: matchControllerRef } } } } } } },
              '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchLabels: matchLabels } } } } } } },
              '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchLabels+: matchLabels } } } } } } },
              '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { namespace: namespace } } } } } } },
            },
            '#withCredentials':: d.fn(help='"Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials."', args=[d.arg(name='credentials', type=d.T.string)]),
            withCredentials(credentials): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentials: credentials } } } } } },
            '#withHost':: d.fn(help='"The name of the website host you want to connect to via a web proxy server. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\"."', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { host: host } } } } } },
            '#withPort':: d.fn(help='"The port number of the website host you want to connect to via a web proxy server. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS."', args=[d.arg(name='port', type=d.T.number)]),
            withPort(port): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { port: port } } } } } },
          },
          '#urls':: d.obj(help='"A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below."'),
          urls: {
            '#seedUrlConfiguration':: d.obj(help='"A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below."'),
            seedUrlConfiguration: {
              '#withSeedUrls':: d.fn(help='"The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048."', args=[d.arg(name='seedUrls', type=d.T.array)]),
              withSeedUrls(seedUrls): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { seedUrls: if std.isArray(v=seedUrls) then seedUrls else [seedUrls] } } } } } } },
              '#withSeedUrlsMixin':: d.fn(help='"The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='seedUrls', type=d.T.array)]),
              withSeedUrlsMixin(seedUrls): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { seedUrls+: if std.isArray(v=seedUrls) then seedUrls else [seedUrls] } } } } } } },
              '#withWebCrawlerMode':: d.fn(help='"The default mode is set to HOST_ONLY. You can choose one of the following modes:"', args=[d.arg(name='webCrawlerMode', type=d.T.string)]),
              withWebCrawlerMode(webCrawlerMode): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { webCrawlerMode: webCrawlerMode } } } } } } },
            },
            '#siteMapsConfiguration':: d.obj(help='"A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below."'),
            siteMapsConfiguration: {
              '#withSiteMaps':: d.fn(help='"The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs."', args=[d.arg(name='siteMaps', type=d.T.array)]),
              withSiteMaps(siteMaps): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { siteMapsConfiguration+: { siteMaps: if std.isArray(v=siteMaps) then siteMaps else [siteMaps] } } } } } } },
              '#withSiteMapsMixin':: d.fn(help='"The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='siteMaps', type=d.T.array)]),
              withSiteMapsMixin(siteMaps): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { siteMapsConfiguration+: { siteMaps+: if std.isArray(v=siteMaps) then siteMaps else [siteMaps] } } } } } } },
            },
          },
          '#withCrawlDepth':: d.fn(help='"Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels - index level (i.e. seed in this example), sections level, and subsections level - and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10."', args=[d.arg(name='crawlDepth', type=d.T.number)]),
          withCrawlDepth(crawlDepth): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { crawlDepth: crawlDepth } } } } },
          '#withMaxContentSizePerPageInMegaBytes':: d.fn(help='"The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50."', args=[d.arg(name='maxContentSizePerPageInMegaBytes', type=d.T.number)]),
          withMaxContentSizePerPageInMegaBytes(maxContentSizePerPageInMegaBytes): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { maxContentSizePerPageInMegaBytes: maxContentSizePerPageInMegaBytes } } } } },
          '#withMaxLinksPerPage':: d.fn(help='"The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a websiteâ€™s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000."', args=[d.arg(name='maxLinksPerPage', type=d.T.number)]),
          withMaxLinksPerPage(maxLinksPerPage): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { maxLinksPerPage: maxLinksPerPage } } } } },
          '#withMaxUrlsPerMinuteCrawlRate':: d.fn(help='"The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300."', args=[d.arg(name='maxUrlsPerMinuteCrawlRate', type=d.T.number)]),
          withMaxUrlsPerMinuteCrawlRate(maxUrlsPerMinuteCrawlRate): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { maxUrlsPerMinuteCrawlRate: maxUrlsPerMinuteCrawlRate } } } } },
          '#withUrlExclusionPatterns':: d.fn(help="\"A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"", args=[d.arg(name='urlExclusionPatterns', type=d.T.array)]),
          withUrlExclusionPatterns(urlExclusionPatterns): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urlExclusionPatterns: if std.isArray(v=urlExclusionPatterns) then urlExclusionPatterns else [urlExclusionPatterns] } } } } },
          '#withUrlExclusionPatternsMixin':: d.fn(help="\"A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='urlExclusionPatterns', type=d.T.array)]),
          withUrlExclusionPatternsMixin(urlExclusionPatterns): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urlExclusionPatterns+: if std.isArray(v=urlExclusionPatterns) then urlExclusionPatterns else [urlExclusionPatterns] } } } } },
          '#withUrlInclusionPatterns':: d.fn(help="\"A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"", args=[d.arg(name='urlInclusionPatterns', type=d.T.array)]),
          withUrlInclusionPatterns(urlInclusionPatterns): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urlInclusionPatterns: if std.isArray(v=urlInclusionPatterns) then urlInclusionPatterns else [urlInclusionPatterns] } } } } },
          '#withUrlInclusionPatternsMixin':: d.fn(help="\"A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='urlInclusionPatterns', type=d.T.array)]),
          withUrlInclusionPatternsMixin(urlInclusionPatterns): { spec+: { forProvider+: { configuration+: { webCrawlerConfiguration+: { urlInclusionPatterns+: if std.isArray(v=urlInclusionPatterns) then urlInclusionPatterns else [urlInclusionPatterns] } } } } },
        },
      },
      '#customDocumentEnrichmentConfiguration':: d.obj(help='"A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below."'),
      customDocumentEnrichmentConfiguration: {
        '#inlineConfigurations':: d.obj(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."'),
        inlineConfigurations: {
          '#condition':: d.obj(help='"Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition."'),
          condition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { condition+: { conditionOnValue+: { dateValue: dateValue } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { condition+: { conditionOnValue+: { longValue: longValue } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { condition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { condition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { condition+: { conditionOnValue+: { stringValue: stringValue } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { condition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { condition+: { operator: operator } },
          },
          '#target':: d.obj(help='"Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below."'),
          target: {
            '#targetDocumentAttributeValue':: d.obj(help="\"The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.\""),
            targetDocumentAttributeValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { target+: { targetDocumentAttributeValue+: { dateValue: dateValue } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { target+: { targetDocumentAttributeValue+: { longValue: longValue } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { target+: { targetDocumentAttributeValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { target+: { targetDocumentAttributeValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { target+: { targetDocumentAttributeValue+: { stringValue: stringValue } } },
            },
            '#withTargetDocumentAttributeKey':: d.fn(help="\"The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.\"", args=[d.arg(name='targetDocumentAttributeKey', type=d.T.string)]),
            withTargetDocumentAttributeKey(targetDocumentAttributeKey): { target+: { targetDocumentAttributeKey: targetDocumentAttributeKey } },
            '#withTargetDocumentAttributeValueDeletion':: d.fn(help='"TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE."', args=[d.arg(name='targetDocumentAttributeValueDeletion', type=d.T.boolean)]),
            withTargetDocumentAttributeValueDeletion(targetDocumentAttributeValueDeletion): { target+: { targetDocumentAttributeValueDeletion: targetDocumentAttributeValueDeletion } },
          },
          '#withDocumentContentDeletion':: d.fn(help='"TRUE to delete content if the condition used for the target attribute is met."', args=[d.arg(name='documentContentDeletion', type=d.T.boolean)]),
          withDocumentContentDeletion(documentContentDeletion): { documentContentDeletion: documentContentDeletion },
        },
        '#postExtractionHookConfiguration':: d.obj(help='"A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below."'),
        postExtractionHookConfiguration: {
          '#invocationCondition':: d.obj(help='"A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition."'),
          invocationCondition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { dateValue: dateValue } } } } } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { longValue: longValue } } } } } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringValue: stringValue } } } } } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } } } } } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { operator: operator } } } } } },
          },
          '#withLambdaArn':: d.fn(help='"The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { lambdaArn: lambdaArn } } } } },
          '#withS3Bucket':: d.fn(help='"Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions."', args=[d.arg(name='s3Bucket', type=d.T.string)]),
          withS3Bucket(s3Bucket): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { s3Bucket: s3Bucket } } } } },
        },
        '#preExtractionHookConfiguration':: d.obj(help='"Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below."'),
        preExtractionHookConfiguration: {
          '#invocationCondition':: d.obj(help='"A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition."'),
          invocationCondition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { dateValue: dateValue } } } } } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { longValue: longValue } } } } } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringValue: stringValue } } } } } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } } } } } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { operator: operator } } } } } },
          },
          '#withLambdaArn':: d.fn(help='"The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { lambdaArn: lambdaArn } } } } },
          '#withS3Bucket':: d.fn(help='"Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions."', args=[d.arg(name='s3Bucket', type=d.T.string)]),
          withS3Bucket(s3Bucket): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { s3Bucket: s3Bucket } } } } },
        },
        '#withInlineConfigurations':: d.fn(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."', args=[d.arg(name='inlineConfigurations', type=d.T.array)]),
        withInlineConfigurations(inlineConfigurations): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { inlineConfigurations: if std.isArray(v=inlineConfigurations) then inlineConfigurations else [inlineConfigurations] } } } },
        '#withInlineConfigurationsMixin':: d.fn(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inlineConfigurations', type=d.T.array)]),
        withInlineConfigurationsMixin(inlineConfigurations): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { inlineConfigurations+: if std.isArray(v=inlineConfigurations) then inlineConfigurations else [inlineConfigurations] } } } },
        '#withRoleArn':: d.fn(help='"The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra."', args=[d.arg(name='roleArn', type=d.T.string)]),
        withRoleArn(roleArn): { spec+: { forProvider+: { customDocumentEnrichmentConfiguration+: { roleArn: roleArn } } } },
      },
      '#indexIdRef':: d.obj(help='"Reference to a Index in kendra to populate indexId."'),
      indexIdRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { indexIdRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { indexIdRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { indexIdRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { indexIdRef+: { namespace: namespace } } } },
      },
      '#indexIdSelector':: d.obj(help='"Selector for a Index in kendra to populate indexId."'),
      indexIdSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { indexIdSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { indexIdSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { indexIdSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { indexIdSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { indexIdSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { indexIdSelector+: { namespace: namespace } } } },
      },
      '#roleArnRef':: d.obj(help='"Reference to a Role in iam to populate roleArn."'),
      roleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { roleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { roleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { roleArnRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { roleArnRef+: { namespace: namespace } } } },
      },
      '#roleArnSelector':: d.obj(help='"Selector for a Role in iam to populate roleArn."'),
      roleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { roleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { roleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { roleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { roleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { roleArnSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { roleArnSelector+: { namespace: namespace } } } },
      },
      '#withDescription':: d.fn(help='"A description for the Data Source connector."', args=[d.arg(name='description', type=d.T.string)]),
      withDescription(description): { spec+: { forProvider+: { description: description } } },
      '#withIndexId':: d.fn(help='"The identifier of the index for your Amazon Kendra data source."', args=[d.arg(name='indexId', type=d.T.string)]),
      withIndexId(indexId): { spec+: { forProvider+: { indexId: indexId } } },
      '#withLanguageCode':: d.fn(help='"The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English."', args=[d.arg(name='languageCode', type=d.T.string)]),
      withLanguageCode(languageCode): { spec+: { forProvider+: { languageCode: languageCode } } },
      '#withName':: d.fn(help='"A name for your data source connector."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { forProvider+: { name: name } } },
      '#withRegion':: d.fn(help="\"Region where this resource will be managed. Defaults to the Region set in the provider configuration.\\nRegion is the region you'd like your resource to be created in.\"", args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { spec+: { forProvider+: { region: region } } },
      '#withRoleArn':: d.fn(help="\"The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.\"", args=[d.arg(name='roleArn', type=d.T.string)]),
      withRoleArn(roleArn): { spec+: { forProvider+: { roleArn: roleArn } } },
      '#withSchedule':: d.fn(help="\"Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.\"", args=[d.arg(name='schedule', type=d.T.string)]),
      withSchedule(schedule): { spec+: { forProvider+: { schedule: schedule } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { forProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: tags } } },
      '#withType':: d.fn(help='"The type of data source repository. For an updated list of values, refer to Valid Values for Type."', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { spec+: { forProvider+: { type: type } } },
    },
    '#initProvider':: d.obj(help='"THIS IS A BETA FIELD. It will be honored\\nunless the Management Policies feature flag is disabled.\\nInitProvider holds the same fields as ForProvider, with the exception\\nof Identifier and other resource reference fields. The fields that are\\nin InitProvider are merged into ForProvider when the resource is created.\\nThe same fields are also added to the terraform ignore_changes hook, to\\navoid updating them after creation. This is useful for fields that are\\nrequired on creation, but we do not desire to update them after creation,\\nfor example because of an external controller is managing them, like an\\nautoscaler."'),
    initProvider: {
      '#configuration':: d.obj(help="\"A block with the configuration information to connect to your Data Source repository. You can't specify the configuration block when the type parameter is set to CUSTOM. Detailed below.\""),
      configuration: {
        '#s3Configuration':: d.obj(help='"(Deprecated, Required if type is set to S3) A block that provides the configuration information to connect to an Amazon S3 bucket as your data source. Detailed below."'),
        s3Configuration: {
          '#accessControlListConfiguration':: d.obj(help='"A block that provides the path to the S3 bucket that contains the user context filtering files for the data source. For the format of the file, see Access control for S3 data sources. Detailed below."'),
          accessControlListConfiguration: {
            '#withKeyPath':: d.fn(help='"Path to the AWS S3 bucket that contains the ACL files."', args=[d.arg(name='keyPath', type=d.T.string)]),
            withKeyPath(keyPath): { spec+: { initProvider+: { configuration+: { s3Configuration+: { accessControlListConfiguration+: { keyPath: keyPath } } } } } },
          },
          '#bucketNameRef':: d.obj(help='"Reference to a Bucket in s3 to populate bucketName."'),
          bucketNameRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { policy+: { resolution: resolution } } } } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { policy+: { resolve: resolve } } } } } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { name: name } } } } } },
            '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameRef+: { namespace: namespace } } } } } },
          },
          '#bucketNameSelector':: d.obj(help='"Selector for a Bucket in s3 to populate bucketName."'),
          bucketNameSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { policy+: { resolution: resolution } } } } } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { policy+: { resolve: resolve } } } } } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchControllerRef: matchControllerRef } } } } } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchLabels: matchLabels } } } } } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { matchLabels+: matchLabels } } } } } },
            '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
            withNamespace(namespace): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketNameSelector+: { namespace: namespace } } } } } },
          },
          '#documentsMetadataConfiguration':: d.obj(help='"A block that defines the Document metadata files that contain information such as the document access control information, source URI, document author, and custom attributes. Each metadata file contains metadata about a single document. Detailed below."'),
          documentsMetadataConfiguration: {
            '#withS3Prefix':: d.fn(help='"A prefix used to filter metadata configuration files in the AWS S3 bucket. The S3 bucket might contain multiple metadata files. Use s3_prefix to include only the desired metadata files."', args=[d.arg(name='s3Prefix', type=d.T.string)]),
            withS3Prefix(s3Prefix): { spec+: { initProvider+: { configuration+: { s3Configuration+: { documentsMetadataConfiguration+: { s3Prefix: s3Prefix } } } } } },
          },
          '#withBucketName':: d.fn(help='"The name of the bucket that contains the documents."', args=[d.arg(name='bucketName', type=d.T.string)]),
          withBucketName(bucketName): { spec+: { initProvider+: { configuration+: { s3Configuration+: { bucketName: bucketName } } } } },
          '#withExclusionPatterns':: d.fn(help='"A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples."', args=[d.arg(name='exclusionPatterns', type=d.T.array)]),
          withExclusionPatterns(exclusionPatterns): { spec+: { initProvider+: { configuration+: { s3Configuration+: { exclusionPatterns: if std.isArray(v=exclusionPatterns) then exclusionPatterns else [exclusionPatterns] } } } } },
          '#withExclusionPatternsMixin':: d.fn(help='"A list of glob patterns for documents that should not be indexed. If a document that matches an inclusion prefix or inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Exclusion Patterns for more examples."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='exclusionPatterns', type=d.T.array)]),
          withExclusionPatternsMixin(exclusionPatterns): { spec+: { initProvider+: { configuration+: { s3Configuration+: { exclusionPatterns+: if std.isArray(v=exclusionPatterns) then exclusionPatterns else [exclusionPatterns] } } } } },
          '#withInclusionPatterns':: d.fn(help='"A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples."', args=[d.arg(name='inclusionPatterns', type=d.T.array)]),
          withInclusionPatterns(inclusionPatterns): { spec+: { initProvider+: { configuration+: { s3Configuration+: { inclusionPatterns: if std.isArray(v=inclusionPatterns) then inclusionPatterns else [inclusionPatterns] } } } } },
          '#withInclusionPatternsMixin':: d.fn(help='"A list of glob patterns for documents that should be indexed. If a document that matches an inclusion pattern also matches an exclusion pattern, the document is not indexed. Refer to Inclusion Patterns for more examples."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inclusionPatterns', type=d.T.array)]),
          withInclusionPatternsMixin(inclusionPatterns): { spec+: { initProvider+: { configuration+: { s3Configuration+: { inclusionPatterns+: if std.isArray(v=inclusionPatterns) then inclusionPatterns else [inclusionPatterns] } } } } },
          '#withInclusionPrefixes':: d.fn(help='"A list of S3 prefixes for the documents that should be included in the index."', args=[d.arg(name='inclusionPrefixes', type=d.T.array)]),
          withInclusionPrefixes(inclusionPrefixes): { spec+: { initProvider+: { configuration+: { s3Configuration+: { inclusionPrefixes: if std.isArray(v=inclusionPrefixes) then inclusionPrefixes else [inclusionPrefixes] } } } } },
          '#withInclusionPrefixesMixin':: d.fn(help='"A list of S3 prefixes for the documents that should be included in the index."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inclusionPrefixes', type=d.T.array)]),
          withInclusionPrefixesMixin(inclusionPrefixes): { spec+: { initProvider+: { configuration+: { s3Configuration+: { inclusionPrefixes+: if std.isArray(v=inclusionPrefixes) then inclusionPrefixes else [inclusionPrefixes] } } } } },
        },
        '#templateConfiguration':: d.obj(help='"A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below."'),
        templateConfiguration: {
          '#withTemplate':: d.fn(help='"JSON string containing a data source template schema."', args=[d.arg(name='template', type=d.T.string)]),
          withTemplate(template): { spec+: { initProvider+: { configuration+: { templateConfiguration+: { template: template } } } } },
        },
        '#webCrawlerConfiguration':: d.obj(help='"(Deprecated, Required if type is set to WEBCRAWLER) A block that provides the configuration information required for Amazon Kendra Web Crawler. Detailed below."'),
        webCrawlerConfiguration: {
          '#authenticationConfiguration':: d.obj(help='"A block with the configuration information required to connect to websites using authentication. You can connect to websites using basic authentication of user name and password. You use a secret in AWS Secrets Manager to store your authentication credentials. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\" and the port is 443, the standard port for HTTPS. Detailed below."'),
          authenticationConfiguration: {
            '#basicAuthentication':: d.obj(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\""),
            basicAuthentication: {
              '#credentialsRef':: d.obj(help='"Reference to a Secret in secretsmanager to populate credentials."'),
              credentialsRef: {
                '#policy':: d.obj(help='"Policies for referencing."'),
                policy: {
                  '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                  withResolution(resolution): { credentialsRef+: { policy+: { resolution: resolution } } },
                  '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                  withResolve(resolve): { credentialsRef+: { policy+: { resolve: resolve } } },
                },
                '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { credentialsRef+: { name: name } },
                '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { credentialsRef+: { namespace: namespace } },
              },
              '#credentialsSelector':: d.obj(help='"Selector for a Secret in secretsmanager to populate credentials."'),
              credentialsSelector: {
                '#policy':: d.obj(help='"Policies for selection."'),
                policy: {
                  '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                  withResolution(resolution): { credentialsSelector+: { policy+: { resolution: resolution } } },
                  '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                  withResolve(resolve): { credentialsSelector+: { policy+: { resolve: resolve } } },
                },
                '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
                withMatchControllerRef(matchControllerRef): { credentialsSelector+: { matchControllerRef: matchControllerRef } },
                '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabels(matchLabels): { credentialsSelector+: { matchLabels: matchLabels } },
                '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
                withMatchLabelsMixin(matchLabels): { credentialsSelector+: { matchLabels+: matchLabels } },
                '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
                withNamespace(namespace): { credentialsSelector+: { namespace: namespace } },
              },
              '#withCredentials':: d.fn(help='"Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials."', args=[d.arg(name='credentials', type=d.T.string)]),
              withCredentials(credentials): { credentials: credentials },
              '#withHost':: d.fn(help='"The name of the website host you want to connect to via a web proxy server. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\"."', args=[d.arg(name='host', type=d.T.string)]),
              withHost(host): { host: host },
              '#withPort':: d.fn(help='"The port number of the website host you want to connect to via a web proxy server. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS."', args=[d.arg(name='port', type=d.T.number)]),
              withPort(port): { port: port },
            },
            '#withBasicAuthentication':: d.fn(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\"", args=[d.arg(name='basicAuthentication', type=d.T.array)]),
            withBasicAuthentication(basicAuthentication): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { authenticationConfiguration+: { basicAuthentication: if std.isArray(v=basicAuthentication) then basicAuthentication else [basicAuthentication] } } } } } },
            '#withBasicAuthenticationMixin':: d.fn(help="\"The list of configuration information that's required to connect to and crawl a website host using basic authentication credentials. The list includes the name and port number of the website host. Detailed below.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='basicAuthentication', type=d.T.array)]),
            withBasicAuthenticationMixin(basicAuthentication): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { authenticationConfiguration+: { basicAuthentication+: if std.isArray(v=basicAuthentication) then basicAuthentication else [basicAuthentication] } } } } } },
          },
          '#proxyConfiguration':: d.obj(help='"Configuration information required to connect to your internal websites via a web proxy. You must provide the website host name and port number. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\" and the port is 443, the standard port for HTTPS. Web proxy credentials are optional and you can use them to connect to a web proxy server that requires basic authentication. To store web proxy credentials, you use a secret in AWS Secrets Manager. Detailed below."'),
          proxyConfiguration: {
            '#credentialsRef':: d.obj(help='"Reference to a Secret in secretsmanager to populate credentials."'),
            credentialsRef: {
              '#policy':: d.obj(help='"Policies for referencing."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { policy+: { resolution: resolution } } } } } } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { policy+: { resolve: resolve } } } } } } } },
              },
              '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { name: name } } } } } } },
              '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsRef+: { namespace: namespace } } } } } } },
            },
            '#credentialsSelector':: d.obj(help='"Selector for a Secret in secretsmanager to populate credentials."'),
            credentialsSelector: {
              '#policy':: d.obj(help='"Policies for selection."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { policy+: { resolution: resolution } } } } } } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { policy+: { resolve: resolve } } } } } } } },
              },
              '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
              withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchControllerRef: matchControllerRef } } } } } } },
              '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchLabels: matchLabels } } } } } } },
              '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { matchLabels+: matchLabels } } } } } } },
              '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentialsSelector+: { namespace: namespace } } } } } } },
            },
            '#withCredentials':: d.fn(help='"Your secret ARN, which you can create in AWS Secrets Manager. The credentials are optional. You use a secret if web proxy credentials are required to connect to a website host. Amazon Kendra currently support basic authentication to connect to a web proxy server. The secret stores your credentials."', args=[d.arg(name='credentials', type=d.T.string)]),
            withCredentials(credentials): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { credentials: credentials } } } } } },
            '#withHost':: d.fn(help='"The name of the website host you want to connect to via a web proxy server. For example, the host name of https://a.example.com/page1.html is \\"a.example.com\\"."', args=[d.arg(name='host', type=d.T.string)]),
            withHost(host): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { host: host } } } } } },
            '#withPort':: d.fn(help='"The port number of the website host you want to connect to via a web proxy server. For example, the port for https://a.example.com/page1.html is 443, the standard port for HTTPS."', args=[d.arg(name='port', type=d.T.number)]),
            withPort(port): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { proxyConfiguration+: { port: port } } } } } },
          },
          '#urls':: d.obj(help='"A block that specifies the seed or starting point URLs of the websites or the sitemap URLs of the websites you want to crawl. You can include website subdomains. You can list up to 100 seed URLs and up to 3 sitemap URLs. You can only crawl websites that use the secure communication protocol, Hypertext Transfer Protocol Secure (HTTPS). If you receive an error when crawling a website, it could be that the website is blocked from crawling. When selecting websites to index, you must adhere to the Amazon Acceptable Use Policy and all other Amazon terms. Remember that you must only use Amazon Kendra Web Crawler to index your own webpages, or webpages that you have authorization to index. Detailed below."'),
          urls: {
            '#seedUrlConfiguration':: d.obj(help='"A block that specifies the configuration of the seed or starting point URLs of the websites you want to crawl. You can choose to crawl only the website host names, or the website host names with subdomains, or the website host names with subdomains and other domains that the webpages link to. You can list up to 100 seed URLs. Detailed below."'),
            seedUrlConfiguration: {
              '#withSeedUrls':: d.fn(help='"The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048."', args=[d.arg(name='seedUrls', type=d.T.array)]),
              withSeedUrls(seedUrls): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { seedUrls: if std.isArray(v=seedUrls) then seedUrls else [seedUrls] } } } } } } },
              '#withSeedUrlsMixin':: d.fn(help='"The list of seed or starting point URLs of the websites you want to crawl. The list can include a maximum of 100 seed URLs. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 2048."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='seedUrls', type=d.T.array)]),
              withSeedUrlsMixin(seedUrls): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { seedUrls+: if std.isArray(v=seedUrls) then seedUrls else [seedUrls] } } } } } } },
              '#withWebCrawlerMode':: d.fn(help='"The default mode is set to HOST_ONLY. You can choose one of the following modes:"', args=[d.arg(name='webCrawlerMode', type=d.T.string)]),
              withWebCrawlerMode(webCrawlerMode): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { seedUrlConfiguration+: { webCrawlerMode: webCrawlerMode } } } } } } },
            },
            '#siteMapsConfiguration':: d.obj(help='"A block that specifies the configuration of the sitemap URLs of the websites you want to crawl. Only URLs belonging to the same website host names are crawled. You can list up to 3 sitemap URLs. Detailed below."'),
            siteMapsConfiguration: {
              '#withSiteMaps':: d.fn(help='"The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs."', args=[d.arg(name='siteMaps', type=d.T.array)]),
              withSiteMaps(siteMaps): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { siteMapsConfiguration+: { siteMaps: if std.isArray(v=siteMaps) then siteMaps else [siteMaps] } } } } } } },
              '#withSiteMapsMixin':: d.fn(help='"The list of sitemap URLs of the websites you want to crawl. The list can include a maximum of 3 sitemap URLs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='siteMaps', type=d.T.array)]),
              withSiteMapsMixin(siteMaps): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urls+: { siteMapsConfiguration+: { siteMaps+: if std.isArray(v=siteMaps) then siteMaps else [siteMaps] } } } } } } },
            },
          },
          '#withCrawlDepth':: d.fn(help='"Specifies the number of levels in a website that you want to crawl. The first level begins from the website seed or starting point URL. For example, if a website has 3 levels - index level (i.e. seed in this example), sections level, and subsections level - and you are only interested in crawling information up to the sections level (i.e. levels 0-1), you can set your depth to 1. The default crawl depth is set to 2. Minimum value of 0. Maximum value of 10."', args=[d.arg(name='crawlDepth', type=d.T.number)]),
          withCrawlDepth(crawlDepth): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { crawlDepth: crawlDepth } } } } },
          '#withMaxContentSizePerPageInMegaBytes':: d.fn(help='"The maximum size (in MB) of a webpage or attachment to crawl. Files larger than this size (in MB) are skipped/not crawled. The default maximum size of a webpage or attachment is set to 50 MB. Minimum value of 1.0e-06. Maximum value of 50."', args=[d.arg(name='maxContentSizePerPageInMegaBytes', type=d.T.number)]),
          withMaxContentSizePerPageInMegaBytes(maxContentSizePerPageInMegaBytes): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { maxContentSizePerPageInMegaBytes: maxContentSizePerPageInMegaBytes } } } } },
          '#withMaxLinksPerPage':: d.fn(help='"The maximum number of URLs on a webpage to include when crawling a website. This number is per webpage. As a websiteâ€™s webpages are crawled, any URLs the webpages link to are also crawled. URLs on a webpage are crawled in order of appearance. The default maximum links per page is 100. Minimum value of 1. Maximum value of 1000."', args=[d.arg(name='maxLinksPerPage', type=d.T.number)]),
          withMaxLinksPerPage(maxLinksPerPage): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { maxLinksPerPage: maxLinksPerPage } } } } },
          '#withMaxUrlsPerMinuteCrawlRate':: d.fn(help='"The maximum number of URLs crawled per website host per minute. The default maximum number of URLs crawled per website host per minute is 300. Minimum value of 1. Maximum value of 300."', args=[d.arg(name='maxUrlsPerMinuteCrawlRate', type=d.T.number)]),
          withMaxUrlsPerMinuteCrawlRate(maxUrlsPerMinuteCrawlRate): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { maxUrlsPerMinuteCrawlRate: maxUrlsPerMinuteCrawlRate } } } } },
          '#withUrlExclusionPatterns':: d.fn(help="\"A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"", args=[d.arg(name='urlExclusionPatterns', type=d.T.array)]),
          withUrlExclusionPatterns(urlExclusionPatterns): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urlExclusionPatterns: if std.isArray(v=urlExclusionPatterns) then urlExclusionPatterns else [urlExclusionPatterns] } } } } },
          '#withUrlExclusionPatternsMixin':: d.fn(help="\"A list of regular expression patterns to exclude certain URLs to crawl. URLs that match the patterns are excluded from the index. URLs that don't match the patterns are included in the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='urlExclusionPatterns', type=d.T.array)]),
          withUrlExclusionPatternsMixin(urlExclusionPatterns): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urlExclusionPatterns+: if std.isArray(v=urlExclusionPatterns) then urlExclusionPatterns else [urlExclusionPatterns] } } } } },
          '#withUrlInclusionPatterns':: d.fn(help="\"A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"", args=[d.arg(name='urlInclusionPatterns', type=d.T.array)]),
          withUrlInclusionPatterns(urlInclusionPatterns): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urlInclusionPatterns: if std.isArray(v=urlInclusionPatterns) then urlInclusionPatterns else [urlInclusionPatterns] } } } } },
          '#withUrlInclusionPatternsMixin':: d.fn(help="\"A list of regular expression patterns to include certain URLs to crawl. URLs that match the patterns are included in the index. URLs that don't match the patterns are excluded from the index. If a URL matches both an inclusion and exclusion pattern, the exclusion pattern takes precedence and the URL file isn't included in the index. Array Members: Minimum number of 0 items. Maximum number of 100 items. Length Constraints: Minimum length of 1. Maximum length of 150.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='urlInclusionPatterns', type=d.T.array)]),
          withUrlInclusionPatternsMixin(urlInclusionPatterns): { spec+: { initProvider+: { configuration+: { webCrawlerConfiguration+: { urlInclusionPatterns+: if std.isArray(v=urlInclusionPatterns) then urlInclusionPatterns else [urlInclusionPatterns] } } } } },
        },
      },
      '#customDocumentEnrichmentConfiguration':: d.obj(help='"A block with the configuration information for altering document metadata and content during the document ingestion process. For more information on how to create, modify and delete document metadata, or make other content alterations when you ingest documents into Amazon Kendra, see Customizing document metadata during the ingestion process. Detailed below."'),
      customDocumentEnrichmentConfiguration: {
        '#inlineConfigurations':: d.obj(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."'),
        inlineConfigurations: {
          '#condition':: d.obj(help='"Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Kendra. See condition."'),
          condition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { condition+: { conditionOnValue+: { dateValue: dateValue } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { condition+: { conditionOnValue+: { longValue: longValue } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { condition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { condition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { condition+: { conditionOnValue+: { stringValue: stringValue } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { condition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { condition+: { operator: operator } },
          },
          '#target':: d.obj(help='"Configuration of the target document attribute or metadata field when ingesting documents into Amazon Kendra. You can also include a value. Detailed below."'),
          target: {
            '#targetDocumentAttributeValue':: d.obj(help="\"The target value you want to create for the target attribute. For example, 'Finance' could be the target value for the target attribute key 'Department'. See target_document_attribute_value.\""),
            targetDocumentAttributeValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { target+: { targetDocumentAttributeValue+: { dateValue: dateValue } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { target+: { targetDocumentAttributeValue+: { longValue: longValue } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { target+: { targetDocumentAttributeValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { target+: { targetDocumentAttributeValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { target+: { targetDocumentAttributeValue+: { stringValue: stringValue } } },
            },
            '#withTargetDocumentAttributeKey':: d.fn(help="\"The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.\"", args=[d.arg(name='targetDocumentAttributeKey', type=d.T.string)]),
            withTargetDocumentAttributeKey(targetDocumentAttributeKey): { target+: { targetDocumentAttributeKey: targetDocumentAttributeKey } },
            '#withTargetDocumentAttributeValueDeletion':: d.fn(help='"TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE. To create a target value (TargetDocumentAttributeValue), set this to FALSE."', args=[d.arg(name='targetDocumentAttributeValueDeletion', type=d.T.boolean)]),
            withTargetDocumentAttributeValueDeletion(targetDocumentAttributeValueDeletion): { target+: { targetDocumentAttributeValueDeletion: targetDocumentAttributeValueDeletion } },
          },
          '#withDocumentContentDeletion':: d.fn(help='"TRUE to delete content if the condition used for the target attribute is met."', args=[d.arg(name='documentContentDeletion', type=d.T.boolean)]),
          withDocumentContentDeletion(documentContentDeletion): { documentContentDeletion: documentContentDeletion },
        },
        '#postExtractionHookConfiguration':: d.obj(help='"A block that specifies the configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below."'),
        postExtractionHookConfiguration: {
          '#invocationCondition':: d.obj(help='"A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition."'),
          invocationCondition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { dateValue: dateValue } } } } } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { longValue: longValue } } } } } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringValue: stringValue } } } } } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } } } } } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { invocationCondition+: { operator: operator } } } } } },
          },
          '#withLambdaArn':: d.fn(help='"The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { lambdaArn: lambdaArn } } } } },
          '#withS3Bucket':: d.fn(help='"Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions."', args=[d.arg(name='s3Bucket', type=d.T.string)]),
          withS3Bucket(s3Bucket): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { postExtractionHookConfiguration+: { s3Bucket: s3Bucket } } } } },
        },
        '#preExtractionHookConfiguration':: d.obj(help='"Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see Advanced data manipulation. Detailed below."'),
        preExtractionHookConfiguration: {
          '#invocationCondition':: d.obj(help='"A block that specifies the condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Kendra should invoke a function that inserts the current date-time. See invocation_condition."'),
          invocationCondition: {
            '#conditionOnValue':: d.obj(help="\"The value used by the operator. For example, you can specify the value 'financial' for strings in the _source_uri field that partially match or contain this value. See condition_on_value.\""),
            conditionOnValue: {
              '#withDateValue':: d.fn(help='"A date expressed as an ISO 8601 string. It is important for the time zone to be included in the ISO 8601 date-time format. As of this writing only UTC is supported. For example, 2012-03-25T12:30:10+00:00."', args=[d.arg(name='dateValue', type=d.T.string)]),
              withDateValue(dateValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { dateValue: dateValue } } } } } } },
              '#withLongValue':: d.fn(help='"A long integer value."', args=[d.arg(name='longValue', type=d.T.number)]),
              withLongValue(longValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { longValue: longValue } } } } } } },
              '#withStringListValue':: d.fn(help='"A list of strings."', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValue(stringListValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringListValueMixin':: d.fn(help='"A list of strings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stringListValue', type=d.T.array)]),
              withStringListValueMixin(stringListValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringListValue+: if std.isArray(v=stringListValue) then stringListValue else [stringListValue] } } } } } } },
              '#withStringValue':: d.fn(help='', args=[d.arg(name='stringValue', type=d.T.string)]),
              withStringValue(stringValue): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionOnValue+: { stringValue: stringValue } } } } } } },
            },
            '#withConditionDocumentAttributeKey':: d.fn(help='"The identifier of the document attribute used for the condition. For example, _source_uri could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition."', args=[d.arg(name='conditionDocumentAttributeKey', type=d.T.string)]),
            withConditionDocumentAttributeKey(conditionDocumentAttributeKey): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { conditionDocumentAttributeKey: conditionDocumentAttributeKey } } } } } },
            '#withOperator':: d.fn(help='"The condition operator. For example, you can use Contains to partially match a string. Valid Values: GreaterThan | GreaterThanOrEquals | LessThan | LessThanOrEquals | Equals | NotEquals | Contains | NotContains | Exists | NotExists | BeginsWith."', args=[d.arg(name='operator', type=d.T.string)]),
            withOperator(operator): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { invocationCondition+: { operator: operator } } } } } },
          },
          '#withLambdaArn':: d.fn(help='"The Amazon Resource Name (ARN) of a Lambda Function that can manipulate your document metadata fields or attributes and content."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { lambdaArn: lambdaArn } } } } },
          '#withS3Bucket':: d.fn(help='"Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions."', args=[d.arg(name='s3Bucket', type=d.T.string)]),
          withS3Bucket(s3Bucket): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { preExtractionHookConfiguration+: { s3Bucket: s3Bucket } } } } },
        },
        '#withInlineConfigurations':: d.fn(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."', args=[d.arg(name='inlineConfigurations', type=d.T.array)]),
        withInlineConfigurations(inlineConfigurations): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { inlineConfigurations: if std.isArray(v=inlineConfigurations) then inlineConfigurations else [inlineConfigurations] } } } },
        '#withInlineConfigurationsMixin':: d.fn(help='"Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Kendra. Minimum number of 0 items. Maximum number of 100 items. Detailed below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inlineConfigurations', type=d.T.array)]),
        withInlineConfigurationsMixin(inlineConfigurations): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { inlineConfigurations+: if std.isArray(v=inlineConfigurations) then inlineConfigurations else [inlineConfigurations] } } } },
        '#withRoleArn':: d.fn(help='"The Amazon Resource Name (ARN) of a role with permission to run pre_extraction_hook_configuration and post_extraction_hook_configuration for altering document metadata and content during the document ingestion process. For more information, see IAM roles for Amazon Kendra."', args=[d.arg(name='roleArn', type=d.T.string)]),
        withRoleArn(roleArn): { spec+: { initProvider+: { customDocumentEnrichmentConfiguration+: { roleArn: roleArn } } } },
      },
      '#indexIdRef':: d.obj(help='"Reference to a Index in kendra to populate indexId."'),
      indexIdRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { indexIdRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { indexIdRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { initProvider+: { indexIdRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { indexIdRef+: { namespace: namespace } } } },
      },
      '#indexIdSelector':: d.obj(help='"Selector for a Index in kendra to populate indexId."'),
      indexIdSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { indexIdSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { indexIdSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { indexIdSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { initProvider+: { indexIdSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { indexIdSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { indexIdSelector+: { namespace: namespace } } } },
      },
      '#roleArnRef':: d.obj(help='"Reference to a Role in iam to populate roleArn."'),
      roleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { roleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { roleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { initProvider+: { roleArnRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { roleArnRef+: { namespace: namespace } } } },
      },
      '#roleArnSelector':: d.obj(help='"Selector for a Role in iam to populate roleArn."'),
      roleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { roleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { roleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { roleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { initProvider+: { roleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { roleArnSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { roleArnSelector+: { namespace: namespace } } } },
      },
      '#withDescription':: d.fn(help='"A description for the Data Source connector."', args=[d.arg(name='description', type=d.T.string)]),
      withDescription(description): { spec+: { initProvider+: { description: description } } },
      '#withIndexId':: d.fn(help='"The identifier of the index for your Amazon Kendra data source."', args=[d.arg(name='indexId', type=d.T.string)]),
      withIndexId(indexId): { spec+: { initProvider+: { indexId: indexId } } },
      '#withLanguageCode':: d.fn(help='"The code for a language. This allows you to support a language for all documents when creating the Data Source connector. English is supported by default. For more information on supported languages, including their codes, see Adding documents in languages other than English."', args=[d.arg(name='languageCode', type=d.T.string)]),
      withLanguageCode(languageCode): { spec+: { initProvider+: { languageCode: languageCode } } },
      '#withName':: d.fn(help='"A name for your data source connector."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { initProvider+: { name: name } } },
      '#withRoleArn':: d.fn(help="\"The Amazon Resource Name (ARN) of a role with permission to access the data source connector. For more information, see IAM roles for Amazon Kendra. You can't specify the role_arn parameter when the type parameter is set to CUSTOM. The role_arn parameter is required for all other data sources.\"", args=[d.arg(name='roleArn', type=d.T.string)]),
      withRoleArn(roleArn): { spec+: { initProvider+: { roleArn: roleArn } } },
      '#withSchedule':: d.fn(help="\"Sets the frequency for Amazon Kendra to check the documents in your Data Source repository and update the index. If you don't set a schedule Amazon Kendra will not periodically update the index. You can call the StartDataSourceSyncJob API to update the index.\"", args=[d.arg(name='schedule', type=d.T.string)]),
      withSchedule(schedule): { spec+: { initProvider+: { schedule: schedule } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { initProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { initProvider+: { tags+: tags } } },
      '#withType':: d.fn(help='"The type of data source repository. For an updated list of values, refer to Valid Values for Type."', args=[d.arg(name='type', type=d.T.string)]),
      withType(type): { spec+: { initProvider+: { type: type } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to\\ncreate, observe, update, and delete this managed resource should be\\nconfigured."'),
    providerConfigRef: {
      '#withKind':: d.fn(help='"Kind of the referenced object."', args=[d.arg(name='kind', type=d.T.string)]),
      withKind(kind): { spec+: { providerConfigRef+: { kind: kind } } },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#withManagementPolicies':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPolicies(managementPolicies): { spec+: { managementPolicies: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#withManagementPoliciesMixin':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPoliciesMixin(managementPolicies): { spec+: { managementPolicies+: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a\\nSecret to which any connection details for this managed resource should\\nbe written. Connection details frequently include the endpoint, username,\\nand password required to connect to the managed resource."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
