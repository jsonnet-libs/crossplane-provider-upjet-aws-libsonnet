{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='lifecyclePolicy', url='', help='"LifecyclePolicy is the Schema for the LifecyclePolicys API. Provides a Data Lifecycle Manager (DLM) lifecycle policy for managing snapshots."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of LifecyclePolicy', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'dlm.aws.m.upbound.io/v1beta1',
    kind: 'LifecyclePolicy',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"LifecyclePolicySpec defines the desired state of LifecyclePolicy"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#executionRoleArnRef':: d.obj(help='"Reference to a Role in iam to populate executionRoleArn."'),
      executionRoleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { executionRoleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { executionRoleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { executionRoleArnRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { executionRoleArnRef+: { namespace: namespace } } } },
      },
      '#executionRoleArnSelector':: d.obj(help='"Selector for a Role in iam to populate executionRoleArn."'),
      executionRoleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { executionRoleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { executionRoleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { executionRoleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { executionRoleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { executionRoleArnSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { forProvider+: { executionRoleArnSelector+: { namespace: namespace } } } },
      },
      '#policyDetails':: d.obj(help='"See the policy_details configuration block. Max of 1."'),
      policyDetails: {
        '#action':: d.obj(help='"The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the action configuration block."'),
        action: {
          '#crossRegionCopy':: d.obj(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."'),
          crossRegionCopy: {
            '#encryptionConfiguration':: d.obj(help='"The encryption settings for the copied snapshot. See the encryption_configuration block. Max of 1 per action."'),
            encryptionConfiguration: {
              '#withCmkArn':: d.fn(help='"The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used."', args=[d.arg(name='cmkArn', type=d.T.string)]),
              withCmkArn(cmkArn): { encryptionConfiguration+: { cmkArn: cmkArn } },
              '#withEncrypted':: d.fn(help='"To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled."', args=[d.arg(name='encrypted', type=d.T.boolean)]),
              withEncrypted(encrypted): { encryptionConfiguration+: { encrypted: encrypted } },
            },
            '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
            retainRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { retainRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
            },
            '#withTarget':: d.fn(help='"The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='target', type=d.T.string)]),
            withTarget(target): { target: target },
          },
          '#withCrossRegionCopy':: d.fn(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."', args=[d.arg(name='crossRegionCopy', type=d.T.array)]),
          withCrossRegionCopy(crossRegionCopy): { spec+: { forProvider+: { policyDetails+: { action+: { crossRegionCopy: if std.isArray(v=crossRegionCopy) then crossRegionCopy else [crossRegionCopy] } } } } },
          '#withCrossRegionCopyMixin':: d.fn(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='crossRegionCopy', type=d.T.array)]),
          withCrossRegionCopyMixin(crossRegionCopy): { spec+: { forProvider+: { policyDetails+: { action+: { crossRegionCopy+: if std.isArray(v=crossRegionCopy) then crossRegionCopy else [crossRegionCopy] } } } } },
          '#withName':: d.fn(help='"A descriptive name for the action."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { spec+: { forProvider+: { policyDetails+: { action+: { name: name } } } } },
        },
        '#eventSource':: d.obj(help='"The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the event_source configuration block."'),
        eventSource: {
          '#parameters':: d.obj(help='"A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block."'),
          parameters: {
            '#withDescriptionRegex':: d.fn(help='"The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account."', args=[d.arg(name='descriptionRegex', type=d.T.string)]),
            withDescriptionRegex(descriptionRegex): { spec+: { forProvider+: { policyDetails+: { eventSource+: { parameters+: { descriptionRegex: descriptionRegex } } } } } },
            '#withEventType':: d.fn(help='"The type of event. Currently, only shareSnapshot events are supported."', args=[d.arg(name='eventType', type=d.T.string)]),
            withEventType(eventType): { spec+: { forProvider+: { policyDetails+: { eventSource+: { parameters+: { eventType: eventType } } } } } },
            '#withSnapshotOwner':: d.fn(help='"The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account."', args=[d.arg(name='snapshotOwner', type=d.T.array)]),
            withSnapshotOwner(snapshotOwner): { spec+: { forProvider+: { policyDetails+: { eventSource+: { parameters+: { snapshotOwner: if std.isArray(v=snapshotOwner) then snapshotOwner else [snapshotOwner] } } } } } },
            '#withSnapshotOwnerMixin':: d.fn(help='"The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='snapshotOwner', type=d.T.array)]),
            withSnapshotOwnerMixin(snapshotOwner): { spec+: { forProvider+: { policyDetails+: { eventSource+: { parameters+: { snapshotOwner+: if std.isArray(v=snapshotOwner) then snapshotOwner else [snapshotOwner] } } } } } },
          },
          '#withType':: d.fn(help='"The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are MANAGED_CWE."', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { forProvider+: { policyDetails+: { eventSource+: { type: type } } } } },
        },
        '#exclusions':: d.obj(help='"Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs.  See the exclusions configuration block."'),
        exclusions: {
          '#withExcludeBootVolumes':: d.fn(help='"Indicates whether to exclude volumes that are attached to instances as the boot volume. To exclude boot volumes, specify true."', args=[d.arg(name='excludeBootVolumes', type=d.T.boolean)]),
          withExcludeBootVolumes(excludeBootVolumes): { spec+: { forProvider+: { policyDetails+: { exclusions+: { excludeBootVolumes: excludeBootVolumes } } } } },
          '#withExcludeTags':: d.fn(help='"Map specifies whether to exclude volumes that have specific tags."', args=[d.arg(name='excludeTags', type=d.T.object)]),
          withExcludeTags(excludeTags): { spec+: { forProvider+: { policyDetails+: { exclusions+: { excludeTags: excludeTags } } } } },
          '#withExcludeTagsMixin':: d.fn(help='"Map specifies whether to exclude volumes that have specific tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='excludeTags', type=d.T.object)]),
          withExcludeTagsMixin(excludeTags): { spec+: { forProvider+: { policyDetails+: { exclusions+: { excludeTags+: excludeTags } } } } },
          '#withExcludeVolumeTypes':: d.fn(help='"List specifies the volume types to exclude."', args=[d.arg(name='excludeVolumeTypes', type=d.T.array)]),
          withExcludeVolumeTypes(excludeVolumeTypes): { spec+: { forProvider+: { policyDetails+: { exclusions+: { excludeVolumeTypes: if std.isArray(v=excludeVolumeTypes) then excludeVolumeTypes else [excludeVolumeTypes] } } } } },
          '#withExcludeVolumeTypesMixin':: d.fn(help='"List specifies the volume types to exclude."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='excludeVolumeTypes', type=d.T.array)]),
          withExcludeVolumeTypesMixin(excludeVolumeTypes): { spec+: { forProvider+: { policyDetails+: { exclusions+: { excludeVolumeTypes+: if std.isArray(v=excludeVolumeTypes) then excludeVolumeTypes else [excludeVolumeTypes] } } } } },
        },
        '#parameters':: d.obj(help='"A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block."'),
        parameters: {
          '#withExcludeBootVolume':: d.fn(help='"Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is false."', args=[d.arg(name='excludeBootVolume', type=d.T.boolean)]),
          withExcludeBootVolume(excludeBootVolume): { spec+: { forProvider+: { policyDetails+: { parameters+: { excludeBootVolume: excludeBootVolume } } } } },
          '#withNoReboot':: d.fn(help='"Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. true indicates that targeted instances are not rebooted when the policy runs. false indicates that target instances are rebooted when the policy runs. The default is true (instances are not rebooted)."', args=[d.arg(name='noReboot', type=d.T.boolean)]),
          withNoReboot(noReboot): { spec+: { forProvider+: { policyDetails+: { parameters+: { noReboot: noReboot } } } } },
        },
        '#schedule':: d.obj(help='"See the schedule configuration block."'),
        schedule: {
          '#archiveRule':: d.obj(help='"Specifies a snapshot archiving rule for a schedule. See archive_rule block."'),
          archiveRule: {
            '#archiveRetainRule':: d.obj(help='"Information about the retention period for the snapshot archiving rule. See the archive_retain_rule block."'),
            archiveRetainRule: {
              '#retentionArchiveTier':: d.obj(help='"Information about retention period in the Amazon EBS Snapshots Archive. See the retention_archive_tier block."'),
              retentionArchiveTier: {
                '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
                withCount(count): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { count: count } } } },
                '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
                withInterval(interval): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { interval: interval } } } },
                '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
                withIntervalUnit(intervalUnit): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { intervalUnit: intervalUnit } } } },
              },
            },
          },
          '#createRule':: d.obj(help='"See the create_rule block. Max of 1 per schedule."'),
          createRule: {
            '#scripts':: d.obj(help='"Specifies pre and/or post scripts for a snapshot lifecycle policy that targets instances. Valid only when resource_type is INSTANCE. See the scripts configuration block."'),
            scripts: {
              '#withExecuteOperationOnScriptFailure':: d.fn(help='"Indicates whether Amazon Data Lifecycle Manager should default to crash-consistent snapshots if the pre script fails. The default is true."', args=[d.arg(name='executeOperationOnScriptFailure', type=d.T.boolean)]),
              withExecuteOperationOnScriptFailure(executeOperationOnScriptFailure): { createRule+: { scripts+: { executeOperationOnScriptFailure: executeOperationOnScriptFailure } } },
              '#withExecutionHandler':: d.fn(help='"The SSM document that includes the pre and/or post scripts to run. In case automating VSS backups, specify AWS_VSS_BACKUP. In case automating application-consistent snapshots for SAP HANA workloads, specify AWSSystemsManagerSAP-CreateDLMSnapshotForSAPHANA. If you are using a custom SSM document that you own, specify either the name or ARN of the SSM document."', args=[d.arg(name='executionHandler', type=d.T.string)]),
              withExecutionHandler(executionHandler): { createRule+: { scripts+: { executionHandler: executionHandler } } },
              '#withExecutionHandlerService':: d.fn(help='"Indicates the service used to execute the pre and/or post scripts. If using custom SSM documents or automating application-consistent snapshots of SAP HANA workloads, specify AWS_SYSTEMS_MANAGER. In case automating VSS Backups, omit this parameter. The default is AWS_SYSTEMS_MANAGER."', args=[d.arg(name='executionHandlerService', type=d.T.string)]),
              withExecutionHandlerService(executionHandlerService): { createRule+: { scripts+: { executionHandlerService: executionHandlerService } } },
              '#withExecutionTimeout':: d.fn(help='"Specifies a timeout period, in seconds, after which Amazon Data Lifecycle Manager fails the script run attempt if it has not completed. In case automating VSS Backups, omit this parameter. The default is 10."', args=[d.arg(name='executionTimeout', type=d.T.number)]),
              withExecutionTimeout(executionTimeout): { createRule+: { scripts+: { executionTimeout: executionTimeout } } },
              '#withMaximumRetryCount':: d.fn(help='"Specifies the number of times Amazon Data Lifecycle Manager should retry scripts that fail. Must be an integer between 0 and 3. The default is 0."', args=[d.arg(name='maximumRetryCount', type=d.T.number)]),
              withMaximumRetryCount(maximumRetryCount): { createRule+: { scripts+: { maximumRetryCount: maximumRetryCount } } },
              '#withStages':: d.fn(help='"List to indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager initiates snapshot creation. Valid values: PRE and POST. The default is PRE and POST"', args=[d.arg(name='stages', type=d.T.array)]),
              withStages(stages): { createRule+: { scripts+: { stages: if std.isArray(v=stages) then stages else [stages] } } },
              '#withStagesMixin':: d.fn(help='"List to indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager initiates snapshot creation. Valid values: PRE and POST. The default is PRE and POST"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stages', type=d.T.array)]),
              withStagesMixin(stages): { createRule+: { scripts+: { stages+: if std.isArray(v=stages) then stages else [stages] } } },
            },
            '#withCronExpression':: d.fn(help='"The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year. Conflicts with interval, interval_unit, and times."', args=[d.arg(name='cronExpression', type=d.T.string)]),
            withCronExpression(cronExpression): { createRule+: { cronExpression: cronExpression } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { createRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { createRule+: { intervalUnit: intervalUnit } },
            '#withLocation':: d.fn(help='"Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify CLOUD. To create snapshots on the same Outpost as the source resource, specify OUTPOST_LOCAL. If you omit this parameter, CLOUD is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are CLOUD and OUTPOST_LOCAL."', args=[d.arg(name='location', type=d.T.string)]),
            withLocation(location): { createRule+: { location: location } },
            '#withTimes':: d.fn(help='"A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='times', type=d.T.array)]),
            withTimes(times): { createRule+: { times: if std.isArray(v=times) then times else [times] } },
            '#withTimesMixin':: d.fn(help='"A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with cron_expression. Must be set if interval is set."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='times', type=d.T.array)]),
            withTimesMixin(times): { createRule+: { times+: if std.isArray(v=times) then times else [times] } },
          },
          '#crossRegionCopyRule':: d.obj(help='"See the cross_region_copy_rule block. Max of 3 per schedule."'),
          crossRegionCopyRule: {
            '#cmkArnRef':: d.obj(help='"Reference to a Key in kms to populate cmkArn."'),
            cmkArnRef: {
              '#policy':: d.obj(help='"Policies for referencing."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { cmkArnRef+: { policy+: { resolution: resolution } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { cmkArnRef+: { policy+: { resolve: resolve } } },
              },
              '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cmkArnRef+: { name: name } },
              '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { cmkArnRef+: { namespace: namespace } },
            },
            '#cmkArnSelector':: d.obj(help='"Selector for a Key in kms to populate cmkArn."'),
            cmkArnSelector: {
              '#policy':: d.obj(help='"Policies for selection."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { cmkArnSelector+: { policy+: { resolution: resolution } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { cmkArnSelector+: { policy+: { resolve: resolve } } },
              },
              '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
              withMatchControllerRef(matchControllerRef): { cmkArnSelector+: { matchControllerRef: matchControllerRef } },
              '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { cmkArnSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { cmkArnSelector+: { matchLabels+: matchLabels } },
              '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { cmkArnSelector+: { namespace: namespace } },
            },
            '#deprecateRule':: d.obj(help='"See the deprecate_rule block. Max of 1 per schedule."'),
            deprecateRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { deprecateRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { deprecateRule+: { intervalUnit: intervalUnit } },
            },
            '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
            retainRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { retainRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
            },
            '#withCmkArn':: d.fn(help='"The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used."', args=[d.arg(name='cmkArn', type=d.T.string)]),
            withCmkArn(cmkArn): { cmkArn: cmkArn },
            '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
            withCopyTags(copyTags): { copyTags: copyTags },
            '#withEncrypted':: d.fn(help='"To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled."', args=[d.arg(name='encrypted', type=d.T.boolean)]),
            withEncrypted(encrypted): { encrypted: encrypted },
            '#withTarget':: d.fn(help='"The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='target', type=d.T.string)]),
            withTarget(target): { target: target },
            '#withTargetRegion':: d.fn(help='"Use only for DLM policies of policy_type=IMAGE_MANAGEMENT. The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='targetRegion', type=d.T.string)]),
            withTargetRegion(targetRegion): { targetRegion: targetRegion },
          },
          '#deprecateRule':: d.obj(help='"See the deprecate_rule block. Max of 1 per schedule."'),
          deprecateRule: {
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { deprecateRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { deprecateRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { deprecateRule+: { intervalUnit: intervalUnit } },
          },
          '#fastRestoreRule':: d.obj(help='"See the fast_restore_rule block. Max of 1 per schedule."'),
          fastRestoreRule: {
            '#withAvailabilityZones':: d.fn(help='"The Availability Zones in which to enable fast snapshot restore."', args=[d.arg(name='availabilityZones', type=d.T.array)]),
            withAvailabilityZones(availabilityZones): { fastRestoreRule+: { availabilityZones: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
            '#withAvailabilityZonesMixin':: d.fn(help='"The Availability Zones in which to enable fast snapshot restore."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='availabilityZones', type=d.T.array)]),
            withAvailabilityZonesMixin(availabilityZones): { fastRestoreRule+: { availabilityZones+: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { fastRestoreRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { fastRestoreRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { fastRestoreRule+: { intervalUnit: intervalUnit } },
          },
          '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
          retainRule: {
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { retainRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { retainRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
          },
          '#shareRule':: d.obj(help='"See the share_rule block. Max of 1 per schedule."'),
          shareRule: {
            '#withTargetAccounts':: d.fn(help='"The IDs of the AWS accounts with which to share the snapshots."', args=[d.arg(name='targetAccounts', type=d.T.array)]),
            withTargetAccounts(targetAccounts): { shareRule+: { targetAccounts: if std.isArray(v=targetAccounts) then targetAccounts else [targetAccounts] } },
            '#withTargetAccountsMixin':: d.fn(help='"The IDs of the AWS accounts with which to share the snapshots."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetAccounts', type=d.T.array)]),
            withTargetAccountsMixin(targetAccounts): { shareRule+: { targetAccounts+: if std.isArray(v=targetAccounts) then targetAccounts else [targetAccounts] } },
            '#withUnshareInterval':: d.fn(help='"The period after which snapshots that are shared with other AWS accounts are automatically unshared."', args=[d.arg(name='unshareInterval', type=d.T.number)]),
            withUnshareInterval(unshareInterval): { shareRule+: { unshareInterval: unshareInterval } },
            '#withUnshareIntervalUnit':: d.fn(help='"The unit of time for the automatic unsharing interval. Valid values are DAYS, WEEKS, MONTHS, YEARS."', args=[d.arg(name='unshareIntervalUnit', type=d.T.string)]),
            withUnshareIntervalUnit(unshareIntervalUnit): { shareRule+: { unshareIntervalUnit: unshareIntervalUnit } },
          },
          '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
          withCopyTags(copyTags): { copyTags: copyTags },
          '#withCrossRegionCopyRule':: d.fn(help='"See the cross_region_copy_rule block. Max of 3 per schedule."', args=[d.arg(name='crossRegionCopyRule', type=d.T.array)]),
          withCrossRegionCopyRule(crossRegionCopyRule): { crossRegionCopyRule: if std.isArray(v=crossRegionCopyRule) then crossRegionCopyRule else [crossRegionCopyRule] },
          '#withCrossRegionCopyRuleMixin':: d.fn(help='"See the cross_region_copy_rule block. Max of 3 per schedule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='crossRegionCopyRule', type=d.T.array)]),
          withCrossRegionCopyRuleMixin(crossRegionCopyRule): { crossRegionCopyRule+: if std.isArray(v=crossRegionCopyRule) then crossRegionCopyRule else [crossRegionCopyRule] },
          '#withName':: d.fn(help='"A descriptive name for the action."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withTagsToAdd':: d.fn(help='"A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these."', args=[d.arg(name='tagsToAdd', type=d.T.object)]),
          withTagsToAdd(tagsToAdd): { tagsToAdd: tagsToAdd },
          '#withTagsToAddMixin':: d.fn(help='"A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tagsToAdd', type=d.T.object)]),
          withTagsToAddMixin(tagsToAdd): { tagsToAdd+: tagsToAdd },
          '#withVariableTags':: d.fn(help='"A map of tag keys and variable values, where the values are determined when the policy is executed. Only $(instance-id) or $(timestamp) are valid values. Can only be used when resource_types is INSTANCE."', args=[d.arg(name='variableTags', type=d.T.object)]),
          withVariableTags(variableTags): { variableTags: variableTags },
          '#withVariableTagsMixin':: d.fn(help='"A map of tag keys and variable values, where the values are determined when the policy is executed. Only $(instance-id) or $(timestamp) are valid values. Can only be used when resource_types is INSTANCE."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variableTags', type=d.T.object)]),
          withVariableTagsMixin(variableTags): { variableTags+: variableTags },
        },
        '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
        withCopyTags(copyTags): { spec+: { forProvider+: { policyDetails+: { copyTags: copyTags } } } },
        '#withCreateInterval':: d.fn(help='"How often the policy should run and create snapshots or AMIs. valid values range from 1 to 7. Default value is 1."', args=[d.arg(name='createInterval', type=d.T.number)]),
        withCreateInterval(createInterval): { spec+: { forProvider+: { policyDetails+: { createInterval: createInterval } } } },
        '#withExtendDeletion':: d.fn(help='"snapshot or AMI retention behavior for the policy if the source volume or instance is deleted, or if the policy enters the error, disabled, or deleted state. Default value is false."', args=[d.arg(name='extendDeletion', type=d.T.boolean)]),
        withExtendDeletion(extendDeletion): { spec+: { forProvider+: { policyDetails+: { extendDeletion: extendDeletion } } } },
        '#withPolicyLanguage':: d.fn(help='"Type of policy to create. SIMPLIFIED To create a default policy. STANDARD To create a custom policy."', args=[d.arg(name='policyLanguage', type=d.T.string)]),
        withPolicyLanguage(policyLanguage): { spec+: { forProvider+: { policyDetails+: { policyLanguage: policyLanguage } } } },
        '#withPolicyType':: d.fn(help='"The valid target resource types and actions a policy can manage. Specify EBS_SNAPSHOT_MANAGEMENT to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is EBS_SNAPSHOT_MANAGEMENT."', args=[d.arg(name='policyType', type=d.T.string)]),
        withPolicyType(policyType): { spec+: { forProvider+: { policyDetails+: { policyType: policyType } } } },
        '#withResourceLocations':: d.fn(help='"The location of the resources to backup. If the source resources are located in an AWS Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If the source resources are located in a Local Zone, specify LOCAL_ZONE. Valid values are CLOUD, LOCAL_ZONE, and OUTPOST."', args=[d.arg(name='resourceLocations', type=d.T.array)]),
        withResourceLocations(resourceLocations): { spec+: { forProvider+: { policyDetails+: { resourceLocations: if std.isArray(v=resourceLocations) then resourceLocations else [resourceLocations] } } } },
        '#withResourceLocationsMixin':: d.fn(help='"The location of the resources to backup. If the source resources are located in an AWS Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If the source resources are located in a Local Zone, specify LOCAL_ZONE. Valid values are CLOUD, LOCAL_ZONE, and OUTPOST."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceLocations', type=d.T.array)]),
        withResourceLocationsMixin(resourceLocations): { spec+: { forProvider+: { policyDetails+: { resourceLocations+: if std.isArray(v=resourceLocations) then resourceLocations else [resourceLocations] } } } },
        '#withResourceType':: d.fn(help='"Type of default policy to create. Valid values are VOLUME and INSTANCE."', args=[d.arg(name='resourceType', type=d.T.string)]),
        withResourceType(resourceType): { spec+: { forProvider+: { policyDetails+: { resourceType: resourceType } } } },
        '#withResourceTypes':: d.fn(help='"A list of resource types that should be targeted by the lifecycle policy. Valid values are VOLUME and INSTANCE."', args=[d.arg(name='resourceTypes', type=d.T.array)]),
        withResourceTypes(resourceTypes): { spec+: { forProvider+: { policyDetails+: { resourceTypes: if std.isArray(v=resourceTypes) then resourceTypes else [resourceTypes] } } } },
        '#withResourceTypesMixin':: d.fn(help='"A list of resource types that should be targeted by the lifecycle policy. Valid values are VOLUME and INSTANCE."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceTypes', type=d.T.array)]),
        withResourceTypesMixin(resourceTypes): { spec+: { forProvider+: { policyDetails+: { resourceTypes+: if std.isArray(v=resourceTypes) then resourceTypes else [resourceTypes] } } } },
        '#withRetainInterval':: d.fn(help='"Specifies how long the policy should retain snapshots or AMIs before deleting them. valid values range from 2 to 14. Default value is 7."', args=[d.arg(name='retainInterval', type=d.T.number)]),
        withRetainInterval(retainInterval): { spec+: { forProvider+: { policyDetails+: { retainInterval: retainInterval } } } },
        '#withSchedule':: d.fn(help='"See the schedule configuration block."', args=[d.arg(name='schedule', type=d.T.array)]),
        withSchedule(schedule): { spec+: { forProvider+: { policyDetails+: { schedule: if std.isArray(v=schedule) then schedule else [schedule] } } } },
        '#withScheduleMixin':: d.fn(help='"See the schedule configuration block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='schedule', type=d.T.array)]),
        withScheduleMixin(schedule): { spec+: { forProvider+: { policyDetails+: { schedule+: if std.isArray(v=schedule) then schedule else [schedule] } } } },
        '#withTargetTags':: d.fn(help='"A map of tag keys and their values. Any resources that match the resource_types and are tagged with any of these tags will be targeted. Required when policy_type is EBS_SNAPSHOT_MANAGEMENT or IMAGE_MANAGEMENT. Must not be specified when policy_type is EVENT_BASED_POLICY."', args=[d.arg(name='targetTags', type=d.T.object)]),
        withTargetTags(targetTags): { spec+: { forProvider+: { policyDetails+: { targetTags: targetTags } } } },
        '#withTargetTagsMixin':: d.fn(help='"A map of tag keys and their values. Any resources that match the resource_types and are tagged with any of these tags will be targeted. Required when policy_type is EBS_SNAPSHOT_MANAGEMENT or IMAGE_MANAGEMENT. Must not be specified when policy_type is EVENT_BASED_POLICY."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetTags', type=d.T.object)]),
        withTargetTagsMixin(targetTags): { spec+: { forProvider+: { policyDetails+: { targetTags+: targetTags } } } },
      },
      '#withDefaultPolicy':: d.fn(help='"Specify the type of default policy to create. valid values are VOLUME or INSTANCE."', args=[d.arg(name='defaultPolicy', type=d.T.string)]),
      withDefaultPolicy(defaultPolicy): { spec+: { forProvider+: { defaultPolicy: defaultPolicy } } },
      '#withDescription':: d.fn(help='"A description for the DLM lifecycle policy."', args=[d.arg(name='description', type=d.T.string)]),
      withDescription(description): { spec+: { forProvider+: { description: description } } },
      '#withExecutionRoleArn':: d.fn(help='"The ARN of an IAM role that is able to be assumed by the DLM service."', args=[d.arg(name='executionRoleArn', type=d.T.string)]),
      withExecutionRoleArn(executionRoleArn): { spec+: { forProvider+: { executionRoleArn: executionRoleArn } } },
      '#withRegion':: d.fn(help="\"Region where this resource will be managed. Defaults to the Region set in the provider configuration.\\nRegion is the region you'd like your resource to be created in.\"", args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { spec+: { forProvider+: { region: region } } },
      '#withState':: d.fn(help='"Whether the lifecycle policy should be enabled or disabled. ENABLED or DISABLED are valid values. Defaults to ENABLED."', args=[d.arg(name='state', type=d.T.string)]),
      withState(state): { spec+: { forProvider+: { state: state } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { forProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: tags } } },
    },
    '#initProvider':: d.obj(help='"THIS IS A BETA FIELD. It will be honored\\nunless the Management Policies feature flag is disabled.\\nInitProvider holds the same fields as ForProvider, with the exception\\nof Identifier and other resource reference fields. The fields that are\\nin InitProvider are merged into ForProvider when the resource is created.\\nThe same fields are also added to the terraform ignore_changes hook, to\\navoid updating them after creation. This is useful for fields that are\\nrequired on creation, but we do not desire to update them after creation,\\nfor example because of an external controller is managing them, like an\\nautoscaler."'),
    initProvider: {
      '#executionRoleArnRef':: d.obj(help='"Reference to a Role in iam to populate executionRoleArn."'),
      executionRoleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { executionRoleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { executionRoleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { initProvider+: { executionRoleArnRef+: { name: name } } } },
        '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { executionRoleArnRef+: { namespace: namespace } } } },
      },
      '#executionRoleArnSelector':: d.obj(help='"Selector for a Role in iam to populate executionRoleArn."'),
      executionRoleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { executionRoleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { executionRoleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { executionRoleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { initProvider+: { executionRoleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { executionRoleArnSelector+: { matchLabels+: matchLabels } } } },
        '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
        withNamespace(namespace): { spec+: { initProvider+: { executionRoleArnSelector+: { namespace: namespace } } } },
      },
      '#policyDetails':: d.obj(help='"See the policy_details configuration block. Max of 1."'),
      policyDetails: {
        '#action':: d.obj(help='"The actions to be performed when the event-based policy is triggered. You can specify only one action per policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the action configuration block."'),
        action: {
          '#crossRegionCopy':: d.obj(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."'),
          crossRegionCopy: {
            '#encryptionConfiguration':: d.obj(help='"The encryption settings for the copied snapshot. See the encryption_configuration block. Max of 1 per action."'),
            encryptionConfiguration: {
              '#withCmkArn':: d.fn(help='"The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used."', args=[d.arg(name='cmkArn', type=d.T.string)]),
              withCmkArn(cmkArn): { encryptionConfiguration+: { cmkArn: cmkArn } },
              '#withEncrypted':: d.fn(help='"To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled."', args=[d.arg(name='encrypted', type=d.T.boolean)]),
              withEncrypted(encrypted): { encryptionConfiguration+: { encrypted: encrypted } },
            },
            '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
            retainRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { retainRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
            },
            '#withTarget':: d.fn(help='"The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='target', type=d.T.string)]),
            withTarget(target): { target: target },
          },
          '#withCrossRegionCopy':: d.fn(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."', args=[d.arg(name='crossRegionCopy', type=d.T.array)]),
          withCrossRegionCopy(crossRegionCopy): { spec+: { initProvider+: { policyDetails+: { action+: { crossRegionCopy: if std.isArray(v=crossRegionCopy) then crossRegionCopy else [crossRegionCopy] } } } } },
          '#withCrossRegionCopyMixin':: d.fn(help='"The rule for copying shared snapshots across Regions. See the cross_region_copy configuration block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='crossRegionCopy', type=d.T.array)]),
          withCrossRegionCopyMixin(crossRegionCopy): { spec+: { initProvider+: { policyDetails+: { action+: { crossRegionCopy+: if std.isArray(v=crossRegionCopy) then crossRegionCopy else [crossRegionCopy] } } } } },
          '#withName':: d.fn(help='"A descriptive name for the action."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { spec+: { initProvider+: { policyDetails+: { action+: { name: name } } } } },
        },
        '#eventSource':: d.obj(help='"The event that triggers the event-based policy. This parameter is required for event-based policies only. If you are creating a snapshot or AMI policy, omit this parameter. See the event_source configuration block."'),
        eventSource: {
          '#parameters':: d.obj(help='"A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block."'),
          parameters: {
            '#withDescriptionRegex':: d.fn(help='"The snapshot description that can trigger the policy. The description pattern is specified using a regular expression. The policy runs only if a snapshot with a description that matches the specified pattern is shared with your account."', args=[d.arg(name='descriptionRegex', type=d.T.string)]),
            withDescriptionRegex(descriptionRegex): { spec+: { initProvider+: { policyDetails+: { eventSource+: { parameters+: { descriptionRegex: descriptionRegex } } } } } },
            '#withEventType':: d.fn(help='"The type of event. Currently, only shareSnapshot events are supported."', args=[d.arg(name='eventType', type=d.T.string)]),
            withEventType(eventType): { spec+: { initProvider+: { policyDetails+: { eventSource+: { parameters+: { eventType: eventType } } } } } },
            '#withSnapshotOwner':: d.fn(help='"The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account."', args=[d.arg(name='snapshotOwner', type=d.T.array)]),
            withSnapshotOwner(snapshotOwner): { spec+: { initProvider+: { policyDetails+: { eventSource+: { parameters+: { snapshotOwner: if std.isArray(v=snapshotOwner) then snapshotOwner else [snapshotOwner] } } } } } },
            '#withSnapshotOwnerMixin':: d.fn(help='"The IDs of the AWS accounts that can trigger policy by sharing snapshots with your account. The policy only runs if one of the specified AWS accounts shares a snapshot with your account."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='snapshotOwner', type=d.T.array)]),
            withSnapshotOwnerMixin(snapshotOwner): { spec+: { initProvider+: { policyDetails+: { eventSource+: { parameters+: { snapshotOwner+: if std.isArray(v=snapshotOwner) then snapshotOwner else [snapshotOwner] } } } } } },
          },
          '#withType':: d.fn(help='"The source of the event. Currently only managed CloudWatch Events rules are supported. Valid values are MANAGED_CWE."', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { initProvider+: { policyDetails+: { eventSource+: { type: type } } } } },
        },
        '#exclusions':: d.obj(help='"Specifies exclusion parameters for volumes or instances for which you do not want to create snapshots or AMIs.  See the exclusions configuration block."'),
        exclusions: {
          '#withExcludeBootVolumes':: d.fn(help='"Indicates whether to exclude volumes that are attached to instances as the boot volume. To exclude boot volumes, specify true."', args=[d.arg(name='excludeBootVolumes', type=d.T.boolean)]),
          withExcludeBootVolumes(excludeBootVolumes): { spec+: { initProvider+: { policyDetails+: { exclusions+: { excludeBootVolumes: excludeBootVolumes } } } } },
          '#withExcludeTags':: d.fn(help='"Map specifies whether to exclude volumes that have specific tags."', args=[d.arg(name='excludeTags', type=d.T.object)]),
          withExcludeTags(excludeTags): { spec+: { initProvider+: { policyDetails+: { exclusions+: { excludeTags: excludeTags } } } } },
          '#withExcludeTagsMixin':: d.fn(help='"Map specifies whether to exclude volumes that have specific tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='excludeTags', type=d.T.object)]),
          withExcludeTagsMixin(excludeTags): { spec+: { initProvider+: { policyDetails+: { exclusions+: { excludeTags+: excludeTags } } } } },
          '#withExcludeVolumeTypes':: d.fn(help='"List specifies the volume types to exclude."', args=[d.arg(name='excludeVolumeTypes', type=d.T.array)]),
          withExcludeVolumeTypes(excludeVolumeTypes): { spec+: { initProvider+: { policyDetails+: { exclusions+: { excludeVolumeTypes: if std.isArray(v=excludeVolumeTypes) then excludeVolumeTypes else [excludeVolumeTypes] } } } } },
          '#withExcludeVolumeTypesMixin':: d.fn(help='"List specifies the volume types to exclude."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='excludeVolumeTypes', type=d.T.array)]),
          withExcludeVolumeTypesMixin(excludeVolumeTypes): { spec+: { initProvider+: { policyDetails+: { exclusions+: { excludeVolumeTypes+: if std.isArray(v=excludeVolumeTypes) then excludeVolumeTypes else [excludeVolumeTypes] } } } } },
        },
        '#parameters':: d.obj(help='"A set of optional parameters for snapshot and AMI lifecycle policies. See the parameters configuration block."'),
        parameters: {
          '#withExcludeBootVolume':: d.fn(help='"Indicates whether to exclude the root volume from snapshots created using CreateSnapshots. The default is false."', args=[d.arg(name='excludeBootVolume', type=d.T.boolean)]),
          withExcludeBootVolume(excludeBootVolume): { spec+: { initProvider+: { policyDetails+: { parameters+: { excludeBootVolume: excludeBootVolume } } } } },
          '#withNoReboot':: d.fn(help='"Applies to AMI lifecycle policies only. Indicates whether targeted instances are rebooted when the lifecycle policy runs. true indicates that targeted instances are not rebooted when the policy runs. false indicates that target instances are rebooted when the policy runs. The default is true (instances are not rebooted)."', args=[d.arg(name='noReboot', type=d.T.boolean)]),
          withNoReboot(noReboot): { spec+: { initProvider+: { policyDetails+: { parameters+: { noReboot: noReboot } } } } },
        },
        '#schedule':: d.obj(help='"See the schedule configuration block."'),
        schedule: {
          '#archiveRule':: d.obj(help='"Specifies a snapshot archiving rule for a schedule. See archive_rule block."'),
          archiveRule: {
            '#archiveRetainRule':: d.obj(help='"Information about the retention period for the snapshot archiving rule. See the archive_retain_rule block."'),
            archiveRetainRule: {
              '#retentionArchiveTier':: d.obj(help='"Information about retention period in the Amazon EBS Snapshots Archive. See the retention_archive_tier block."'),
              retentionArchiveTier: {
                '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
                withCount(count): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { count: count } } } },
                '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
                withInterval(interval): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { interval: interval } } } },
                '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
                withIntervalUnit(intervalUnit): { archiveRule+: { archiveRetainRule+: { retentionArchiveTier+: { intervalUnit: intervalUnit } } } },
              },
            },
          },
          '#createRule':: d.obj(help='"See the create_rule block. Max of 1 per schedule."'),
          createRule: {
            '#scripts':: d.obj(help='"Specifies pre and/or post scripts for a snapshot lifecycle policy that targets instances. Valid only when resource_type is INSTANCE. See the scripts configuration block."'),
            scripts: {
              '#withExecuteOperationOnScriptFailure':: d.fn(help='"Indicates whether Amazon Data Lifecycle Manager should default to crash-consistent snapshots if the pre script fails. The default is true."', args=[d.arg(name='executeOperationOnScriptFailure', type=d.T.boolean)]),
              withExecuteOperationOnScriptFailure(executeOperationOnScriptFailure): { createRule+: { scripts+: { executeOperationOnScriptFailure: executeOperationOnScriptFailure } } },
              '#withExecutionHandler':: d.fn(help='"The SSM document that includes the pre and/or post scripts to run. In case automating VSS backups, specify AWS_VSS_BACKUP. In case automating application-consistent snapshots for SAP HANA workloads, specify AWSSystemsManagerSAP-CreateDLMSnapshotForSAPHANA. If you are using a custom SSM document that you own, specify either the name or ARN of the SSM document."', args=[d.arg(name='executionHandler', type=d.T.string)]),
              withExecutionHandler(executionHandler): { createRule+: { scripts+: { executionHandler: executionHandler } } },
              '#withExecutionHandlerService':: d.fn(help='"Indicates the service used to execute the pre and/or post scripts. If using custom SSM documents or automating application-consistent snapshots of SAP HANA workloads, specify AWS_SYSTEMS_MANAGER. In case automating VSS Backups, omit this parameter. The default is AWS_SYSTEMS_MANAGER."', args=[d.arg(name='executionHandlerService', type=d.T.string)]),
              withExecutionHandlerService(executionHandlerService): { createRule+: { scripts+: { executionHandlerService: executionHandlerService } } },
              '#withExecutionTimeout':: d.fn(help='"Specifies a timeout period, in seconds, after which Amazon Data Lifecycle Manager fails the script run attempt if it has not completed. In case automating VSS Backups, omit this parameter. The default is 10."', args=[d.arg(name='executionTimeout', type=d.T.number)]),
              withExecutionTimeout(executionTimeout): { createRule+: { scripts+: { executionTimeout: executionTimeout } } },
              '#withMaximumRetryCount':: d.fn(help='"Specifies the number of times Amazon Data Lifecycle Manager should retry scripts that fail. Must be an integer between 0 and 3. The default is 0."', args=[d.arg(name='maximumRetryCount', type=d.T.number)]),
              withMaximumRetryCount(maximumRetryCount): { createRule+: { scripts+: { maximumRetryCount: maximumRetryCount } } },
              '#withStages':: d.fn(help='"List to indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager initiates snapshot creation. Valid values: PRE and POST. The default is PRE and POST"', args=[d.arg(name='stages', type=d.T.array)]),
              withStages(stages): { createRule+: { scripts+: { stages: if std.isArray(v=stages) then stages else [stages] } } },
              '#withStagesMixin':: d.fn(help='"List to indicate which scripts Amazon Data Lifecycle Manager should run on target instances. Pre scripts run before Amazon Data Lifecycle Manager initiates snapshot creation. Post scripts run after Amazon Data Lifecycle Manager initiates snapshot creation. Valid values: PRE and POST. The default is PRE and POST"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='stages', type=d.T.array)]),
              withStagesMixin(stages): { createRule+: { scripts+: { stages+: if std.isArray(v=stages) then stages else [stages] } } },
            },
            '#withCronExpression':: d.fn(help='"The schedule, as a Cron expression. The schedule interval must be between 1 hour and 1 year. Conflicts with interval, interval_unit, and times."', args=[d.arg(name='cronExpression', type=d.T.string)]),
            withCronExpression(cronExpression): { createRule+: { cronExpression: cronExpression } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { createRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { createRule+: { intervalUnit: intervalUnit } },
            '#withLocation':: d.fn(help='"Specifies the destination for snapshots created by the policy. To create snapshots in the same Region as the source resource, specify CLOUD. To create snapshots on the same Outpost as the source resource, specify OUTPOST_LOCAL. If you omit this parameter, CLOUD is used by default. If the policy targets resources in an AWS Region, then you must create snapshots in the same Region as the source resource. If the policy targets resources on an Outpost, then you can create snapshots on the same Outpost as the source resource, or in the Region of that Outpost. Valid values are CLOUD and OUTPOST_LOCAL."', args=[d.arg(name='location', type=d.T.string)]),
            withLocation(location): { createRule+: { location: location } },
            '#withTimes':: d.fn(help='"A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='times', type=d.T.array)]),
            withTimes(times): { createRule+: { times: if std.isArray(v=times) then times else [times] } },
            '#withTimesMixin':: d.fn(help='"A list of times in 24 hour clock format that sets when the lifecycle policy should be evaluated. Max of 1. Conflicts with cron_expression. Must be set if interval is set."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='times', type=d.T.array)]),
            withTimesMixin(times): { createRule+: { times+: if std.isArray(v=times) then times else [times] } },
          },
          '#crossRegionCopyRule':: d.obj(help='"See the cross_region_copy_rule block. Max of 3 per schedule."'),
          crossRegionCopyRule: {
            '#cmkArnRef':: d.obj(help='"Reference to a Key in kms to populate cmkArn."'),
            cmkArnRef: {
              '#policy':: d.obj(help='"Policies for referencing."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { cmkArnRef+: { policy+: { resolution: resolution } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { cmkArnRef+: { policy+: { resolve: resolve } } },
              },
              '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { cmkArnRef+: { name: name } },
              '#withNamespace':: d.fn(help='"Namespace of the referenced object"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { cmkArnRef+: { namespace: namespace } },
            },
            '#cmkArnSelector':: d.obj(help='"Selector for a Key in kms to populate cmkArn."'),
            cmkArnSelector: {
              '#policy':: d.obj(help='"Policies for selection."'),
              policy: {
                '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
                withResolution(resolution): { cmkArnSelector+: { policy+: { resolution: resolution } } },
                '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
                withResolve(resolve): { cmkArnSelector+: { policy+: { resolve: resolve } } },
              },
              '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
              withMatchControllerRef(matchControllerRef): { cmkArnSelector+: { matchControllerRef: matchControllerRef } },
              '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { cmkArnSelector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { cmkArnSelector+: { matchLabels+: matchLabels } },
              '#withNamespace':: d.fn(help='"Namespace for the selector"', args=[d.arg(name='namespace', type=d.T.string)]),
              withNamespace(namespace): { cmkArnSelector+: { namespace: namespace } },
            },
            '#deprecateRule':: d.obj(help='"See the deprecate_rule block. Max of 1 per schedule."'),
            deprecateRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { deprecateRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { deprecateRule+: { intervalUnit: intervalUnit } },
            },
            '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
            retainRule: {
              '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
              withInterval(interval): { retainRule+: { interval: interval } },
              '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
              withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
            },
            '#withCmkArn':: d.fn(help='"The Amazon Resource Name (ARN) of the AWS KMS key to use for EBS encryption. If this parameter is not specified, the default KMS key for the account is used."', args=[d.arg(name='cmkArn', type=d.T.string)]),
            withCmkArn(cmkArn): { cmkArn: cmkArn },
            '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
            withCopyTags(copyTags): { copyTags: copyTags },
            '#withEncrypted':: d.fn(help='"To encrypt a copy of an unencrypted snapshot when encryption by default is not enabled, enable encryption using this parameter. Copies of encrypted snapshots are encrypted, even if this parameter is false or when encryption by default is not enabled."', args=[d.arg(name='encrypted', type=d.T.boolean)]),
            withEncrypted(encrypted): { encrypted: encrypted },
            '#withTarget':: d.fn(help='"The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='target', type=d.T.string)]),
            withTarget(target): { target: target },
            '#withTargetRegion':: d.fn(help='"Use only for DLM policies of policy_type=IMAGE_MANAGEMENT. The target Region or the Amazon Resource Name (ARN) of the target Outpost for the snapshot copies."', args=[d.arg(name='targetRegion', type=d.T.string)]),
            withTargetRegion(targetRegion): { targetRegion: targetRegion },
          },
          '#deprecateRule':: d.obj(help='"See the deprecate_rule block. Max of 1 per schedule."'),
          deprecateRule: {
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { deprecateRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { deprecateRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { deprecateRule+: { intervalUnit: intervalUnit } },
          },
          '#fastRestoreRule':: d.obj(help='"See the fast_restore_rule block. Max of 1 per schedule."'),
          fastRestoreRule: {
            '#withAvailabilityZones':: d.fn(help='"The Availability Zones in which to enable fast snapshot restore."', args=[d.arg(name='availabilityZones', type=d.T.array)]),
            withAvailabilityZones(availabilityZones): { fastRestoreRule+: { availabilityZones: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
            '#withAvailabilityZonesMixin':: d.fn(help='"The Availability Zones in which to enable fast snapshot restore."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='availabilityZones', type=d.T.array)]),
            withAvailabilityZonesMixin(availabilityZones): { fastRestoreRule+: { availabilityZones+: if std.isArray(v=availabilityZones) then availabilityZones else [availabilityZones] } },
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { fastRestoreRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { fastRestoreRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { fastRestoreRule+: { intervalUnit: intervalUnit } },
          },
          '#retainRule':: d.obj(help='"Specifies the retention rule for cross-Region snapshot copies. See the retain_rule block. Max of 1 per action."'),
          retainRule: {
            '#withCount':: d.fn(help='"Specifies the number of oldest AMIs to deprecate. Must be an integer between 1 and 1000. Conflicts with interval and interval_unit."', args=[d.arg(name='count', type=d.T.number)]),
            withCount(count): { retainRule+: { count: count } },
            '#withInterval':: d.fn(help='"How often this lifecycle policy should be evaluated. 1, 2,3,4,6,8,12 or 24 are valid values. Conflicts with cron_expression. If set, interval_unit and times must also be set."', args=[d.arg(name='interval', type=d.T.number)]),
            withInterval(interval): { retainRule+: { interval: interval } },
            '#withIntervalUnit':: d.fn(help='"The unit for how often the lifecycle policy should be evaluated. HOURS is currently the only allowed value and also the default value. Conflicts with cron_expression. Must be set if interval is set."', args=[d.arg(name='intervalUnit', type=d.T.string)]),
            withIntervalUnit(intervalUnit): { retainRule+: { intervalUnit: intervalUnit } },
          },
          '#shareRule':: d.obj(help='"See the share_rule block. Max of 1 per schedule."'),
          shareRule: {
            '#withTargetAccounts':: d.fn(help='"The IDs of the AWS accounts with which to share the snapshots."', args=[d.arg(name='targetAccounts', type=d.T.array)]),
            withTargetAccounts(targetAccounts): { shareRule+: { targetAccounts: if std.isArray(v=targetAccounts) then targetAccounts else [targetAccounts] } },
            '#withTargetAccountsMixin':: d.fn(help='"The IDs of the AWS accounts with which to share the snapshots."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetAccounts', type=d.T.array)]),
            withTargetAccountsMixin(targetAccounts): { shareRule+: { targetAccounts+: if std.isArray(v=targetAccounts) then targetAccounts else [targetAccounts] } },
            '#withUnshareInterval':: d.fn(help='"The period after which snapshots that are shared with other AWS accounts are automatically unshared."', args=[d.arg(name='unshareInterval', type=d.T.number)]),
            withUnshareInterval(unshareInterval): { shareRule+: { unshareInterval: unshareInterval } },
            '#withUnshareIntervalUnit':: d.fn(help='"The unit of time for the automatic unsharing interval. Valid values are DAYS, WEEKS, MONTHS, YEARS."', args=[d.arg(name='unshareIntervalUnit', type=d.T.string)]),
            withUnshareIntervalUnit(unshareIntervalUnit): { shareRule+: { unshareIntervalUnit: unshareIntervalUnit } },
          },
          '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
          withCopyTags(copyTags): { copyTags: copyTags },
          '#withCrossRegionCopyRule':: d.fn(help='"See the cross_region_copy_rule block. Max of 3 per schedule."', args=[d.arg(name='crossRegionCopyRule', type=d.T.array)]),
          withCrossRegionCopyRule(crossRegionCopyRule): { crossRegionCopyRule: if std.isArray(v=crossRegionCopyRule) then crossRegionCopyRule else [crossRegionCopyRule] },
          '#withCrossRegionCopyRuleMixin':: d.fn(help='"See the cross_region_copy_rule block. Max of 3 per schedule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='crossRegionCopyRule', type=d.T.array)]),
          withCrossRegionCopyRuleMixin(crossRegionCopyRule): { crossRegionCopyRule+: if std.isArray(v=crossRegionCopyRule) then crossRegionCopyRule else [crossRegionCopyRule] },
          '#withName':: d.fn(help='"A descriptive name for the action."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withTagsToAdd':: d.fn(help='"A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these."', args=[d.arg(name='tagsToAdd', type=d.T.object)]),
          withTagsToAdd(tagsToAdd): { tagsToAdd: tagsToAdd },
          '#withTagsToAddMixin':: d.fn(help='"A map of tag keys and their values. DLM lifecycle policies will already tag the snapshot with the tags on the volume. This configuration adds extra tags on top of these."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tagsToAdd', type=d.T.object)]),
          withTagsToAddMixin(tagsToAdd): { tagsToAdd+: tagsToAdd },
          '#withVariableTags':: d.fn(help='"A map of tag keys and variable values, where the values are determined when the policy is executed. Only $(instance-id) or $(timestamp) are valid values. Can only be used when resource_types is INSTANCE."', args=[d.arg(name='variableTags', type=d.T.object)]),
          withVariableTags(variableTags): { variableTags: variableTags },
          '#withVariableTagsMixin':: d.fn(help='"A map of tag keys and variable values, where the values are determined when the policy is executed. Only $(instance-id) or $(timestamp) are valid values. Can only be used when resource_types is INSTANCE."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variableTags', type=d.T.object)]),
          withVariableTagsMixin(variableTags): { variableTags+: variableTags },
        },
        '#withCopyTags':: d.fn(help='"Indicates whether the policy should copy tags from the source resource to the snapshot or AMI. Default value is false."', args=[d.arg(name='copyTags', type=d.T.boolean)]),
        withCopyTags(copyTags): { spec+: { initProvider+: { policyDetails+: { copyTags: copyTags } } } },
        '#withCreateInterval':: d.fn(help='"How often the policy should run and create snapshots or AMIs. valid values range from 1 to 7. Default value is 1."', args=[d.arg(name='createInterval', type=d.T.number)]),
        withCreateInterval(createInterval): { spec+: { initProvider+: { policyDetails+: { createInterval: createInterval } } } },
        '#withExtendDeletion':: d.fn(help='"snapshot or AMI retention behavior for the policy if the source volume or instance is deleted, or if the policy enters the error, disabled, or deleted state. Default value is false."', args=[d.arg(name='extendDeletion', type=d.T.boolean)]),
        withExtendDeletion(extendDeletion): { spec+: { initProvider+: { policyDetails+: { extendDeletion: extendDeletion } } } },
        '#withPolicyLanguage':: d.fn(help='"Type of policy to create. SIMPLIFIED To create a default policy. STANDARD To create a custom policy."', args=[d.arg(name='policyLanguage', type=d.T.string)]),
        withPolicyLanguage(policyLanguage): { spec+: { initProvider+: { policyDetails+: { policyLanguage: policyLanguage } } } },
        '#withPolicyType':: d.fn(help='"The valid target resource types and actions a policy can manage. Specify EBS_SNAPSHOT_MANAGEMENT to create a lifecycle policy that manages the lifecycle of Amazon EBS snapshots. Specify IMAGE_MANAGEMENT to create a lifecycle policy that manages the lifecycle of EBS-backed AMIs. Specify EVENT_BASED_POLICY to create an event-based policy that performs specific actions when a defined event occurs in your AWS account. Default value is EBS_SNAPSHOT_MANAGEMENT."', args=[d.arg(name='policyType', type=d.T.string)]),
        withPolicyType(policyType): { spec+: { initProvider+: { policyDetails+: { policyType: policyType } } } },
        '#withResourceLocations':: d.fn(help='"The location of the resources to backup. If the source resources are located in an AWS Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If the source resources are located in a Local Zone, specify LOCAL_ZONE. Valid values are CLOUD, LOCAL_ZONE, and OUTPOST."', args=[d.arg(name='resourceLocations', type=d.T.array)]),
        withResourceLocations(resourceLocations): { spec+: { initProvider+: { policyDetails+: { resourceLocations: if std.isArray(v=resourceLocations) then resourceLocations else [resourceLocations] } } } },
        '#withResourceLocationsMixin':: d.fn(help='"The location of the resources to backup. If the source resources are located in an AWS Region, specify CLOUD. If the source resources are located on an Outpost in your account, specify OUTPOST. If the source resources are located in a Local Zone, specify LOCAL_ZONE. Valid values are CLOUD, LOCAL_ZONE, and OUTPOST."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceLocations', type=d.T.array)]),
        withResourceLocationsMixin(resourceLocations): { spec+: { initProvider+: { policyDetails+: { resourceLocations+: if std.isArray(v=resourceLocations) then resourceLocations else [resourceLocations] } } } },
        '#withResourceType':: d.fn(help='"Type of default policy to create. Valid values are VOLUME and INSTANCE."', args=[d.arg(name='resourceType', type=d.T.string)]),
        withResourceType(resourceType): { spec+: { initProvider+: { policyDetails+: { resourceType: resourceType } } } },
        '#withResourceTypes':: d.fn(help='"A list of resource types that should be targeted by the lifecycle policy. Valid values are VOLUME and INSTANCE."', args=[d.arg(name='resourceTypes', type=d.T.array)]),
        withResourceTypes(resourceTypes): { spec+: { initProvider+: { policyDetails+: { resourceTypes: if std.isArray(v=resourceTypes) then resourceTypes else [resourceTypes] } } } },
        '#withResourceTypesMixin':: d.fn(help='"A list of resource types that should be targeted by the lifecycle policy. Valid values are VOLUME and INSTANCE."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceTypes', type=d.T.array)]),
        withResourceTypesMixin(resourceTypes): { spec+: { initProvider+: { policyDetails+: { resourceTypes+: if std.isArray(v=resourceTypes) then resourceTypes else [resourceTypes] } } } },
        '#withRetainInterval':: d.fn(help='"Specifies how long the policy should retain snapshots or AMIs before deleting them. valid values range from 2 to 14. Default value is 7."', args=[d.arg(name='retainInterval', type=d.T.number)]),
        withRetainInterval(retainInterval): { spec+: { initProvider+: { policyDetails+: { retainInterval: retainInterval } } } },
        '#withSchedule':: d.fn(help='"See the schedule configuration block."', args=[d.arg(name='schedule', type=d.T.array)]),
        withSchedule(schedule): { spec+: { initProvider+: { policyDetails+: { schedule: if std.isArray(v=schedule) then schedule else [schedule] } } } },
        '#withScheduleMixin':: d.fn(help='"See the schedule configuration block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='schedule', type=d.T.array)]),
        withScheduleMixin(schedule): { spec+: { initProvider+: { policyDetails+: { schedule+: if std.isArray(v=schedule) then schedule else [schedule] } } } },
        '#withTargetTags':: d.fn(help='"A map of tag keys and their values. Any resources that match the resource_types and are tagged with any of these tags will be targeted. Required when policy_type is EBS_SNAPSHOT_MANAGEMENT or IMAGE_MANAGEMENT. Must not be specified when policy_type is EVENT_BASED_POLICY."', args=[d.arg(name='targetTags', type=d.T.object)]),
        withTargetTags(targetTags): { spec+: { initProvider+: { policyDetails+: { targetTags: targetTags } } } },
        '#withTargetTagsMixin':: d.fn(help='"A map of tag keys and their values. Any resources that match the resource_types and are tagged with any of these tags will be targeted. Required when policy_type is EBS_SNAPSHOT_MANAGEMENT or IMAGE_MANAGEMENT. Must not be specified when policy_type is EVENT_BASED_POLICY."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='targetTags', type=d.T.object)]),
        withTargetTagsMixin(targetTags): { spec+: { initProvider+: { policyDetails+: { targetTags+: targetTags } } } },
      },
      '#withDefaultPolicy':: d.fn(help='"Specify the type of default policy to create. valid values are VOLUME or INSTANCE."', args=[d.arg(name='defaultPolicy', type=d.T.string)]),
      withDefaultPolicy(defaultPolicy): { spec+: { initProvider+: { defaultPolicy: defaultPolicy } } },
      '#withDescription':: d.fn(help='"A description for the DLM lifecycle policy."', args=[d.arg(name='description', type=d.T.string)]),
      withDescription(description): { spec+: { initProvider+: { description: description } } },
      '#withExecutionRoleArn':: d.fn(help='"The ARN of an IAM role that is able to be assumed by the DLM service."', args=[d.arg(name='executionRoleArn', type=d.T.string)]),
      withExecutionRoleArn(executionRoleArn): { spec+: { initProvider+: { executionRoleArn: executionRoleArn } } },
      '#withState':: d.fn(help='"Whether the lifecycle policy should be enabled or disabled. ENABLED or DISABLED are valid values. Defaults to ENABLED."', args=[d.arg(name='state', type=d.T.string)]),
      withState(state): { spec+: { initProvider+: { state: state } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { initProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { initProvider+: { tags+: tags } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to\\ncreate, observe, update, and delete this managed resource should be\\nconfigured."'),
    providerConfigRef: {
      '#withKind':: d.fn(help='"Kind of the referenced object."', args=[d.arg(name='kind', type=d.T.string)]),
      withKind(kind): { spec+: { providerConfigRef+: { kind: kind } } },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#withManagementPolicies':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPolicies(managementPolicies): { spec+: { managementPolicies: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#withManagementPoliciesMixin':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPoliciesMixin(managementPolicies): { spec+: { managementPolicies+: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a\\nSecret to which any connection details for this managed resource should\\nbe written. Connection details frequently include the endpoint, username,\\nand password required to connect to the managed resource."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
