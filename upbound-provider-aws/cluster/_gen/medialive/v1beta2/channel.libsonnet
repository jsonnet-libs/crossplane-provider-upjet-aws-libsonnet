{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='channel', url='', help='"Channel is the Schema for the Channels API."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Channel', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'medialive.aws.upbound.io/v1beta2',
    kind: 'Channel',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"ChannelSpec defines the desired state of Channel"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#cdiInputSpecification':: d.obj(help='"Specification of CDI inputs for this channel. See CDI Input Specification for more details."'),
      cdiInputSpecification: {
        '#withResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { forProvider+: { cdiInputSpecification+: { resolution: resolution } } } },
      },
      '#destinations':: d.obj(help='"Destinations for channel. See Destinations for more details."'),
      destinations: {
        '#mediaPackageSettings':: d.obj(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."'),
        mediaPackageSettings: {
          '#withChannelId':: d.fn(help='"ID of the channel in MediaPackage that is the destination for this output group."', args=[d.arg(name='channelId', type=d.T.string)]),
          withChannelId(channelId): { channelId: channelId },
        },
        '#multiplexSettings':: d.obj(help='"Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details."'),
        multiplexSettings: {
          '#withMultiplexId':: d.fn(help='"The ID of the Multiplex that the encoder is providing output to."', args=[d.arg(name='multiplexId', type=d.T.string)]),
          withMultiplexId(multiplexId): { multiplexSettings+: { multiplexId: multiplexId } },
          '#withProgramName':: d.fn(help='"The program name of the Multiplex program that the encoder is providing output to."', args=[d.arg(name='programName', type=d.T.string)]),
          withProgramName(programName): { multiplexSettings+: { programName: programName } },
        },
        '#settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
        settings: {
          '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
          withPasswordParam(passwordParam): { passwordParam: passwordParam },
          '#withStreamName':: d.fn(help='"Stream name RTMP destinations (URLs of type rtmp://)"', args=[d.arg(name='streamName', type=d.T.string)]),
          withStreamName(streamName): { streamName: streamName },
          '#withUrl':: d.fn(help='"A URL specifying a destination."', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
          '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { username: username },
        },
        '#withId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withMediaPackageSettings':: d.fn(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."', args=[d.arg(name='mediaPackageSettings', type=d.T.array)]),
        withMediaPackageSettings(mediaPackageSettings): { mediaPackageSettings: if std.isArray(v=mediaPackageSettings) then mediaPackageSettings else [mediaPackageSettings] },
        '#withMediaPackageSettingsMixin':: d.fn(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mediaPackageSettings', type=d.T.array)]),
        withMediaPackageSettingsMixin(mediaPackageSettings): { mediaPackageSettings+: if std.isArray(v=mediaPackageSettings) then mediaPackageSettings else [mediaPackageSettings] },
        '#withSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='settings', type=d.T.array)]),
        withSettings(settings): { settings: if std.isArray(v=settings) then settings else [settings] },
        '#withSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='settings', type=d.T.array)]),
        withSettingsMixin(settings): { settings+: if std.isArray(v=settings) then settings else [settings] },
      },
      '#encoderSettings':: d.obj(help='"Encoder settings. See Encoder Settings for more details."'),
      encoderSettings: {
        '#audioDescriptions':: d.obj(help='"Audio descriptions for the channel. See Audio Descriptions for more details."'),
        audioDescriptions: {
          '#audioNormalizationSettings':: d.obj(help='"Advanced audio normalization settings. See Audio Normalization Settings for more details."'),
          audioNormalizationSettings: {
            '#withAlgorithm':: d.fn(help='"Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification."', args=[d.arg(name='algorithm', type=d.T.string)]),
            withAlgorithm(algorithm): { audioNormalizationSettings+: { algorithm: algorithm } },
            '#withAlgorithmControl':: d.fn(help='"Algorithm control for the audio description."', args=[d.arg(name='algorithmControl', type=d.T.string)]),
            withAlgorithmControl(algorithmControl): { audioNormalizationSettings+: { algorithmControl: algorithmControl } },
            '#withTargetLkfs':: d.fn(help='"Target LKFS (loudness) to adjust volume to."', args=[d.arg(name='targetLkfs', type=d.T.number)]),
            withTargetLkfs(targetLkfs): { audioNormalizationSettings+: { targetLkfs: targetLkfs } },
          },
          '#audioWatermarkSettings':: d.obj(help='"Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details."'),
          audioWatermarkSettings: {
            '#nielsenWatermarksSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            nielsenWatermarksSettings: {
              '#nielsenCbetSettings':: d.obj(help='"Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details."'),
              nielsenCbetSettings: {
                '#withCbetCheckDigitString':: d.fn(help='', args=[d.arg(name='cbetCheckDigitString', type=d.T.string)]),
                withCbetCheckDigitString(cbetCheckDigitString): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { cbetCheckDigitString: cbetCheckDigitString } } } },
                '#withCbetStepaside':: d.fn(help='"Determines the method of CBET insertion mode when prior encoding is detected on the same layer."', args=[d.arg(name='cbetStepaside', type=d.T.string)]),
                withCbetStepaside(cbetStepaside): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { cbetStepaside: cbetStepaside } } } },
                '#withCsid':: d.fn(help='"CBET source ID to use in the watermark."', args=[d.arg(name='csid', type=d.T.string)]),
                withCsid(csid): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { csid: csid } } } },
              },
              '#nielsenNaesIiNwSettings':: d.obj(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."'),
              nielsenNaesIiNwSettings: {
                '#withCheckDigitString':: d.fn(help='', args=[d.arg(name='checkDigitString', type=d.T.string)]),
                withCheckDigitString(checkDigitString): { checkDigitString: checkDigitString },
                '#withSid':: d.fn(help='"The Nielsen Source ID to include in the watermark."', args=[d.arg(name='sid', type=d.T.number)]),
                withSid(sid): { sid: sid },
              },
              '#withNielsenDistributionType':: d.fn(help='"Distribution types to assign to the watermarks. Options are PROGRAM_CONTENT and FINAL_DISTRIBUTOR."', args=[d.arg(name='nielsenDistributionType', type=d.T.string)]),
              withNielsenDistributionType(nielsenDistributionType): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenDistributionType: nielsenDistributionType } } },
              '#withNielsenNaesIiNwSettings':: d.fn(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."', args=[d.arg(name='nielsenNaesIiNwSettings', type=d.T.array)]),
              withNielsenNaesIiNwSettings(nielsenNaesIiNwSettings): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenNaesIiNwSettings: if std.isArray(v=nielsenNaesIiNwSettings) then nielsenNaesIiNwSettings else [nielsenNaesIiNwSettings] } } },
              '#withNielsenNaesIiNwSettingsMixin':: d.fn(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nielsenNaesIiNwSettings', type=d.T.array)]),
              withNielsenNaesIiNwSettingsMixin(nielsenNaesIiNwSettings): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenNaesIiNwSettings+: if std.isArray(v=nielsenNaesIiNwSettings) then nielsenNaesIiNwSettings else [nielsenNaesIiNwSettings] } } },
            },
          },
          '#codecSettings':: d.obj(help='"Audio codec settings. See Audio Codec Settings for more details."'),
          codecSettings: {
            '#aacSettings':: d.obj(help='"Aac Settings. See AAC Settings for more details."'),
            aacSettings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { aacSettings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { aacSettings+: { codingMode: codingMode } } },
              '#withInputType':: d.fn(help='"Set to \\"broadcasterMixedAd\\" when input contains pre-mixed main audio + AD (narration) as a stereo pair."', args=[d.arg(name='inputType', type=d.T.string)]),
              withInputType(inputType): { codecSettings+: { aacSettings+: { inputType: inputType } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { aacSettings+: { profile: profile } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { aacSettings+: { rateControlMode: rateControlMode } } },
              '#withRawFormat':: d.fn(help='"Sets LATM/LOAS AAC output for raw containers."', args=[d.arg(name='rawFormat', type=d.T.string)]),
              withRawFormat(rawFormat): { codecSettings+: { aacSettings+: { rawFormat: rawFormat } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { aacSettings+: { sampleRate: sampleRate } } },
              '#withSpec':: d.fn(help='"Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers."', args=[d.arg(name='spec', type=d.T.string)]),
              withSpec(spec): { codecSettings+: { aacSettings+: { spec: spec } } },
              '#withVbrQuality':: d.fn(help='"VBR Quality Level - Only used if rateControlMode is VBR."', args=[d.arg(name='vbrQuality', type=d.T.string)]),
              withVbrQuality(vbrQuality): { codecSettings+: { aacSettings+: { vbrQuality: vbrQuality } } },
            },
            '#ac3Settings':: d.obj(help='"Ac3 Settings. See AC3 Settings for more details."'),
            ac3Settings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { ac3Settings+: { bitrate: bitrate } } },
              '#withBitstreamMode':: d.fn(help='"Specifies the bitstream mode (bsmod) for the emitted AC-3 stream."', args=[d.arg(name='bitstreamMode', type=d.T.string)]),
              withBitstreamMode(bitstreamMode): { codecSettings+: { ac3Settings+: { bitstreamMode: bitstreamMode } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { ac3Settings+: { codingMode: codingMode } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { ac3Settings+: { dialnorm: dialnorm } } },
              '#withDrcProfile':: d.fn(help='"If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification."', args=[d.arg(name='drcProfile', type=d.T.string)]),
              withDrcProfile(drcProfile): { codecSettings+: { ac3Settings+: { drcProfile: drcProfile } } },
              '#withLfeFilter':: d.fn(help='"When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding."', args=[d.arg(name='lfeFilter', type=d.T.string)]),
              withLfeFilter(lfeFilter): { codecSettings+: { ac3Settings+: { lfeFilter: lfeFilter } } },
              '#withMetadataControl':: d.fn(help='"Metadata control."', args=[d.arg(name='metadataControl', type=d.T.string)]),
              withMetadataControl(metadataControl): { codecSettings+: { ac3Settings+: { metadataControl: metadataControl } } },
            },
            '#eac3AtmosSettings':: d.obj(help='"- Eac3 Atmos Settings. See EAC3 Atmos Settings"'),
            eac3AtmosSettings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { eac3AtmosSettings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { eac3AtmosSettings+: { codingMode: codingMode } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { eac3AtmosSettings+: { dialnorm: dialnorm } } },
              '#withDrcLine':: d.fn(help='"Sets the Dolby dynamic range compression profile."', args=[d.arg(name='drcLine', type=d.T.string)]),
              withDrcLine(drcLine): { codecSettings+: { eac3AtmosSettings+: { drcLine: drcLine } } },
              '#withDrcRf':: d.fn(help='"Sets the profile for heavy Dolby dynamic range compression."', args=[d.arg(name='drcRf', type=d.T.string)]),
              withDrcRf(drcRf): { codecSettings+: { eac3AtmosSettings+: { drcRf: drcRf } } },
              '#withHeightTrim':: d.fn(help='"Height dimensional trim."', args=[d.arg(name='heightTrim', type=d.T.number)]),
              withHeightTrim(heightTrim): { codecSettings+: { eac3AtmosSettings+: { heightTrim: heightTrim } } },
              '#withSurroundTrim':: d.fn(help='"Surround dimensional trim."', args=[d.arg(name='surroundTrim', type=d.T.number)]),
              withSurroundTrim(surroundTrim): { codecSettings+: { eac3AtmosSettings+: { surroundTrim: surroundTrim } } },
            },
            '#eac3Settings':: d.obj(help='"- Eac3 Settings. See EAC3 Settings"'),
            eac3Settings: {
              '#withAttenuationControl':: d.fn(help='"Sets the attenuation control."', args=[d.arg(name='attenuationControl', type=d.T.string)]),
              withAttenuationControl(attenuationControl): { codecSettings+: { eac3Settings+: { attenuationControl: attenuationControl } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { eac3Settings+: { bitrate: bitrate } } },
              '#withBitstreamMode':: d.fn(help='"Specifies the bitstream mode (bsmod) for the emitted AC-3 stream."', args=[d.arg(name='bitstreamMode', type=d.T.string)]),
              withBitstreamMode(bitstreamMode): { codecSettings+: { eac3Settings+: { bitstreamMode: bitstreamMode } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { eac3Settings+: { codingMode: codingMode } } },
              '#withDcFilter':: d.fn(help='', args=[d.arg(name='dcFilter', type=d.T.string)]),
              withDcFilter(dcFilter): { codecSettings+: { eac3Settings+: { dcFilter: dcFilter } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { eac3Settings+: { dialnorm: dialnorm } } },
              '#withDrcLine':: d.fn(help='"Sets the Dolby dynamic range compression profile."', args=[d.arg(name='drcLine', type=d.T.string)]),
              withDrcLine(drcLine): { codecSettings+: { eac3Settings+: { drcLine: drcLine } } },
              '#withDrcRf':: d.fn(help='"Sets the profile for heavy Dolby dynamic range compression."', args=[d.arg(name='drcRf', type=d.T.string)]),
              withDrcRf(drcRf): { codecSettings+: { eac3Settings+: { drcRf: drcRf } } },
              '#withLfeControl':: d.fn(help='', args=[d.arg(name='lfeControl', type=d.T.string)]),
              withLfeControl(lfeControl): { codecSettings+: { eac3Settings+: { lfeControl: lfeControl } } },
              '#withLfeFilter':: d.fn(help='"When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding."', args=[d.arg(name='lfeFilter', type=d.T.string)]),
              withLfeFilter(lfeFilter): { codecSettings+: { eac3Settings+: { lfeFilter: lfeFilter } } },
              '#withLoRoCenterMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='loRoCenterMixLevel', type=d.T.number)]),
              withLoRoCenterMixLevel(loRoCenterMixLevel): { codecSettings+: { eac3Settings+: { loRoCenterMixLevel: loRoCenterMixLevel } } },
              '#withLoRoSurroundMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='loRoSurroundMixLevel', type=d.T.number)]),
              withLoRoSurroundMixLevel(loRoSurroundMixLevel): { codecSettings+: { eac3Settings+: { loRoSurroundMixLevel: loRoSurroundMixLevel } } },
              '#withLtRtCenterMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='ltRtCenterMixLevel', type=d.T.number)]),
              withLtRtCenterMixLevel(ltRtCenterMixLevel): { codecSettings+: { eac3Settings+: { ltRtCenterMixLevel: ltRtCenterMixLevel } } },
              '#withLtRtSurroundMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='ltRtSurroundMixLevel', type=d.T.number)]),
              withLtRtSurroundMixLevel(ltRtSurroundMixLevel): { codecSettings+: { eac3Settings+: { ltRtSurroundMixLevel: ltRtSurroundMixLevel } } },
              '#withMetadataControl':: d.fn(help='"Metadata control."', args=[d.arg(name='metadataControl', type=d.T.string)]),
              withMetadataControl(metadataControl): { codecSettings+: { eac3Settings+: { metadataControl: metadataControl } } },
              '#withPassthroughControl':: d.fn(help='', args=[d.arg(name='passthroughControl', type=d.T.string)]),
              withPassthroughControl(passthroughControl): { codecSettings+: { eac3Settings+: { passthroughControl: passthroughControl } } },
              '#withPhaseControl':: d.fn(help='', args=[d.arg(name='phaseControl', type=d.T.string)]),
              withPhaseControl(phaseControl): { codecSettings+: { eac3Settings+: { phaseControl: phaseControl } } },
              '#withStereoDownmix':: d.fn(help='', args=[d.arg(name='stereoDownmix', type=d.T.string)]),
              withStereoDownmix(stereoDownmix): { codecSettings+: { eac3Settings+: { stereoDownmix: stereoDownmix } } },
              '#withSurroundExMode':: d.fn(help='', args=[d.arg(name='surroundExMode', type=d.T.string)]),
              withSurroundExMode(surroundExMode): { codecSettings+: { eac3Settings+: { surroundExMode: surroundExMode } } },
              '#withSurroundMode':: d.fn(help='', args=[d.arg(name='surroundMode', type=d.T.string)]),
              withSurroundMode(surroundMode): { codecSettings+: { eac3Settings+: { surroundMode: surroundMode } } },
            },
            '#mp2Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            mp2Settings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { mp2Settings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { mp2Settings+: { codingMode: codingMode } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { mp2Settings+: { sampleRate: sampleRate } } },
            },
            '#wavSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            wavSettings: {
              '#withBitDepth':: d.fn(help='', args=[d.arg(name='bitDepth', type=d.T.number)]),
              withBitDepth(bitDepth): { codecSettings+: { wavSettings+: { bitDepth: bitDepth } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { wavSettings+: { codingMode: codingMode } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { wavSettings+: { sampleRate: sampleRate } } },
            },
            '#withPassThroughSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='passThroughSettings', type=d.T.object)]),
            withPassThroughSettings(passThroughSettings): { codecSettings+: { passThroughSettings: passThroughSettings } },
            '#withPassThroughSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='passThroughSettings', type=d.T.object)]),
            withPassThroughSettingsMixin(passThroughSettings): { codecSettings+: { passThroughSettings+: passThroughSettings } },
          },
          '#remixSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
          remixSettings: {
            '#channelMappings':: d.obj(help=''),
            channelMappings: {
              '#inputChannelLevels':: d.obj(help=''),
              inputChannelLevels: {
                '#withGain':: d.fn(help='', args=[d.arg(name='gain', type=d.T.number)]),
                withGain(gain): { gain: gain },
                '#withInputChannel':: d.fn(help='', args=[d.arg(name='inputChannel', type=d.T.number)]),
                withInputChannel(inputChannel): { inputChannel: inputChannel },
              },
              '#withInputChannelLevels':: d.fn(help='', args=[d.arg(name='inputChannelLevels', type=d.T.array)]),
              withInputChannelLevels(inputChannelLevels): { inputChannelLevels: if std.isArray(v=inputChannelLevels) then inputChannelLevels else [inputChannelLevels] },
              '#withInputChannelLevelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inputChannelLevels', type=d.T.array)]),
              withInputChannelLevelsMixin(inputChannelLevels): { inputChannelLevels+: if std.isArray(v=inputChannelLevels) then inputChannelLevels else [inputChannelLevels] },
              '#withOutputChannel':: d.fn(help='', args=[d.arg(name='outputChannel', type=d.T.number)]),
              withOutputChannel(outputChannel): { outputChannel: outputChannel },
            },
            '#withChannelMappings':: d.fn(help='', args=[d.arg(name='channelMappings', type=d.T.array)]),
            withChannelMappings(channelMappings): { remixSettings+: { channelMappings: if std.isArray(v=channelMappings) then channelMappings else [channelMappings] } },
            '#withChannelMappingsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='channelMappings', type=d.T.array)]),
            withChannelMappingsMixin(channelMappings): { remixSettings+: { channelMappings+: if std.isArray(v=channelMappings) then channelMappings else [channelMappings] } },
            '#withChannelsIn':: d.fn(help='', args=[d.arg(name='channelsIn', type=d.T.number)]),
            withChannelsIn(channelsIn): { remixSettings+: { channelsIn: channelsIn } },
            '#withChannelsOut':: d.fn(help='', args=[d.arg(name='channelsOut', type=d.T.number)]),
            withChannelsOut(channelsOut): { remixSettings+: { channelsOut: channelsOut } },
          },
          '#withAudioSelectorName':: d.fn(help="\"The name of the audio selector in the input that MediaLive should monitor to detect silence. Select your most important rendition. If you didn't create an audio selector in this input, leave blank.\"", args=[d.arg(name='audioSelectorName', type=d.T.string)]),
          withAudioSelectorName(audioSelectorName): { audioSelectorName: audioSelectorName },
          '#withAudioType':: d.fn(help='"Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1."', args=[d.arg(name='audioType', type=d.T.string)]),
          withAudioType(audioType): { audioType: audioType },
          '#withAudioTypeControl':: d.fn(help='"Determined how audio type is determined."', args=[d.arg(name='audioTypeControl', type=d.T.string)]),
          withAudioTypeControl(audioTypeControl): { audioTypeControl: audioTypeControl },
          '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
          withLanguageCode(languageCode): { languageCode: languageCode },
          '#withLanguageCodeControl':: d.fn(help='', args=[d.arg(name='languageCodeControl', type=d.T.string)]),
          withLanguageCodeControl(languageCodeControl): { languageCodeControl: languageCodeControl },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withStreamName':: d.fn(help='"Stream name RTMP destinations (URLs of type rtmp://)"', args=[d.arg(name='streamName', type=d.T.string)]),
          withStreamName(streamName): { streamName: streamName },
        },
        '#availBlanking':: d.obj(help='"Settings for ad avail blanking. See Avail Blanking for more details."'),
        availBlanking: {
          '#availBlankingImage':: d.obj(help='"Blanking image to be used. See Avail Blanking Image for more details."'),
          availBlankingImage: {
            '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
            withPasswordParam(passwordParam): { spec+: { forProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { passwordParam: passwordParam } } } } } },
            '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
            withUri(uri): { spec+: { forProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { uri: uri } } } } } },
            '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
            withUsername(username): { spec+: { forProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { username: username } } } } } },
          },
          '#withState':: d.fn(help='"When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added."', args=[d.arg(name='state', type=d.T.string)]),
          withState(state): { spec+: { forProvider+: { encoderSettings+: { availBlanking+: { state: state } } } } },
        },
        '#captionDescriptions':: d.obj(help='"Caption Descriptions. See Caption Descriptions for more details."'),
        captionDescriptions: {
          '#destinationSettings':: d.obj(help='"Additional settings for captions destination that depend on the destination type. See Destination Settings for more details."'),
          destinationSettings: {
            '#burnInDestinationSettings':: d.obj(help='"Burn In Destination Settings. See Burn In Destination Settings for more details."'),
            burnInDestinationSettings: {
              '#font':: d.obj(help='"External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details."'),
              font: {
                '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                withPasswordParam(passwordParam): { destinationSettings+: { burnInDestinationSettings+: { font+: { passwordParam: passwordParam } } } },
                '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                withUri(uri): { destinationSettings+: { burnInDestinationSettings+: { font+: { uri: uri } } } },
                '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                withUsername(username): { destinationSettings+: { burnInDestinationSettings+: { font+: { username: username } } } },
              },
              '#withAlignment':: d.fn(help='"If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='alignment', type=d.T.string)]),
              withAlignment(alignment): { destinationSettings+: { burnInDestinationSettings+: { alignment: alignment } } },
              '#withBackgroundColor':: d.fn(help='"Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundColor', type=d.T.string)]),
              withBackgroundColor(backgroundColor): { destinationSettings+: { burnInDestinationSettings+: { backgroundColor: backgroundColor } } },
              '#withBackgroundOpacity':: d.fn(help='"Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundOpacity', type=d.T.number)]),
              withBackgroundOpacity(backgroundOpacity): { destinationSettings+: { burnInDestinationSettings+: { backgroundOpacity: backgroundOpacity } } },
              '#withFontColor':: d.fn(help='"Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontColor', type=d.T.string)]),
              withFontColor(fontColor): { destinationSettings+: { burnInDestinationSettings+: { fontColor: fontColor } } },
              '#withFontOpacity':: d.fn(help='"Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontOpacity', type=d.T.number)]),
              withFontOpacity(fontOpacity): { destinationSettings+: { burnInDestinationSettings+: { fontOpacity: fontOpacity } } },
              '#withFontResolution':: d.fn(help='"Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontResolution', type=d.T.number)]),
              withFontResolution(fontResolution): { destinationSettings+: { burnInDestinationSettings+: { fontResolution: fontResolution } } },
              '#withFontSize':: d.fn(help='"When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontSize', type=d.T.string)]),
              withFontSize(fontSize): { destinationSettings+: { burnInDestinationSettings+: { fontSize: fontSize } } },
              '#withOutlineColor':: d.fn(help='"Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineColor', type=d.T.string)]),
              withOutlineColor(outlineColor): { destinationSettings+: { burnInDestinationSettings+: { outlineColor: outlineColor } } },
              '#withOutlineSize':: d.fn(help='"Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineSize', type=d.T.number)]),
              withOutlineSize(outlineSize): { destinationSettings+: { burnInDestinationSettings+: { outlineSize: outlineSize } } },
              '#withShadowColor':: d.fn(help='"Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowColor', type=d.T.string)]),
              withShadowColor(shadowColor): { destinationSettings+: { burnInDestinationSettings+: { shadowColor: shadowColor } } },
              '#withShadowOpacity':: d.fn(help='"Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowOpacity', type=d.T.number)]),
              withShadowOpacity(shadowOpacity): { destinationSettings+: { burnInDestinationSettings+: { shadowOpacity: shadowOpacity } } },
              '#withShadowXOffset':: d.fn(help='"Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowXOffset', type=d.T.number)]),
              withShadowXOffset(shadowXOffset): { destinationSettings+: { burnInDestinationSettings+: { shadowXOffset: shadowXOffset } } },
              '#withShadowYOffset':: d.fn(help='"Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowYOffset', type=d.T.number)]),
              withShadowYOffset(shadowYOffset): { destinationSettings+: { burnInDestinationSettings+: { shadowYOffset: shadowYOffset } } },
              '#withTeletextGridControl':: d.fn(help='"Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs."', args=[d.arg(name='teletextGridControl', type=d.T.string)]),
              withTeletextGridControl(teletextGridControl): { destinationSettings+: { burnInDestinationSettings+: { teletextGridControl: teletextGridControl } } },
              '#withXPosition':: d.fn(help='"Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='xPosition', type=d.T.number)]),
              withXPosition(xPosition): { destinationSettings+: { burnInDestinationSettings+: { xPosition: xPosition } } },
              '#withYPosition':: d.fn(help='"Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='yPosition', type=d.T.number)]),
              withYPosition(yPosition): { destinationSettings+: { burnInDestinationSettings+: { yPosition: yPosition } } },
            },
            '#dvbSubDestinationSettings':: d.obj(help='"DVB Sub Destination Settings. See DVB Sub Destination Settings for more details."'),
            dvbSubDestinationSettings: {
              '#font':: d.obj(help='"External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details."'),
              font: {
                '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                withPasswordParam(passwordParam): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { passwordParam: passwordParam } } } },
                '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                withUri(uri): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { uri: uri } } } },
                '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                withUsername(username): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { username: username } } } },
              },
              '#withAlignment':: d.fn(help='"If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='alignment', type=d.T.string)]),
              withAlignment(alignment): { destinationSettings+: { dvbSubDestinationSettings+: { alignment: alignment } } },
              '#withBackgroundColor':: d.fn(help='"Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundColor', type=d.T.string)]),
              withBackgroundColor(backgroundColor): { destinationSettings+: { dvbSubDestinationSettings+: { backgroundColor: backgroundColor } } },
              '#withBackgroundOpacity':: d.fn(help='"Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundOpacity', type=d.T.number)]),
              withBackgroundOpacity(backgroundOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { backgroundOpacity: backgroundOpacity } } },
              '#withFontColor':: d.fn(help='"Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontColor', type=d.T.string)]),
              withFontColor(fontColor): { destinationSettings+: { dvbSubDestinationSettings+: { fontColor: fontColor } } },
              '#withFontOpacity':: d.fn(help='"Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontOpacity', type=d.T.number)]),
              withFontOpacity(fontOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { fontOpacity: fontOpacity } } },
              '#withFontResolution':: d.fn(help='"Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontResolution', type=d.T.number)]),
              withFontResolution(fontResolution): { destinationSettings+: { dvbSubDestinationSettings+: { fontResolution: fontResolution } } },
              '#withFontSize':: d.fn(help='"When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontSize', type=d.T.string)]),
              withFontSize(fontSize): { destinationSettings+: { dvbSubDestinationSettings+: { fontSize: fontSize } } },
              '#withOutlineColor':: d.fn(help='"Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineColor', type=d.T.string)]),
              withOutlineColor(outlineColor): { destinationSettings+: { dvbSubDestinationSettings+: { outlineColor: outlineColor } } },
              '#withOutlineSize':: d.fn(help='"Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineSize', type=d.T.number)]),
              withOutlineSize(outlineSize): { destinationSettings+: { dvbSubDestinationSettings+: { outlineSize: outlineSize } } },
              '#withShadowColor':: d.fn(help='"Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowColor', type=d.T.string)]),
              withShadowColor(shadowColor): { destinationSettings+: { dvbSubDestinationSettings+: { shadowColor: shadowColor } } },
              '#withShadowOpacity':: d.fn(help='"Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowOpacity', type=d.T.number)]),
              withShadowOpacity(shadowOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { shadowOpacity: shadowOpacity } } },
              '#withShadowXOffset':: d.fn(help='"Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowXOffset', type=d.T.number)]),
              withShadowXOffset(shadowXOffset): { destinationSettings+: { dvbSubDestinationSettings+: { shadowXOffset: shadowXOffset } } },
              '#withShadowYOffset':: d.fn(help='"Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowYOffset', type=d.T.number)]),
              withShadowYOffset(shadowYOffset): { destinationSettings+: { dvbSubDestinationSettings+: { shadowYOffset: shadowYOffset } } },
              '#withTeletextGridControl':: d.fn(help='"Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs."', args=[d.arg(name='teletextGridControl', type=d.T.string)]),
              withTeletextGridControl(teletextGridControl): { destinationSettings+: { dvbSubDestinationSettings+: { teletextGridControl: teletextGridControl } } },
              '#withXPosition':: d.fn(help='"Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='xPosition', type=d.T.number)]),
              withXPosition(xPosition): { destinationSettings+: { dvbSubDestinationSettings+: { xPosition: xPosition } } },
              '#withYPosition':: d.fn(help='"Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='yPosition', type=d.T.number)]),
              withYPosition(yPosition): { destinationSettings+: { dvbSubDestinationSettings+: { yPosition: yPosition } } },
            },
            '#ebuTtDDestinationSettings':: d.obj(help='"EBU TT D Destination Settings. See EBU TT D Destination Settings for more details."'),
            ebuTtDDestinationSettings: {
              '#withCopyrightHolder':: d.fn(help='"Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata."', args=[d.arg(name='copyrightHolder', type=d.T.string)]),
              withCopyrightHolder(copyrightHolder): { destinationSettings+: { ebuTtDDestinationSettings+: { copyrightHolder: copyrightHolder } } },
              '#withFillLineGap':: d.fn(help='"Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled."', args=[d.arg(name='fillLineGap', type=d.T.string)]),
              withFillLineGap(fillLineGap): { destinationSettings+: { ebuTtDDestinationSettings+: { fillLineGap: fillLineGap } } },
              '#withFontFamily':: d.fn(help='"Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”."', args=[d.arg(name='fontFamily', type=d.T.string)]),
              withFontFamily(fontFamily): { destinationSettings+: { ebuTtDDestinationSettings+: { fontFamily: fontFamily } } },
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { ebuTtDDestinationSettings+: { styleControl: styleControl } } },
            },
            '#ttmlDestinationSettings':: d.obj(help='"TTML Destination Settings. See TTML Destination Settings for more details."'),
            ttmlDestinationSettings: {
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { ttmlDestinationSettings+: { styleControl: styleControl } } },
            },
            '#webvttDestinationSettings':: d.obj(help='"WebVTT Destination Settings. See WebVTT Destination Settings for more details."'),
            webvttDestinationSettings: {
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { webvttDestinationSettings+: { styleControl: styleControl } } },
            },
            '#withAribDestinationSettings':: d.fn(help='"ARIB Destination Settings."', args=[d.arg(name='aribDestinationSettings', type=d.T.object)]),
            withAribDestinationSettings(aribDestinationSettings): { destinationSettings+: { aribDestinationSettings: aribDestinationSettings } },
            '#withAribDestinationSettingsMixin':: d.fn(help='"ARIB Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aribDestinationSettings', type=d.T.object)]),
            withAribDestinationSettingsMixin(aribDestinationSettings): { destinationSettings+: { aribDestinationSettings+: aribDestinationSettings } },
            '#withEmbeddedDestinationSettings':: d.fn(help='"Embedded Destination Settings."', args=[d.arg(name='embeddedDestinationSettings', type=d.T.object)]),
            withEmbeddedDestinationSettings(embeddedDestinationSettings): { destinationSettings+: { embeddedDestinationSettings: embeddedDestinationSettings } },
            '#withEmbeddedDestinationSettingsMixin':: d.fn(help='"Embedded Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='embeddedDestinationSettings', type=d.T.object)]),
            withEmbeddedDestinationSettingsMixin(embeddedDestinationSettings): { destinationSettings+: { embeddedDestinationSettings+: embeddedDestinationSettings } },
            '#withEmbeddedPlusScte20DestinationSettings':: d.fn(help='"Embedded Plus SCTE20 Destination Settings."', args=[d.arg(name='embeddedPlusScte20DestinationSettings', type=d.T.object)]),
            withEmbeddedPlusScte20DestinationSettings(embeddedPlusScte20DestinationSettings): { destinationSettings+: { embeddedPlusScte20DestinationSettings: embeddedPlusScte20DestinationSettings } },
            '#withEmbeddedPlusScte20DestinationSettingsMixin':: d.fn(help='"Embedded Plus SCTE20 Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='embeddedPlusScte20DestinationSettings', type=d.T.object)]),
            withEmbeddedPlusScte20DestinationSettingsMixin(embeddedPlusScte20DestinationSettings): { destinationSettings+: { embeddedPlusScte20DestinationSettings+: embeddedPlusScte20DestinationSettings } },
            '#withRtmpCaptionInfoDestinationSettings':: d.fn(help='"RTMP Caption Info Destination Settings."', args=[d.arg(name='rtmpCaptionInfoDestinationSettings', type=d.T.object)]),
            withRtmpCaptionInfoDestinationSettings(rtmpCaptionInfoDestinationSettings): { destinationSettings+: { rtmpCaptionInfoDestinationSettings: rtmpCaptionInfoDestinationSettings } },
            '#withRtmpCaptionInfoDestinationSettingsMixin':: d.fn(help='"RTMP Caption Info Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rtmpCaptionInfoDestinationSettings', type=d.T.object)]),
            withRtmpCaptionInfoDestinationSettingsMixin(rtmpCaptionInfoDestinationSettings): { destinationSettings+: { rtmpCaptionInfoDestinationSettings+: rtmpCaptionInfoDestinationSettings } },
            '#withScte20PlusEmbeddedDestinationSettings':: d.fn(help='"SCTE20 Plus Embedded Destination Settings."', args=[d.arg(name='scte20PlusEmbeddedDestinationSettings', type=d.T.object)]),
            withScte20PlusEmbeddedDestinationSettings(scte20PlusEmbeddedDestinationSettings): { destinationSettings+: { scte20PlusEmbeddedDestinationSettings: scte20PlusEmbeddedDestinationSettings } },
            '#withScte20PlusEmbeddedDestinationSettingsMixin':: d.fn(help='"SCTE20 Plus Embedded Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scte20PlusEmbeddedDestinationSettings', type=d.T.object)]),
            withScte20PlusEmbeddedDestinationSettingsMixin(scte20PlusEmbeddedDestinationSettings): { destinationSettings+: { scte20PlusEmbeddedDestinationSettings+: scte20PlusEmbeddedDestinationSettings } },
            '#withScte27DestinationSettings':: d.fn(help='"SCTE27 Destination Settings."', args=[d.arg(name='scte27DestinationSettings', type=d.T.object)]),
            withScte27DestinationSettings(scte27DestinationSettings): { destinationSettings+: { scte27DestinationSettings: scte27DestinationSettings } },
            '#withScte27DestinationSettingsMixin':: d.fn(help='"SCTE27 Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scte27DestinationSettings', type=d.T.object)]),
            withScte27DestinationSettingsMixin(scte27DestinationSettings): { destinationSettings+: { scte27DestinationSettings+: scte27DestinationSettings } },
            '#withSmpteTtDestinationSettings':: d.fn(help='"SMPTE TT Destination Settings."', args=[d.arg(name='smpteTtDestinationSettings', type=d.T.object)]),
            withSmpteTtDestinationSettings(smpteTtDestinationSettings): { destinationSettings+: { smpteTtDestinationSettings: smpteTtDestinationSettings } },
            '#withSmpteTtDestinationSettingsMixin':: d.fn(help='"SMPTE TT Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='smpteTtDestinationSettings', type=d.T.object)]),
            withSmpteTtDestinationSettingsMixin(smpteTtDestinationSettings): { destinationSettings+: { smpteTtDestinationSettings+: smpteTtDestinationSettings } },
            '#withTeletextDestinationSettings':: d.fn(help='"Teletext Destination Settings."', args=[d.arg(name='teletextDestinationSettings', type=d.T.object)]),
            withTeletextDestinationSettings(teletextDestinationSettings): { destinationSettings+: { teletextDestinationSettings: teletextDestinationSettings } },
            '#withTeletextDestinationSettingsMixin':: d.fn(help='"Teletext Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='teletextDestinationSettings', type=d.T.object)]),
            withTeletextDestinationSettingsMixin(teletextDestinationSettings): { destinationSettings+: { teletextDestinationSettings+: teletextDestinationSettings } },
          },
          '#withAccessibility':: d.fn(help='"Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds."', args=[d.arg(name='accessibility', type=d.T.string)]),
          withAccessibility(accessibility): { accessibility: accessibility },
          '#withCaptionSelectorName':: d.fn(help='"Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name."', args=[d.arg(name='captionSelectorName', type=d.T.string)]),
          withCaptionSelectorName(captionSelectorName): { captionSelectorName: captionSelectorName },
          '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
          withLanguageCode(languageCode): { languageCode: languageCode },
          '#withLanguageDescription':: d.fn(help='"Human readable information to indicate captions available for players (eg. English, or Spanish)."', args=[d.arg(name='languageDescription', type=d.T.string)]),
          withLanguageDescription(languageDescription): { languageDescription: languageDescription },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#globalConfiguration':: d.obj(help='"Configuration settings that apply to the event as a whole. See Global Configuration for more details."'),
        globalConfiguration: {
          '#inputLossBehavior':: d.obj(help='"Settings for system actions when input is lost. See Input Loss Behavior for more details."'),
          inputLossBehavior: {
            '#inputLossImageSlate':: d.obj(help=''),
            inputLossImageSlate: {
              '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
              withPasswordParam(passwordParam): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { passwordParam: passwordParam } } } } } } },
              '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
              withUri(uri): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { uri: uri } } } } } } },
              '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
              withUsername(username): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { username: username } } } } } } },
            },
            '#withBlackFrameMsec':: d.fn(help='', args=[d.arg(name='blackFrameMsec', type=d.T.number)]),
            withBlackFrameMsec(blackFrameMsec): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { blackFrameMsec: blackFrameMsec } } } } } },
            '#withInputLossImageColor':: d.fn(help='', args=[d.arg(name='inputLossImageColor', type=d.T.string)]),
            withInputLossImageColor(inputLossImageColor): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageColor: inputLossImageColor } } } } } },
            '#withInputLossImageType':: d.fn(help='', args=[d.arg(name='inputLossImageType', type=d.T.string)]),
            withInputLossImageType(inputLossImageType): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageType: inputLossImageType } } } } } },
            '#withRepeatFrameMsec':: d.fn(help='', args=[d.arg(name='repeatFrameMsec', type=d.T.number)]),
            withRepeatFrameMsec(repeatFrameMsec): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { repeatFrameMsec: repeatFrameMsec } } } } } },
          },
          '#withInitialAudioGain':: d.fn(help='"Value to set the initial audio gain for the Live Event."', args=[d.arg(name='initialAudioGain', type=d.T.number)]),
          withInitialAudioGain(initialAudioGain): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { initialAudioGain: initialAudioGain } } } } },
          '#withInputEndAction':: d.fn(help='"Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API)."', args=[d.arg(name='inputEndAction', type=d.T.string)]),
          withInputEndAction(inputEndAction): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { inputEndAction: inputEndAction } } } } },
          '#withOutputLockingMode':: d.fn(help='"Indicates how MediaLive pipelines are synchronized. PIPELINE_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch."', args=[d.arg(name='outputLockingMode', type=d.T.string)]),
          withOutputLockingMode(outputLockingMode): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { outputLockingMode: outputLockingMode } } } } },
          '#withOutputTimingSource':: d.fn(help='"Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream."', args=[d.arg(name='outputTimingSource', type=d.T.string)]),
          withOutputTimingSource(outputTimingSource): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { outputTimingSource: outputTimingSource } } } } },
          '#withSupportLowFramerateInputs':: d.fn(help='"Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second."', args=[d.arg(name='supportLowFramerateInputs', type=d.T.string)]),
          withSupportLowFramerateInputs(supportLowFramerateInputs): { spec+: { forProvider+: { encoderSettings+: { globalConfiguration+: { supportLowFramerateInputs: supportLowFramerateInputs } } } } },
        },
        '#motionGraphicsConfiguration':: d.obj(help='"Settings for motion graphics. See Motion Graphics Configuration for more details."'),
        motionGraphicsConfiguration: {
          '#motionGraphicsSettings':: d.obj(help='"–  Motion Graphics Settings. See Motion Graphics Settings for more details."'),
          motionGraphicsSettings: {
            '#withHtmlMotionGraphicsSettings':: d.fn(help='"Html Motion Graphics Settings."', args=[d.arg(name='htmlMotionGraphicsSettings', type=d.T.object)]),
            withHtmlMotionGraphicsSettings(htmlMotionGraphicsSettings): { spec+: { forProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsSettings+: { htmlMotionGraphicsSettings: htmlMotionGraphicsSettings } } } } } },
            '#withHtmlMotionGraphicsSettingsMixin':: d.fn(help='"Html Motion Graphics Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='htmlMotionGraphicsSettings', type=d.T.object)]),
            withHtmlMotionGraphicsSettingsMixin(htmlMotionGraphicsSettings): { spec+: { forProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsSettings+: { htmlMotionGraphicsSettings+: htmlMotionGraphicsSettings } } } } } },
          },
          '#withMotionGraphicsInsertion':: d.fn(help='"Motion Graphics Insertion."', args=[d.arg(name='motionGraphicsInsertion', type=d.T.string)]),
          withMotionGraphicsInsertion(motionGraphicsInsertion): { spec+: { forProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsInsertion: motionGraphicsInsertion } } } } },
        },
        '#nielsenConfiguration':: d.obj(help='"Nielsen configuration settings. See Nielsen Configuration for more details."'),
        nielsenConfiguration: {
          '#withDistributorId':: d.fn(help='"Enter the Distributor ID assigned to your organization by Nielsen."', args=[d.arg(name='distributorId', type=d.T.string)]),
          withDistributorId(distributorId): { spec+: { forProvider+: { encoderSettings+: { nielsenConfiguration+: { distributorId: distributorId } } } } },
          '#withNielsenPcmToId3Tagging':: d.fn(help='"Enables Nielsen PCM to ID3 tagging."', args=[d.arg(name='nielsenPcmToId3Tagging', type=d.T.string)]),
          withNielsenPcmToId3Tagging(nielsenPcmToId3Tagging): { spec+: { forProvider+: { encoderSettings+: { nielsenConfiguration+: { nielsenPcmToId3Tagging: nielsenPcmToId3Tagging } } } } },
        },
        '#outputGroups':: d.obj(help='"Output groups for the channel. See Output Groups for more details."'),
        outputGroups: {
          '#outputGroupSettings':: d.obj(help='"Settings associated with the output group. See Output Group Settings for more details."'),
          outputGroupSettings: {
            '#archiveGroupSettings':: d.obj(help='"Archive group settings. See Archive Group Settings for more details."'),
            archiveGroupSettings: {
              '#archiveCdnSettings':: d.obj(help='"Parameters that control the interactions with the CDN. See Archive CDN Settings for more details."'),
              archiveCdnSettings: {
                '#archiveS3Settings':: d.obj(help='"Archive S3 Settings. See Archive S3 Settings for more details."'),
                archiveS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { archiveCdnSettings+: { archiveS3Settings+: { cannedAcl: cannedAcl } } },
                },
              },
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { destination+: { destinationRefId: destinationRefId } },
              },
              '#withRolloverInterval':: d.fn(help='"Number of seconds to write to archive file before closing and starting a new one."', args=[d.arg(name='rolloverInterval', type=d.T.number)]),
              withRolloverInterval(rolloverInterval): { rolloverInterval: rolloverInterval },
            },
            '#frameCaptureGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            frameCaptureGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { frameCaptureGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#frameCaptureCdnSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              frameCaptureCdnSettings: {
                '#frameCaptureS3Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                frameCaptureS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { outputGroupSettings+: { frameCaptureGroupSettings+: { frameCaptureCdnSettings+: { frameCaptureS3Settings+: { cannedAcl: cannedAcl } } } } },
                },
              },
            },
            '#hlsGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            hlsGroupSettings: {
              '#captionLanguageMappings':: d.obj(help=''),
              captionLanguageMappings: {
                '#withCaptionChannel':: d.fn(help='', args=[d.arg(name='captionChannel', type=d.T.number)]),
                withCaptionChannel(captionChannel): { captionChannel: captionChannel },
                '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
                withLanguageCode(languageCode): { languageCode: languageCode },
                '#withLanguageDescription':: d.fn(help='"Human readable information to indicate captions available for players (eg. English, or Spanish)."', args=[d.arg(name='languageDescription', type=d.T.string)]),
                withLanguageDescription(languageDescription): { languageDescription: languageDescription },
              },
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { hlsGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#hlsCdnSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              hlsCdnSettings: {
                '#hlsAkamaiSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsAkamaiSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsAkamaiSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsAkamaiSettings+: { filecacheDuration: filecacheDuration } },
                  '#withHttpTransferMode':: d.fn(help='', args=[d.arg(name='httpTransferMode', type=d.T.string)]),
                  withHttpTransferMode(httpTransferMode): { hlsAkamaiSettings+: { httpTransferMode: httpTransferMode } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsAkamaiSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsAkamaiSettings+: { restartDelay: restartDelay } },
                  '#withSalt':: d.fn(help='', args=[d.arg(name='salt', type=d.T.string)]),
                  withSalt(salt): { hlsAkamaiSettings+: { salt: salt } },
                  '#withToken':: d.fn(help='', args=[d.arg(name='token', type=d.T.string)]),
                  withToken(token): { hlsAkamaiSettings+: { token: token } },
                },
                '#hlsBasicPutSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsBasicPutSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsBasicPutSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsBasicPutSettings+: { filecacheDuration: filecacheDuration } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsBasicPutSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsBasicPutSettings+: { restartDelay: restartDelay } },
                },
                '#hlsMediaStoreSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsMediaStoreSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsMediaStoreSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsMediaStoreSettings+: { filecacheDuration: filecacheDuration } },
                  '#withMediaStoreStorageClass':: d.fn(help='', args=[d.arg(name='mediaStoreStorageClass', type=d.T.string)]),
                  withMediaStoreStorageClass(mediaStoreStorageClass): { hlsMediaStoreSettings+: { mediaStoreStorageClass: mediaStoreStorageClass } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsMediaStoreSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsMediaStoreSettings+: { restartDelay: restartDelay } },
                },
                '#hlsS3Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { hlsS3Settings+: { cannedAcl: cannedAcl } },
                },
                '#hlsWebdavSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsWebdavSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsWebdavSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsWebdavSettings+: { filecacheDuration: filecacheDuration } },
                  '#withHttpTransferMode':: d.fn(help='', args=[d.arg(name='httpTransferMode', type=d.T.string)]),
                  withHttpTransferMode(httpTransferMode): { hlsWebdavSettings+: { httpTransferMode: httpTransferMode } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsWebdavSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsWebdavSettings+: { restartDelay: restartDelay } },
                },
              },
              '#keyProviderSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              keyProviderSettings: {
                '#staticKeySettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                staticKeySettings: {
                  '#keyProviderServer':: d.obj(help=''),
                  keyProviderServer: {
                    '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                    withPasswordParam(passwordParam): { keyProviderServer+: { passwordParam: passwordParam } },
                    '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                    withUri(uri): { keyProviderServer+: { uri: uri } },
                    '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                    withUsername(username): { keyProviderServer+: { username: username } },
                  },
                  '#withStaticKeyValue':: d.fn(help='', args=[d.arg(name='staticKeyValue', type=d.T.string)]),
                  withStaticKeyValue(staticKeyValue): { staticKeyValue: staticKeyValue },
                },
                '#withStaticKeySettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='staticKeySettings', type=d.T.array)]),
                withStaticKeySettings(staticKeySettings): { outputGroupSettings+: { hlsGroupSettings+: { keyProviderSettings+: { staticKeySettings: if std.isArray(v=staticKeySettings) then staticKeySettings else [staticKeySettings] } } } },
                '#withStaticKeySettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='staticKeySettings', type=d.T.array)]),
                withStaticKeySettingsMixin(staticKeySettings): { outputGroupSettings+: { hlsGroupSettings+: { keyProviderSettings+: { staticKeySettings+: if std.isArray(v=staticKeySettings) then staticKeySettings else [staticKeySettings] } } } },
              },
              '#withAdMarkers':: d.fn(help='"The ad marker type for this output group."', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkers(adMarkers): { outputGroupSettings+: { hlsGroupSettings+: { adMarkers: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAdMarkersMixin':: d.fn(help='"The ad marker type for this output group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkersMixin(adMarkers): { outputGroupSettings+: { hlsGroupSettings+: { adMarkers+: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withBaseUrlContent':: d.fn(help='', args=[d.arg(name='baseUrlContent', type=d.T.string)]),
              withBaseUrlContent(baseUrlContent): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlContent: baseUrlContent } } },
              '#withBaseUrlContent1':: d.fn(help='', args=[d.arg(name='baseUrlContent1', type=d.T.string)]),
              withBaseUrlContent1(baseUrlContent1): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlContent1: baseUrlContent1 } } },
              '#withBaseUrlManifest':: d.fn(help='', args=[d.arg(name='baseUrlManifest', type=d.T.string)]),
              withBaseUrlManifest(baseUrlManifest): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlManifest: baseUrlManifest } } },
              '#withBaseUrlManifest1':: d.fn(help='', args=[d.arg(name='baseUrlManifest1', type=d.T.string)]),
              withBaseUrlManifest1(baseUrlManifest1): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlManifest1: baseUrlManifest1 } } },
              '#withCaptionLanguageMappings':: d.fn(help='', args=[d.arg(name='captionLanguageMappings', type=d.T.array)]),
              withCaptionLanguageMappings(captionLanguageMappings): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageMappings: if std.isArray(v=captionLanguageMappings) then captionLanguageMappings else [captionLanguageMappings] } } },
              '#withCaptionLanguageMappingsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionLanguageMappings', type=d.T.array)]),
              withCaptionLanguageMappingsMixin(captionLanguageMappings): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageMappings+: if std.isArray(v=captionLanguageMappings) then captionLanguageMappings else [captionLanguageMappings] } } },
              '#withCaptionLanguageSetting':: d.fn(help='', args=[d.arg(name='captionLanguageSetting', type=d.T.string)]),
              withCaptionLanguageSetting(captionLanguageSetting): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageSetting: captionLanguageSetting } } },
              '#withClientCache':: d.fn(help='', args=[d.arg(name='clientCache', type=d.T.string)]),
              withClientCache(clientCache): { outputGroupSettings+: { hlsGroupSettings+: { clientCache: clientCache } } },
              '#withCodecSpecification':: d.fn(help='', args=[d.arg(name='codecSpecification', type=d.T.string)]),
              withCodecSpecification(codecSpecification): { outputGroupSettings+: { hlsGroupSettings+: { codecSpecification: codecSpecification } } },
              '#withConstantIv':: d.fn(help='', args=[d.arg(name='constantIv', type=d.T.string)]),
              withConstantIv(constantIv): { outputGroupSettings+: { hlsGroupSettings+: { constantIv: constantIv } } },
              '#withDirectoryStructure':: d.fn(help='', args=[d.arg(name='directoryStructure', type=d.T.string)]),
              withDirectoryStructure(directoryStructure): { outputGroupSettings+: { hlsGroupSettings+: { directoryStructure: directoryStructure } } },
              '#withDiscontinuityTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='discontinuityTags', type=d.T.string)]),
              withDiscontinuityTags(discontinuityTags): { outputGroupSettings+: { hlsGroupSettings+: { discontinuityTags: discontinuityTags } } },
              '#withEncryptionType':: d.fn(help='', args=[d.arg(name='encryptionType', type=d.T.string)]),
              withEncryptionType(encryptionType): { outputGroupSettings+: { hlsGroupSettings+: { encryptionType: encryptionType } } },
              '#withHlsCdnSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='hlsCdnSettings', type=d.T.array)]),
              withHlsCdnSettings(hlsCdnSettings): { outputGroupSettings+: { hlsGroupSettings+: { hlsCdnSettings: if std.isArray(v=hlsCdnSettings) then hlsCdnSettings else [hlsCdnSettings] } } },
              '#withHlsCdnSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hlsCdnSettings', type=d.T.array)]),
              withHlsCdnSettingsMixin(hlsCdnSettings): { outputGroupSettings+: { hlsGroupSettings+: { hlsCdnSettings+: if std.isArray(v=hlsCdnSettings) then hlsCdnSettings else [hlsCdnSettings] } } },
              '#withHlsId3SegmentTagging':: d.fn(help='', args=[d.arg(name='hlsId3SegmentTagging', type=d.T.string)]),
              withHlsId3SegmentTagging(hlsId3SegmentTagging): { outputGroupSettings+: { hlsGroupSettings+: { hlsId3SegmentTagging: hlsId3SegmentTagging } } },
              '#withIframeOnlyPlaylists':: d.fn(help='', args=[d.arg(name='iframeOnlyPlaylists', type=d.T.string)]),
              withIframeOnlyPlaylists(iframeOnlyPlaylists): { outputGroupSettings+: { hlsGroupSettings+: { iframeOnlyPlaylists: iframeOnlyPlaylists } } },
              '#withIncompleteSegmentBehavior':: d.fn(help='', args=[d.arg(name='incompleteSegmentBehavior', type=d.T.string)]),
              withIncompleteSegmentBehavior(incompleteSegmentBehavior): { outputGroupSettings+: { hlsGroupSettings+: { incompleteSegmentBehavior: incompleteSegmentBehavior } } },
              '#withIndexNSegments':: d.fn(help='', args=[d.arg(name='indexNSegments', type=d.T.number)]),
              withIndexNSegments(indexNSegments): { outputGroupSettings+: { hlsGroupSettings+: { indexNSegments: indexNSegments } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { hlsGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withIvInManifest':: d.fn(help='', args=[d.arg(name='ivInManifest', type=d.T.string)]),
              withIvInManifest(ivInManifest): { outputGroupSettings+: { hlsGroupSettings+: { ivInManifest: ivInManifest } } },
              '#withIvSource':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='ivSource', type=d.T.string)]),
              withIvSource(ivSource): { outputGroupSettings+: { hlsGroupSettings+: { ivSource: ivSource } } },
              '#withKeepSegments':: d.fn(help='', args=[d.arg(name='keepSegments', type=d.T.number)]),
              withKeepSegments(keepSegments): { outputGroupSettings+: { hlsGroupSettings+: { keepSegments: keepSegments } } },
              '#withKeyFormat':: d.fn(help='', args=[d.arg(name='keyFormat', type=d.T.string)]),
              withKeyFormat(keyFormat): { outputGroupSettings+: { hlsGroupSettings+: { keyFormat: keyFormat } } },
              '#withKeyFormatVersions':: d.fn(help='', args=[d.arg(name='keyFormatVersions', type=d.T.string)]),
              withKeyFormatVersions(keyFormatVersions): { outputGroupSettings+: { hlsGroupSettings+: { keyFormatVersions: keyFormatVersions } } },
              '#withManifestCompression':: d.fn(help='', args=[d.arg(name='manifestCompression', type=d.T.string)]),
              withManifestCompression(manifestCompression): { outputGroupSettings+: { hlsGroupSettings+: { manifestCompression: manifestCompression } } },
              '#withManifestDurationFormat':: d.fn(help='', args=[d.arg(name='manifestDurationFormat', type=d.T.string)]),
              withManifestDurationFormat(manifestDurationFormat): { outputGroupSettings+: { hlsGroupSettings+: { manifestDurationFormat: manifestDurationFormat } } },
              '#withMinSegmentLength':: d.fn(help='', args=[d.arg(name='minSegmentLength', type=d.T.number)]),
              withMinSegmentLength(minSegmentLength): { outputGroupSettings+: { hlsGroupSettings+: { minSegmentLength: minSegmentLength } } },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.string)]),
              withMode(mode): { outputGroupSettings+: { hlsGroupSettings+: { mode: mode } } },
              '#withOutputSelection':: d.fn(help='', args=[d.arg(name='outputSelection', type=d.T.string)]),
              withOutputSelection(outputSelection): { outputGroupSettings+: { hlsGroupSettings+: { outputSelection: outputSelection } } },
              '#withProgramDateTime':: d.fn(help='', args=[d.arg(name='programDateTime', type=d.T.string)]),
              withProgramDateTime(programDateTime): { outputGroupSettings+: { hlsGroupSettings+: { programDateTime: programDateTime } } },
              '#withProgramDateTimeClock':: d.fn(help='', args=[d.arg(name='programDateTimeClock', type=d.T.string)]),
              withProgramDateTimeClock(programDateTimeClock): { outputGroupSettings+: { hlsGroupSettings+: { programDateTimeClock: programDateTimeClock } } },
              '#withProgramDateTimePeriod':: d.fn(help='', args=[d.arg(name='programDateTimePeriod', type=d.T.number)]),
              withProgramDateTimePeriod(programDateTimePeriod): { outputGroupSettings+: { hlsGroupSettings+: { programDateTimePeriod: programDateTimePeriod } } },
              '#withRedundantManifest':: d.fn(help='', args=[d.arg(name='redundantManifest', type=d.T.string)]),
              withRedundantManifest(redundantManifest): { outputGroupSettings+: { hlsGroupSettings+: { redundantManifest: redundantManifest } } },
              '#withSegmentLength':: d.fn(help='', args=[d.arg(name='segmentLength', type=d.T.number)]),
              withSegmentLength(segmentLength): { outputGroupSettings+: { hlsGroupSettings+: { segmentLength: segmentLength } } },
              '#withSegmentsPerSubdirectory':: d.fn(help='', args=[d.arg(name='segmentsPerSubdirectory', type=d.T.number)]),
              withSegmentsPerSubdirectory(segmentsPerSubdirectory): { outputGroupSettings+: { hlsGroupSettings+: { segmentsPerSubdirectory: segmentsPerSubdirectory } } },
              '#withStreamInfResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='streamInfResolution', type=d.T.string)]),
              withStreamInfResolution(streamInfResolution): { outputGroupSettings+: { hlsGroupSettings+: { streamInfResolution: streamInfResolution } } },
              '#withTimedMetadataId3Frame':: d.fn(help='"Indicates ID3 frame that has the timecode."', args=[d.arg(name='timedMetadataId3Frame', type=d.T.string)]),
              withTimedMetadataId3Frame(timedMetadataId3Frame): { outputGroupSettings+: { hlsGroupSettings+: { timedMetadataId3Frame: timedMetadataId3Frame } } },
              '#withTimedMetadataId3Period':: d.fn(help='', args=[d.arg(name='timedMetadataId3Period', type=d.T.number)]),
              withTimedMetadataId3Period(timedMetadataId3Period): { outputGroupSettings+: { hlsGroupSettings+: { timedMetadataId3Period: timedMetadataId3Period } } },
              '#withTimestampDeltaMilliseconds':: d.fn(help='', args=[d.arg(name='timestampDeltaMilliseconds', type=d.T.number)]),
              withTimestampDeltaMilliseconds(timestampDeltaMilliseconds): { outputGroupSettings+: { hlsGroupSettings+: { timestampDeltaMilliseconds: timestampDeltaMilliseconds } } },
              '#withTsFileMode':: d.fn(help='', args=[d.arg(name='tsFileMode', type=d.T.string)]),
              withTsFileMode(tsFileMode): { outputGroupSettings+: { hlsGroupSettings+: { tsFileMode: tsFileMode } } },
            },
            '#mediaPackageGroupSettings':: d.obj(help='"Media package group settings. See Media Package Group Settings for more details."'),
            mediaPackageGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { mediaPackageGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
            },
            '#msSmoothGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            msSmoothGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { msSmoothGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#withAcquisitionPointId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='acquisitionPointId', type=d.T.string)]),
              withAcquisitionPointId(acquisitionPointId): { outputGroupSettings+: { msSmoothGroupSettings+: { acquisitionPointId: acquisitionPointId } } },
              '#withAudioOnlyTimecodeControl':: d.fn(help='', args=[d.arg(name='audioOnlyTimecodeControl', type=d.T.string)]),
              withAudioOnlyTimecodeControl(audioOnlyTimecodeControl): { outputGroupSettings+: { msSmoothGroupSettings+: { audioOnlyTimecodeControl: audioOnlyTimecodeControl } } },
              '#withCertificateMode':: d.fn(help='"Setting to allow self signed or verified RTMP certificates."', args=[d.arg(name='certificateMode', type=d.T.string)]),
              withCertificateMode(certificateMode): { outputGroupSettings+: { msSmoothGroupSettings+: { certificateMode: certificateMode } } },
              '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
              withConnectionRetryInterval(connectionRetryInterval): { outputGroupSettings+: { msSmoothGroupSettings+: { connectionRetryInterval: connectionRetryInterval } } },
              '#withEventId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='eventId', type=d.T.string)]),
              withEventId(eventId): { outputGroupSettings+: { msSmoothGroupSettings+: { eventId: eventId } } },
              '#withEventIdMode':: d.fn(help='', args=[d.arg(name='eventIdMode', type=d.T.string)]),
              withEventIdMode(eventIdMode): { outputGroupSettings+: { msSmoothGroupSettings+: { eventIdMode: eventIdMode } } },
              '#withEventStopBehavior':: d.fn(help='', args=[d.arg(name='eventStopBehavior', type=d.T.string)]),
              withEventStopBehavior(eventStopBehavior): { outputGroupSettings+: { msSmoothGroupSettings+: { eventStopBehavior: eventStopBehavior } } },
              '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
              withFilecacheDuration(filecacheDuration): { outputGroupSettings+: { msSmoothGroupSettings+: { filecacheDuration: filecacheDuration } } },
              '#withFragmentLength':: d.fn(help='', args=[d.arg(name='fragmentLength', type=d.T.number)]),
              withFragmentLength(fragmentLength): { outputGroupSettings+: { msSmoothGroupSettings+: { fragmentLength: fragmentLength } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { msSmoothGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
              withNumRetries(numRetries): { outputGroupSettings+: { msSmoothGroupSettings+: { numRetries: numRetries } } },
              '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
              withRestartDelay(restartDelay): { outputGroupSettings+: { msSmoothGroupSettings+: { restartDelay: restartDelay } } },
              '#withSegmentationMode':: d.fn(help='', args=[d.arg(name='segmentationMode', type=d.T.string)]),
              withSegmentationMode(segmentationMode): { outputGroupSettings+: { msSmoothGroupSettings+: { segmentationMode: segmentationMode } } },
              '#withSendDelayMs':: d.fn(help='', args=[d.arg(name='sendDelayMs', type=d.T.number)]),
              withSendDelayMs(sendDelayMs): { outputGroupSettings+: { msSmoothGroupSettings+: { sendDelayMs: sendDelayMs } } },
              '#withSparseTrackType':: d.fn(help='', args=[d.arg(name='sparseTrackType', type=d.T.string)]),
              withSparseTrackType(sparseTrackType): { outputGroupSettings+: { msSmoothGroupSettings+: { sparseTrackType: sparseTrackType } } },
              '#withStreamManifestBehavior':: d.fn(help='', args=[d.arg(name='streamManifestBehavior', type=d.T.string)]),
              withStreamManifestBehavior(streamManifestBehavior): { outputGroupSettings+: { msSmoothGroupSettings+: { streamManifestBehavior: streamManifestBehavior } } },
              '#withTimestampOffset':: d.fn(help='', args=[d.arg(name='timestampOffset', type=d.T.string)]),
              withTimestampOffset(timestampOffset): { outputGroupSettings+: { msSmoothGroupSettings+: { timestampOffset: timestampOffset } } },
              '#withTimestampOffsetMode':: d.fn(help='', args=[d.arg(name='timestampOffsetMode', type=d.T.string)]),
              withTimestampOffsetMode(timestampOffsetMode): { outputGroupSettings+: { msSmoothGroupSettings+: { timestampOffsetMode: timestampOffsetMode } } },
            },
            '#rtmpGroupSettings':: d.obj(help='"RTMP group settings. See RTMP Group Settings for more details."'),
            rtmpGroupSettings: {
              '#withAdMarkers':: d.fn(help='"The ad marker type for this output group."', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkers(adMarkers): { outputGroupSettings+: { rtmpGroupSettings+: { adMarkers: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAdMarkersMixin':: d.fn(help='"The ad marker type for this output group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkersMixin(adMarkers): { outputGroupSettings+: { rtmpGroupSettings+: { adMarkers+: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAuthenticationScheme':: d.fn(help='"Authentication scheme to use when connecting with CDN."', args=[d.arg(name='authenticationScheme', type=d.T.string)]),
              withAuthenticationScheme(authenticationScheme): { outputGroupSettings+: { rtmpGroupSettings+: { authenticationScheme: authenticationScheme } } },
              '#withCacheFullBehavior':: d.fn(help='"Controls behavior when content cache fills up."', args=[d.arg(name='cacheFullBehavior', type=d.T.string)]),
              withCacheFullBehavior(cacheFullBehavior): { outputGroupSettings+: { rtmpGroupSettings+: { cacheFullBehavior: cacheFullBehavior } } },
              '#withCacheLength':: d.fn(help='"Cache length in seconds, is used to calculate buffer size."', args=[d.arg(name='cacheLength', type=d.T.number)]),
              withCacheLength(cacheLength): { outputGroupSettings+: { rtmpGroupSettings+: { cacheLength: cacheLength } } },
              '#withCaptionData':: d.fn(help='"Controls the types of data that passes to onCaptionInfo outputs."', args=[d.arg(name='captionData', type=d.T.string)]),
              withCaptionData(captionData): { outputGroupSettings+: { rtmpGroupSettings+: { captionData: captionData } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { rtmpGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
              withRestartDelay(restartDelay): { outputGroupSettings+: { rtmpGroupSettings+: { restartDelay: restartDelay } } },
            },
            '#udpGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            udpGroupSettings: {
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { udpGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withTimedMetadataId3Frame':: d.fn(help='"Indicates ID3 frame that has the timecode."', args=[d.arg(name='timedMetadataId3Frame', type=d.T.string)]),
              withTimedMetadataId3Frame(timedMetadataId3Frame): { outputGroupSettings+: { udpGroupSettings+: { timedMetadataId3Frame: timedMetadataId3Frame } } },
              '#withTimedMetadataId3Period':: d.fn(help='', args=[d.arg(name='timedMetadataId3Period', type=d.T.number)]),
              withTimedMetadataId3Period(timedMetadataId3Period): { outputGroupSettings+: { udpGroupSettings+: { timedMetadataId3Period: timedMetadataId3Period } } },
            },
            '#withArchiveGroupSettings':: d.fn(help='"Archive group settings. See Archive Group Settings for more details."', args=[d.arg(name='archiveGroupSettings', type=d.T.array)]),
            withArchiveGroupSettings(archiveGroupSettings): { outputGroupSettings+: { archiveGroupSettings: if std.isArray(v=archiveGroupSettings) then archiveGroupSettings else [archiveGroupSettings] } },
            '#withArchiveGroupSettingsMixin':: d.fn(help='"Archive group settings. See Archive Group Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='archiveGroupSettings', type=d.T.array)]),
            withArchiveGroupSettingsMixin(archiveGroupSettings): { outputGroupSettings+: { archiveGroupSettings+: if std.isArray(v=archiveGroupSettings) then archiveGroupSettings else [archiveGroupSettings] } },
            '#withMultiplexGroupSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='multiplexGroupSettings', type=d.T.object)]),
            withMultiplexGroupSettings(multiplexGroupSettings): { outputGroupSettings+: { multiplexGroupSettings: multiplexGroupSettings } },
            '#withMultiplexGroupSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='multiplexGroupSettings', type=d.T.object)]),
            withMultiplexGroupSettingsMixin(multiplexGroupSettings): { outputGroupSettings+: { multiplexGroupSettings+: multiplexGroupSettings } },
          },
          '#outputs':: d.obj(help='"List of outputs. See Outputs for more details."'),
          outputs: {
            '#outputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
            outputSettings: {
              '#archiveOutputSettings':: d.obj(help='"Archive output settings. See Archive Output Settings for more details."'),
              archiveOutputSettings: {
                '#containerSettings':: d.obj(help='"Settings specific to the container type of the file. See Container Settings for more details."'),
                containerSettings: {
                  '#m2tsSettings':: d.obj(help='"M2TS Settings. See M2TS Settings for more details."'),
                  m2tsSettings: {
                    '#dvbNitSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbNitSettings: {
                      '#withNetworkId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='networkId', type=d.T.number)]),
                      withNetworkId(networkId): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkId: networkId } } } } } },
                      '#withNetworkName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='networkName', type=d.T.string)]),
                      withNetworkName(networkName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkName: networkName } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#dvbSdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbSdtSettings: {
                      '#withOutputSdt':: d.fn(help='', args=[d.arg(name='outputSdt', type=d.T.string)]),
                      withOutputSdt(outputSdt): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { outputSdt: outputSdt } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { repInterval: repInterval } } } } } },
                      '#withServiceName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceName', type=d.T.string)]),
                      withServiceName(serviceName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceName: serviceName } } } } } },
                      '#withServiceProviderName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceProviderName', type=d.T.string)]),
                      withServiceProviderName(serviceProviderName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceProviderName: serviceProviderName } } } } } },
                    },
                    '#dvbTdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbTdtSettings: {
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTdtSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#withAbsentInputAudioBehavior':: d.fn(help='', args=[d.arg(name='absentInputAudioBehavior', type=d.T.string)]),
                    withAbsentInputAudioBehavior(absentInputAudioBehavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { absentInputAudioBehavior: absentInputAudioBehavior } } } } },
                    '#withArib':: d.fn(help='', args=[d.arg(name='arib', type=d.T.string)]),
                    withArib(arib): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { arib: arib } } } } },
                    '#withAribCaptionsPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='aribCaptionsPid', type=d.T.string)]),
                    withAribCaptionsPid(aribCaptionsPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPid: aribCaptionsPid } } } } },
                    '#withAribCaptionsPidControl':: d.fn(help='', args=[d.arg(name='aribCaptionsPidControl', type=d.T.string)]),
                    withAribCaptionsPidControl(aribCaptionsPidControl): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPidControl: aribCaptionsPidControl } } } } },
                    '#withAudioBufferModel':: d.fn(help='', args=[d.arg(name='audioBufferModel', type=d.T.string)]),
                    withAudioBufferModel(audioBufferModel): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioBufferModel: audioBufferModel } } } } },
                    '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                    withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioFramesPerPes: audioFramesPerPes } } } } },
                    '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                    withAudioPids(audioPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioPids: audioPids } } } } },
                    '#withAudioStreamType':: d.fn(help='', args=[d.arg(name='audioStreamType', type=d.T.string)]),
                    withAudioStreamType(audioStreamType): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioStreamType: audioStreamType } } } } },
                    '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
                    withBitrate(bitrate): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { bitrate: bitrate } } } } },
                    '#withBufferModel':: d.fn(help='', args=[d.arg(name='bufferModel', type=d.T.string)]),
                    withBufferModel(bufferModel): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { bufferModel: bufferModel } } } } },
                    '#withCcDescriptor':: d.fn(help='', args=[d.arg(name='ccDescriptor', type=d.T.string)]),
                    withCcDescriptor(ccDescriptor): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ccDescriptor: ccDescriptor } } } } },
                    '#withDvbSubPids':: d.fn(help='', args=[d.arg(name='dvbSubPids', type=d.T.string)]),
                    withDvbSubPids(dvbSubPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSubPids: dvbSubPids } } } } },
                    '#withDvbTeletextPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='dvbTeletextPid', type=d.T.string)]),
                    withDvbTeletextPid(dvbTeletextPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTeletextPid: dvbTeletextPid } } } } },
                    '#withEbif':: d.fn(help='', args=[d.arg(name='ebif', type=d.T.string)]),
                    withEbif(ebif): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebif: ebif } } } } },
                    '#withEbpAudioInterval':: d.fn(help='', args=[d.arg(name='ebpAudioInterval', type=d.T.string)]),
                    withEbpAudioInterval(ebpAudioInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpAudioInterval: ebpAudioInterval } } } } },
                    '#withEbpLookaheadMs':: d.fn(help='', args=[d.arg(name='ebpLookaheadMs', type=d.T.number)]),
                    withEbpLookaheadMs(ebpLookaheadMs): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpLookaheadMs: ebpLookaheadMs } } } } },
                    '#withEbpPlacement':: d.fn(help='', args=[d.arg(name='ebpPlacement', type=d.T.string)]),
                    withEbpPlacement(ebpPlacement): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpPlacement: ebpPlacement } } } } },
                    '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                    withEcmPid(ecmPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ecmPid: ecmPid } } } } },
                    '#withEsRateInPes':: d.fn(help='', args=[d.arg(name='esRateInPes', type=d.T.string)]),
                    withEsRateInPes(esRateInPes): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { esRateInPes: esRateInPes } } } } },
                    '#withEtvPlatformPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvPlatformPid', type=d.T.string)]),
                    withEtvPlatformPid(etvPlatformPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { etvPlatformPid: etvPlatformPid } } } } },
                    '#withEtvSignalPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvSignalPid', type=d.T.string)]),
                    withEtvSignalPid(etvSignalPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { etvSignalPid: etvSignalPid } } } } },
                    '#withFragmentTime':: d.fn(help='', args=[d.arg(name='fragmentTime', type=d.T.number)]),
                    withFragmentTime(fragmentTime): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { fragmentTime: fragmentTime } } } } },
                    '#withKlv':: d.fn(help='', args=[d.arg(name='klv', type=d.T.string)]),
                    withKlv(klv): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { klv: klv } } } } },
                    '#withKlvDataPids':: d.fn(help='', args=[d.arg(name='klvDataPids', type=d.T.string)]),
                    withKlvDataPids(klvDataPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { klvDataPids: klvDataPids } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withNullPacketBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='nullPacketBitrate', type=d.T.number)]),
                    withNullPacketBitrate(nullPacketBitrate): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { nullPacketBitrate: nullPacketBitrate } } } } },
                    '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                    withPatInterval(patInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { patInterval: patInterval } } } } },
                    '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                    withPcrControl(pcrControl): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrControl: pcrControl } } } } },
                    '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                    withPcrPeriod(pcrPeriod): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPeriod: pcrPeriod } } } } },
                    '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                    withPcrPid(pcrPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPid: pcrPid } } } } },
                    '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                    withPmtInterval(pmtInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtInterval: pmtInterval } } } } },
                    '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                    withPmtPid(pmtPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtPid: pmtPid } } } } },
                    '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                    withProgramNum(programNum): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { programNum: programNum } } } } },
                    '#withRateMode':: d.fn(help='', args=[d.arg(name='rateMode', type=d.T.string)]),
                    withRateMode(rateMode): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { rateMode: rateMode } } } } },
                    '#withScte27Pids':: d.fn(help='', args=[d.arg(name='scte27Pids', type=d.T.string)]),
                    withScte27Pids(scte27Pids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte27Pids: scte27Pids } } } } },
                    '#withScte35Control':: d.fn(help='', args=[d.arg(name='scte35Control', type=d.T.string)]),
                    withScte35Control(scte35Control): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Control: scte35Control } } } } },
                    '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                    withScte35Pid(scte35Pid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Pid: scte35Pid } } } } },
                    '#withSegmentationMarkers':: d.fn(help='', args=[d.arg(name='segmentationMarkers', type=d.T.string)]),
                    withSegmentationMarkers(segmentationMarkers): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationMarkers: segmentationMarkers } } } } },
                    '#withSegmentationStyle':: d.fn(help='', args=[d.arg(name='segmentationStyle', type=d.T.string)]),
                    withSegmentationStyle(segmentationStyle): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationStyle: segmentationStyle } } } } },
                    '#withSegmentationTime':: d.fn(help='', args=[d.arg(name='segmentationTime', type=d.T.number)]),
                    withSegmentationTime(segmentationTime): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationTime: segmentationTime } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                    '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                    withTimedMetadataPid(timedMetadataPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataPid: timedMetadataPid } } } } },
                    '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                    withTransportStreamId(transportStreamId): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { transportStreamId: transportStreamId } } } } },
                    '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                    withVideoPid(videoPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { videoPid: videoPid } } } } },
                  },
                  '#withRawSettings':: d.fn(help='"Raw Settings. This can be set as an empty block."', args=[d.arg(name='rawSettings', type=d.T.object)]),
                  withRawSettings(rawSettings): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { rawSettings: rawSettings } } } },
                  '#withRawSettingsMixin':: d.fn(help='"Raw Settings. This can be set as an empty block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rawSettings', type=d.T.object)]),
                  withRawSettingsMixin(rawSettings): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { rawSettings+: rawSettings } } } },
                },
                '#withExtension':: d.fn(help='"Output file extension."', args=[d.arg(name='extension', type=d.T.string)]),
                withExtension(extension): { outputSettings+: { archiveOutputSettings+: { extension: extension } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { archiveOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#frameCaptureOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              frameCaptureOutputSettings: {
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { frameCaptureOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#hlsOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              hlsOutputSettings: {
                '#hlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsSettings: {
                  '#audioOnlyHlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  audioOnlyHlsSettings: {
                    '#audioOnlyImage':: d.obj(help=''),
                    audioOnlyImage: {
                      '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                      withPasswordParam(passwordParam): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { passwordParam: passwordParam } } } } } },
                      '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                      withUri(uri): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { uri: uri } } } } } },
                      '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                      withUsername(username): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { username: username } } } } } },
                    },
                    '#withAudioGroupId':: d.fn(help='"Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition."', args=[d.arg(name='audioGroupId', type=d.T.string)]),
                    withAudioGroupId(audioGroupId): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioGroupId: audioGroupId } } } } },
                    '#withAudioTrackType':: d.fn(help='', args=[d.arg(name='audioTrackType', type=d.T.string)]),
                    withAudioTrackType(audioTrackType): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioTrackType: audioTrackType } } } } },
                    '#withSegmentType':: d.fn(help='', args=[d.arg(name='segmentType', type=d.T.string)]),
                    withSegmentType(segmentType): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { segmentType: segmentType } } } } },
                  },
                  '#fmp4HlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  fmp4HlsSettings: {
                    '#withAudioRenditionSets':: d.fn(help='', args=[d.arg(name='audioRenditionSets', type=d.T.string)]),
                    withAudioRenditionSets(audioRenditionSets): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { audioRenditionSets: audioRenditionSets } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                  },
                  '#standardHlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  standardHlsSettings: {
                    '#m3u8Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    m3u8Settings: {
                      '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                      withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { audioFramesPerPes: audioFramesPerPes } } } } } },
                      '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                      withAudioPids(audioPids): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { audioPids: audioPids } } } } } },
                      '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                      withEcmPid(ecmPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { ecmPid: ecmPid } } } } } },
                      '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                      withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { nielsenId3Behavior: nielsenId3Behavior } } } } } },
                      '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                      withPatInterval(patInterval): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { patInterval: patInterval } } } } } },
                      '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                      withPcrControl(pcrControl): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrControl: pcrControl } } } } } },
                      '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                      withPcrPeriod(pcrPeriod): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrPeriod: pcrPeriod } } } } } },
                      '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                      withPcrPid(pcrPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrPid: pcrPid } } } } } },
                      '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                      withPmtInterval(pmtInterval): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pmtInterval: pmtInterval } } } } } },
                      '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                      withPmtPid(pmtPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pmtPid: pmtPid } } } } } },
                      '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                      withProgramNum(programNum): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { programNum: programNum } } } } } },
                      '#withScte35Behavior':: d.fn(help='', args=[d.arg(name='scte35Behavior', type=d.T.string)]),
                      withScte35Behavior(scte35Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { scte35Behavior: scte35Behavior } } } } } },
                      '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                      withScte35Pid(scte35Pid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { scte35Pid: scte35Pid } } } } } },
                      '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                      withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { timedMetadataBehavior: timedMetadataBehavior } } } } } },
                      '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                      withTimedMetadataPid(timedMetadataPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { timedMetadataPid: timedMetadataPid } } } } } },
                      '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                      withTransportStreamId(transportStreamId): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { transportStreamId: transportStreamId } } } } } },
                      '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                      withVideoPid(videoPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { videoPid: videoPid } } } } } },
                    },
                    '#withAudioRenditionSets':: d.fn(help='', args=[d.arg(name='audioRenditionSets', type=d.T.string)]),
                    withAudioRenditionSets(audioRenditionSets): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { audioRenditionSets: audioRenditionSets } } } } },
                  },
                  '#withFrameCaptureHlsSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='frameCaptureHlsSettings', type=d.T.object)]),
                  withFrameCaptureHlsSettings(frameCaptureHlsSettings): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { frameCaptureHlsSettings: frameCaptureHlsSettings } } } },
                  '#withFrameCaptureHlsSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='frameCaptureHlsSettings', type=d.T.object)]),
                  withFrameCaptureHlsSettingsMixin(frameCaptureHlsSettings): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { frameCaptureHlsSettings+: frameCaptureHlsSettings } } } },
                },
                '#withH265PackagingType':: d.fn(help='', args=[d.arg(name='h265PackagingType', type=d.T.string)]),
                withH265PackagingType(h265PackagingType): { outputSettings+: { hlsOutputSettings+: { h265PackagingType: h265PackagingType } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { hlsOutputSettings+: { nameModifier: nameModifier } } },
                '#withSegmentModifier':: d.fn(help='', args=[d.arg(name='segmentModifier', type=d.T.string)]),
                withSegmentModifier(segmentModifier): { outputSettings+: { hlsOutputSettings+: { segmentModifier: segmentModifier } } },
              },
              '#msSmoothOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              msSmoothOutputSettings: {
                '#withH265PackagingType':: d.fn(help='', args=[d.arg(name='h265PackagingType', type=d.T.string)]),
                withH265PackagingType(h265PackagingType): { outputSettings+: { msSmoothOutputSettings+: { h265PackagingType: h265PackagingType } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { msSmoothOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#multiplexOutputSettings':: d.obj(help='"Multiplex output settings. See Multiplex Output Settings for more details."'),
              multiplexOutputSettings: {
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { multiplexOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
              },
              '#rtmpOutputSettings':: d.obj(help='"RTMP output settings. See RTMP Output Settings for more details."'),
              rtmpOutputSettings: {
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { rtmpOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
                '#withCertificateMode':: d.fn(help='"Setting to allow self signed or verified RTMP certificates."', args=[d.arg(name='certificateMode', type=d.T.string)]),
                withCertificateMode(certificateMode): { outputSettings+: { rtmpOutputSettings+: { certificateMode: certificateMode } } },
                '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                withConnectionRetryInterval(connectionRetryInterval): { outputSettings+: { rtmpOutputSettings+: { connectionRetryInterval: connectionRetryInterval } } },
                '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                withNumRetries(numRetries): { outputSettings+: { rtmpOutputSettings+: { numRetries: numRetries } } },
              },
              '#udpOutputSettings':: d.obj(help='"UDP output settings. See UDP Output Settings for more details."'),
              udpOutputSettings: {
                '#containerSettings':: d.obj(help='"Settings specific to the container type of the file. See Container Settings for more details."'),
                containerSettings: {
                  '#m2tsSettings':: d.obj(help='"M2TS Settings. See M2TS Settings for more details."'),
                  m2tsSettings: {
                    '#dvbNitSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbNitSettings: {
                      '#withNetworkId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='networkId', type=d.T.number)]),
                      withNetworkId(networkId): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkId: networkId } } } } } },
                      '#withNetworkName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='networkName', type=d.T.string)]),
                      withNetworkName(networkName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkName: networkName } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#dvbSdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbSdtSettings: {
                      '#withOutputSdt':: d.fn(help='', args=[d.arg(name='outputSdt', type=d.T.string)]),
                      withOutputSdt(outputSdt): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { outputSdt: outputSdt } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { repInterval: repInterval } } } } } },
                      '#withServiceName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceName', type=d.T.string)]),
                      withServiceName(serviceName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceName: serviceName } } } } } },
                      '#withServiceProviderName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceProviderName', type=d.T.string)]),
                      withServiceProviderName(serviceProviderName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceProviderName: serviceProviderName } } } } } },
                    },
                    '#dvbTdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbTdtSettings: {
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTdtSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#withAbsentInputAudioBehavior':: d.fn(help='', args=[d.arg(name='absentInputAudioBehavior', type=d.T.string)]),
                    withAbsentInputAudioBehavior(absentInputAudioBehavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { absentInputAudioBehavior: absentInputAudioBehavior } } } } },
                    '#withArib':: d.fn(help='', args=[d.arg(name='arib', type=d.T.string)]),
                    withArib(arib): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { arib: arib } } } } },
                    '#withAribCaptionsPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='aribCaptionsPid', type=d.T.string)]),
                    withAribCaptionsPid(aribCaptionsPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPid: aribCaptionsPid } } } } },
                    '#withAribCaptionsPidControl':: d.fn(help='', args=[d.arg(name='aribCaptionsPidControl', type=d.T.string)]),
                    withAribCaptionsPidControl(aribCaptionsPidControl): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPidControl: aribCaptionsPidControl } } } } },
                    '#withAudioBufferModel':: d.fn(help='', args=[d.arg(name='audioBufferModel', type=d.T.string)]),
                    withAudioBufferModel(audioBufferModel): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioBufferModel: audioBufferModel } } } } },
                    '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                    withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioFramesPerPes: audioFramesPerPes } } } } },
                    '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                    withAudioPids(audioPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioPids: audioPids } } } } },
                    '#withAudioStreamType':: d.fn(help='', args=[d.arg(name='audioStreamType', type=d.T.string)]),
                    withAudioStreamType(audioStreamType): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioStreamType: audioStreamType } } } } },
                    '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
                    withBitrate(bitrate): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { bitrate: bitrate } } } } },
                    '#withBufferModel':: d.fn(help='', args=[d.arg(name='bufferModel', type=d.T.string)]),
                    withBufferModel(bufferModel): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { bufferModel: bufferModel } } } } },
                    '#withCcDescriptor':: d.fn(help='', args=[d.arg(name='ccDescriptor', type=d.T.string)]),
                    withCcDescriptor(ccDescriptor): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ccDescriptor: ccDescriptor } } } } },
                    '#withDvbSubPids':: d.fn(help='', args=[d.arg(name='dvbSubPids', type=d.T.string)]),
                    withDvbSubPids(dvbSubPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSubPids: dvbSubPids } } } } },
                    '#withDvbTeletextPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='dvbTeletextPid', type=d.T.string)]),
                    withDvbTeletextPid(dvbTeletextPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTeletextPid: dvbTeletextPid } } } } },
                    '#withEbif':: d.fn(help='', args=[d.arg(name='ebif', type=d.T.string)]),
                    withEbif(ebif): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebif: ebif } } } } },
                    '#withEbpAudioInterval':: d.fn(help='', args=[d.arg(name='ebpAudioInterval', type=d.T.string)]),
                    withEbpAudioInterval(ebpAudioInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpAudioInterval: ebpAudioInterval } } } } },
                    '#withEbpLookaheadMs':: d.fn(help='', args=[d.arg(name='ebpLookaheadMs', type=d.T.number)]),
                    withEbpLookaheadMs(ebpLookaheadMs): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpLookaheadMs: ebpLookaheadMs } } } } },
                    '#withEbpPlacement':: d.fn(help='', args=[d.arg(name='ebpPlacement', type=d.T.string)]),
                    withEbpPlacement(ebpPlacement): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpPlacement: ebpPlacement } } } } },
                    '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                    withEcmPid(ecmPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ecmPid: ecmPid } } } } },
                    '#withEsRateInPes':: d.fn(help='', args=[d.arg(name='esRateInPes', type=d.T.string)]),
                    withEsRateInPes(esRateInPes): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { esRateInPes: esRateInPes } } } } },
                    '#withEtvPlatformPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvPlatformPid', type=d.T.string)]),
                    withEtvPlatformPid(etvPlatformPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { etvPlatformPid: etvPlatformPid } } } } },
                    '#withEtvSignalPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvSignalPid', type=d.T.string)]),
                    withEtvSignalPid(etvSignalPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { etvSignalPid: etvSignalPid } } } } },
                    '#withFragmentTime':: d.fn(help='', args=[d.arg(name='fragmentTime', type=d.T.number)]),
                    withFragmentTime(fragmentTime): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { fragmentTime: fragmentTime } } } } },
                    '#withKlv':: d.fn(help='', args=[d.arg(name='klv', type=d.T.string)]),
                    withKlv(klv): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { klv: klv } } } } },
                    '#withKlvDataPids':: d.fn(help='', args=[d.arg(name='klvDataPids', type=d.T.string)]),
                    withKlvDataPids(klvDataPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { klvDataPids: klvDataPids } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withNullPacketBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='nullPacketBitrate', type=d.T.number)]),
                    withNullPacketBitrate(nullPacketBitrate): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { nullPacketBitrate: nullPacketBitrate } } } } },
                    '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                    withPatInterval(patInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { patInterval: patInterval } } } } },
                    '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                    withPcrControl(pcrControl): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrControl: pcrControl } } } } },
                    '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                    withPcrPeriod(pcrPeriod): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPeriod: pcrPeriod } } } } },
                    '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                    withPcrPid(pcrPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPid: pcrPid } } } } },
                    '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                    withPmtInterval(pmtInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtInterval: pmtInterval } } } } },
                    '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                    withPmtPid(pmtPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtPid: pmtPid } } } } },
                    '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                    withProgramNum(programNum): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { programNum: programNum } } } } },
                    '#withRateMode':: d.fn(help='', args=[d.arg(name='rateMode', type=d.T.string)]),
                    withRateMode(rateMode): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { rateMode: rateMode } } } } },
                    '#withScte27Pids':: d.fn(help='', args=[d.arg(name='scte27Pids', type=d.T.string)]),
                    withScte27Pids(scte27Pids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte27Pids: scte27Pids } } } } },
                    '#withScte35Control':: d.fn(help='', args=[d.arg(name='scte35Control', type=d.T.string)]),
                    withScte35Control(scte35Control): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Control: scte35Control } } } } },
                    '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                    withScte35Pid(scte35Pid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Pid: scte35Pid } } } } },
                    '#withSegmentationMarkers':: d.fn(help='', args=[d.arg(name='segmentationMarkers', type=d.T.string)]),
                    withSegmentationMarkers(segmentationMarkers): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationMarkers: segmentationMarkers } } } } },
                    '#withSegmentationStyle':: d.fn(help='', args=[d.arg(name='segmentationStyle', type=d.T.string)]),
                    withSegmentationStyle(segmentationStyle): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationStyle: segmentationStyle } } } } },
                    '#withSegmentationTime':: d.fn(help='', args=[d.arg(name='segmentationTime', type=d.T.number)]),
                    withSegmentationTime(segmentationTime): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationTime: segmentationTime } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                    '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                    withTimedMetadataPid(timedMetadataPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataPid: timedMetadataPid } } } } },
                    '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                    withTransportStreamId(transportStreamId): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { transportStreamId: transportStreamId } } } } },
                    '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                    withVideoPid(videoPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { videoPid: videoPid } } } } },
                  },
                },
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { udpOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
                '#fecOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
                fecOutputSettings: {
                  '#withColumnDepth':: d.fn(help='"The height of the FEC protection matrix."', args=[d.arg(name='columnDepth', type=d.T.number)]),
                  withColumnDepth(columnDepth): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { columnDepth: columnDepth } } } },
                  '#withIncludeFec':: d.fn(help='"Enables column only or column and row based FEC."', args=[d.arg(name='includeFec', type=d.T.string)]),
                  withIncludeFec(includeFec): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { includeFec: includeFec } } } },
                  '#withRowLength':: d.fn(help='"The width of the FEC protection matrix."', args=[d.arg(name='rowLength', type=d.T.number)]),
                  withRowLength(rowLength): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { rowLength: rowLength } } } },
                },
                '#withBufferMsec':: d.fn(help='"UDP output buffering in milliseconds."', args=[d.arg(name='bufferMsec', type=d.T.number)]),
                withBufferMsec(bufferMsec): { outputSettings+: { udpOutputSettings+: { bufferMsec: bufferMsec } } },
              },
              '#withMediaPackageOutputSettings':: d.fn(help='"Media package output settings. This can be set as an empty block."', args=[d.arg(name='mediaPackageOutputSettings', type=d.T.object)]),
              withMediaPackageOutputSettings(mediaPackageOutputSettings): { outputSettings+: { mediaPackageOutputSettings: mediaPackageOutputSettings } },
              '#withMediaPackageOutputSettingsMixin':: d.fn(help='"Media package output settings. This can be set as an empty block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mediaPackageOutputSettings', type=d.T.object)]),
              withMediaPackageOutputSettingsMixin(mediaPackageOutputSettings): { outputSettings+: { mediaPackageOutputSettings+: mediaPackageOutputSettings } },
            },
            '#withAudioDescriptionNames':: d.fn(help='"The names of the audio descriptions used as audio sources for the output."', args=[d.arg(name='audioDescriptionNames', type=d.T.array)]),
            withAudioDescriptionNames(audioDescriptionNames): { audioDescriptionNames: if std.isArray(v=audioDescriptionNames) then audioDescriptionNames else [audioDescriptionNames] },
            '#withAudioDescriptionNamesMixin':: d.fn(help='"The names of the audio descriptions used as audio sources for the output."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioDescriptionNames', type=d.T.array)]),
            withAudioDescriptionNamesMixin(audioDescriptionNames): { audioDescriptionNames+: if std.isArray(v=audioDescriptionNames) then audioDescriptionNames else [audioDescriptionNames] },
            '#withCaptionDescriptionNames':: d.fn(help='"The names of the caption descriptions used as caption sources for the output."', args=[d.arg(name='captionDescriptionNames', type=d.T.array)]),
            withCaptionDescriptionNames(captionDescriptionNames): { captionDescriptionNames: if std.isArray(v=captionDescriptionNames) then captionDescriptionNames else [captionDescriptionNames] },
            '#withCaptionDescriptionNamesMixin':: d.fn(help='"The names of the caption descriptions used as caption sources for the output."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionDescriptionNames', type=d.T.array)]),
            withCaptionDescriptionNamesMixin(captionDescriptionNames): { captionDescriptionNames+: if std.isArray(v=captionDescriptionNames) then captionDescriptionNames else [captionDescriptionNames] },
            '#withOutputName':: d.fn(help='"The name used to identify an output."', args=[d.arg(name='outputName', type=d.T.string)]),
            withOutputName(outputName): { outputName: outputName },
            '#withVideoDescriptionName':: d.fn(help='"The name of the video description used as video source for the output."', args=[d.arg(name='videoDescriptionName', type=d.T.string)]),
            withVideoDescriptionName(videoDescriptionName): { videoDescriptionName: videoDescriptionName },
          },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withOutputs':: d.fn(help='"List of outputs. See Outputs for more details."', args=[d.arg(name='outputs', type=d.T.array)]),
          withOutputs(outputs): { outputs: if std.isArray(v=outputs) then outputs else [outputs] },
          '#withOutputsMixin':: d.fn(help='"List of outputs. See Outputs for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='outputs', type=d.T.array)]),
          withOutputsMixin(outputs): { outputs+: if std.isArray(v=outputs) then outputs else [outputs] },
        },
        '#timecodeConfig':: d.obj(help='"Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details."'),
        timecodeConfig: {
          '#withSource':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='source', type=d.T.string)]),
          withSource(source): { spec+: { forProvider+: { encoderSettings+: { timecodeConfig+: { source: source } } } } },
          '#withSyncThreshold':: d.fn(help='"Threshold in frames beyond which output timecode is resynchronized to the input timecode."', args=[d.arg(name='syncThreshold', type=d.T.number)]),
          withSyncThreshold(syncThreshold): { spec+: { forProvider+: { encoderSettings+: { timecodeConfig+: { syncThreshold: syncThreshold } } } } },
        },
        '#videoDescriptions':: d.obj(help='"Video Descriptions. See Video Descriptions for more details."'),
        videoDescriptions: {
          '#codecSettings':: d.obj(help='"Audio codec settings. See Audio Codec Settings for more details."'),
          codecSettings: {
            '#frameCaptureSettings':: d.obj(help='"Frame capture settings. See Frame Capture Settings for more details."'),
            frameCaptureSettings: {
              '#withCaptureInterval':: d.fn(help='"The frequency at which to capture frames for inclusion in the output."', args=[d.arg(name='captureInterval', type=d.T.number)]),
              withCaptureInterval(captureInterval): { codecSettings+: { frameCaptureSettings+: { captureInterval: captureInterval } } },
              '#withCaptureIntervalUnits':: d.fn(help='"Unit for the frame capture interval."', args=[d.arg(name='captureIntervalUnits', type=d.T.string)]),
              withCaptureIntervalUnits(captureIntervalUnits): { codecSettings+: { frameCaptureSettings+: { captureIntervalUnits: captureIntervalUnits } } },
            },
            '#h264Settings':: d.obj(help='"H264 settings. See H264 Settings for more details."'),
            h264Settings: {
              '#filterSettings':: d.obj(help='"Filters to apply to an encode. See H264 Filter Settings for more details."'),
              filterSettings: {
                '#temporalFilterSettings':: d.obj(help='"Temporal filter settings. See Temporal Filter Settings"'),
                temporalFilterSettings: {
                  '#withPostFilterSharpening':: d.fn(help='"Post filter sharpening."', args=[d.arg(name='postFilterSharpening', type=d.T.string)]),
                  withPostFilterSharpening(postFilterSharpening): { codecSettings+: { h264Settings+: { filterSettings+: { temporalFilterSettings+: { postFilterSharpening: postFilterSharpening } } } } },
                  '#withStrength':: d.fn(help='"Filter strength."', args=[d.arg(name='strength', type=d.T.string)]),
                  withStrength(strength): { codecSettings+: { h264Settings+: { filterSettings+: { temporalFilterSettings+: { strength: strength } } } } },
                },
              },
              '#withAdaptiveQuantization':: d.fn(help='"Enables or disables adaptive quantization."', args=[d.arg(name='adaptiveQuantization', type=d.T.string)]),
              withAdaptiveQuantization(adaptiveQuantization): { codecSettings+: { h264Settings+: { adaptiveQuantization: adaptiveQuantization } } },
              '#withAfdSignaling':: d.fn(help='"Indicates that AFD values will be written into the output stream."', args=[d.arg(name='afdSignaling', type=d.T.string)]),
              withAfdSignaling(afdSignaling): { codecSettings+: { h264Settings+: { afdSignaling: afdSignaling } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { h264Settings+: { bitrate: bitrate } } },
              '#withBufFillPct':: d.fn(help='', args=[d.arg(name='bufFillPct', type=d.T.number)]),
              withBufFillPct(bufFillPct): { codecSettings+: { h264Settings+: { bufFillPct: bufFillPct } } },
              '#withBufSize':: d.fn(help='"Size of buffer in bits."', args=[d.arg(name='bufSize', type=d.T.number)]),
              withBufSize(bufSize): { codecSettings+: { h264Settings+: { bufSize: bufSize } } },
              '#withColorMetadata':: d.fn(help='"Includes color space metadata in the output."', args=[d.arg(name='colorMetadata', type=d.T.string)]),
              withColorMetadata(colorMetadata): { codecSettings+: { h264Settings+: { colorMetadata: colorMetadata } } },
              '#withEntropyEncoding':: d.fn(help='"Entropy encoding mode."', args=[d.arg(name='entropyEncoding', type=d.T.string)]),
              withEntropyEncoding(entropyEncoding): { codecSettings+: { h264Settings+: { entropyEncoding: entropyEncoding } } },
              '#withFixedAfd':: d.fn(help='"Four bit AFD value to write on all frames of video in the output stream."', args=[d.arg(name='fixedAfd', type=d.T.string)]),
              withFixedAfd(fixedAfd): { codecSettings+: { h264Settings+: { fixedAfd: fixedAfd } } },
              '#withFlickerAq':: d.fn(help='', args=[d.arg(name='flickerAq', type=d.T.string)]),
              withFlickerAq(flickerAq): { codecSettings+: { h264Settings+: { flickerAq: flickerAq } } },
              '#withForceFieldPictures':: d.fn(help='"Controls whether coding is performed on a field basis or on a frame basis."', args=[d.arg(name='forceFieldPictures', type=d.T.string)]),
              withForceFieldPictures(forceFieldPictures): { codecSettings+: { h264Settings+: { forceFieldPictures: forceFieldPictures } } },
              '#withFramerateControl':: d.fn(help='"Indicates how the output video frame rate is specified."', args=[d.arg(name='framerateControl', type=d.T.string)]),
              withFramerateControl(framerateControl): { codecSettings+: { h264Settings+: { framerateControl: framerateControl } } },
              '#withFramerateDenominator':: d.fn(help='"Framerate denominator."', args=[d.arg(name='framerateDenominator', type=d.T.number)]),
              withFramerateDenominator(framerateDenominator): { codecSettings+: { h264Settings+: { framerateDenominator: framerateDenominator } } },
              '#withFramerateNumerator':: d.fn(help='"Framerate numerator."', args=[d.arg(name='framerateNumerator', type=d.T.number)]),
              withFramerateNumerator(framerateNumerator): { codecSettings+: { h264Settings+: { framerateNumerator: framerateNumerator } } },
              '#withGopBReference':: d.fn(help='"GOP-B reference."', args=[d.arg(name='gopBReference', type=d.T.string)]),
              withGopBReference(gopBReference): { codecSettings+: { h264Settings+: { gopBReference: gopBReference } } },
              '#withGopClosedCadence':: d.fn(help='"Frequency of closed GOPs."', args=[d.arg(name='gopClosedCadence', type=d.T.number)]),
              withGopClosedCadence(gopClosedCadence): { codecSettings+: { h264Settings+: { gopClosedCadence: gopClosedCadence } } },
              '#withGopNumBFrames':: d.fn(help='"Number of B-frames between reference frames."', args=[d.arg(name='gopNumBFrames', type=d.T.number)]),
              withGopNumBFrames(gopNumBFrames): { codecSettings+: { h264Settings+: { gopNumBFrames: gopNumBFrames } } },
              '#withGopSize':: d.fn(help='"GOP size in units of either frames of seconds per gop_size_units."', args=[d.arg(name='gopSize', type=d.T.number)]),
              withGopSize(gopSize): { codecSettings+: { h264Settings+: { gopSize: gopSize } } },
              '#withGopSizeUnits':: d.fn(help='"Indicates if the gop_size is specified in frames or seconds."', args=[d.arg(name='gopSizeUnits', type=d.T.string)]),
              withGopSizeUnits(gopSizeUnits): { codecSettings+: { h264Settings+: { gopSizeUnits: gopSizeUnits } } },
              '#withLevel':: d.fn(help='"H264 level."', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { codecSettings+: { h264Settings+: { level: level } } },
              '#withLookAheadRateControl':: d.fn(help='"Amount of lookahead."', args=[d.arg(name='lookAheadRateControl', type=d.T.string)]),
              withLookAheadRateControl(lookAheadRateControl): { codecSettings+: { h264Settings+: { lookAheadRateControl: lookAheadRateControl } } },
              '#withMaxBitrate':: d.fn(help='"Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video."', args=[d.arg(name='maxBitrate', type=d.T.number)]),
              withMaxBitrate(maxBitrate): { codecSettings+: { h264Settings+: { maxBitrate: maxBitrate } } },
              '#withMinIInterval':: d.fn(help='"Min interval."', args=[d.arg(name='minIInterval', type=d.T.number)]),
              withMinIInterval(minIInterval): { codecSettings+: { h264Settings+: { minIInterval: minIInterval } } },
              '#withNumRefFrames':: d.fn(help='"Number of reference frames to use."', args=[d.arg(name='numRefFrames', type=d.T.number)]),
              withNumRefFrames(numRefFrames): { codecSettings+: { h264Settings+: { numRefFrames: numRefFrames } } },
              '#withParControl':: d.fn(help='"Indicates how the output pixel aspect ratio is specified."', args=[d.arg(name='parControl', type=d.T.string)]),
              withParControl(parControl): { codecSettings+: { h264Settings+: { parControl: parControl } } },
              '#withParDenominator':: d.fn(help='"Pixel Aspect Ratio denominator."', args=[d.arg(name='parDenominator', type=d.T.number)]),
              withParDenominator(parDenominator): { codecSettings+: { h264Settings+: { parDenominator: parDenominator } } },
              '#withParNumerator':: d.fn(help='"Pixel Aspect Ratio numerator."', args=[d.arg(name='parNumerator', type=d.T.number)]),
              withParNumerator(parNumerator): { codecSettings+: { h264Settings+: { parNumerator: parNumerator } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { h264Settings+: { profile: profile } } },
              '#withQualityLevel':: d.fn(help='"Quality level."', args=[d.arg(name='qualityLevel', type=d.T.string)]),
              withQualityLevel(qualityLevel): { codecSettings+: { h264Settings+: { qualityLevel: qualityLevel } } },
              '#withQvbrQualityLevel':: d.fn(help='"Controls the target quality for the video encode."', args=[d.arg(name='qvbrQualityLevel', type=d.T.number)]),
              withQvbrQualityLevel(qvbrQualityLevel): { codecSettings+: { h264Settings+: { qvbrQualityLevel: qvbrQualityLevel } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { h264Settings+: { rateControlMode: rateControlMode } } },
              '#withScanType':: d.fn(help='"Sets the scan type of the output."', args=[d.arg(name='scanType', type=d.T.string)]),
              withScanType(scanType): { codecSettings+: { h264Settings+: { scanType: scanType } } },
              '#withSceneChangeDetect':: d.fn(help='"Scene change detection."', args=[d.arg(name='sceneChangeDetect', type=d.T.string)]),
              withSceneChangeDetect(sceneChangeDetect): { codecSettings+: { h264Settings+: { sceneChangeDetect: sceneChangeDetect } } },
              '#withSlices':: d.fn(help='"Number of slices per picture."', args=[d.arg(name='slices', type=d.T.number)]),
              withSlices(slices): { codecSettings+: { h264Settings+: { slices: slices } } },
              '#withSoftness':: d.fn(help='"Softness."', args=[d.arg(name='softness', type=d.T.number)]),
              withSoftness(softness): { codecSettings+: { h264Settings+: { softness: softness } } },
              '#withSpatialAq':: d.fn(help='"Makes adjustments within each frame based on spatial variation of content complexity."', args=[d.arg(name='spatialAq', type=d.T.string)]),
              withSpatialAq(spatialAq): { codecSettings+: { h264Settings+: { spatialAq: spatialAq } } },
              '#withSubgopLength':: d.fn(help='"Subgop length."', args=[d.arg(name='subgopLength', type=d.T.string)]),
              withSubgopLength(subgopLength): { codecSettings+: { h264Settings+: { subgopLength: subgopLength } } },
              '#withSyntax':: d.fn(help='"Produces a bitstream compliant with SMPTE RP-2027."', args=[d.arg(name='syntax', type=d.T.string)]),
              withSyntax(syntax): { codecSettings+: { h264Settings+: { syntax: syntax } } },
              '#withTemporalAq':: d.fn(help='"Makes adjustments within each frame based on temporal variation of content complexity."', args=[d.arg(name='temporalAq', type=d.T.string)]),
              withTemporalAq(temporalAq): { codecSettings+: { h264Settings+: { temporalAq: temporalAq } } },
              '#withTimecodeInsertion':: d.fn(help='"Determines how timecodes should be inserted into the video elementary stream."', args=[d.arg(name='timecodeInsertion', type=d.T.string)]),
              withTimecodeInsertion(timecodeInsertion): { codecSettings+: { h264Settings+: { timecodeInsertion: timecodeInsertion } } },
            },
            '#h265Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            h265Settings: {
              '#colorSpaceSettings':: d.obj(help='"Define the color metadata for the output. H265 Color Space Settings for more details."'),
              colorSpaceSettings: {
                '#hdr10Settings':: d.obj(help='"Set the colorspace to be HDR10. See H265 HDR10 Settings for more details."'),
                hdr10Settings: {
                  '#withMaxCll':: d.fn(help='"Sets the MaxCLL value for HDR10."', args=[d.arg(name='maxCll', type=d.T.number)]),
                  withMaxCll(maxCll): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { hdr10Settings+: { maxCll: maxCll } } } } },
                  '#withMaxFall':: d.fn(help='"Sets the MaxFALL value for HDR10."', args=[d.arg(name='maxFall', type=d.T.number)]),
                  withMaxFall(maxFall): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { hdr10Settings+: { maxFall: maxFall } } } } },
                },
                '#withColorSpacePassthroughSettings':: d.fn(help='"Sets the colorspace metadata to be passed through."', args=[d.arg(name='colorSpacePassthroughSettings', type=d.T.object)]),
                withColorSpacePassthroughSettings(colorSpacePassthroughSettings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { colorSpacePassthroughSettings: colorSpacePassthroughSettings } } } },
                '#withColorSpacePassthroughSettingsMixin':: d.fn(help='"Sets the colorspace metadata to be passed through."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='colorSpacePassthroughSettings', type=d.T.object)]),
                withColorSpacePassthroughSettingsMixin(colorSpacePassthroughSettings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { colorSpacePassthroughSettings+: colorSpacePassthroughSettings } } } },
                '#withDolbyVision81Settings':: d.fn(help='"Set the colorspace to Dolby Vision81."', args=[d.arg(name='dolbyVision81Settings', type=d.T.object)]),
                withDolbyVision81Settings(dolbyVision81Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { dolbyVision81Settings: dolbyVision81Settings } } } },
                '#withDolbyVision81SettingsMixin':: d.fn(help='"Set the colorspace to Dolby Vision81."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dolbyVision81Settings', type=d.T.object)]),
                withDolbyVision81SettingsMixin(dolbyVision81Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { dolbyVision81Settings+: dolbyVision81Settings } } } },
                '#withRec601Settings':: d.fn(help='"Set the colorspace to Rec. 601."', args=[d.arg(name='rec601Settings', type=d.T.object)]),
                withRec601Settings(rec601Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec601Settings: rec601Settings } } } },
                '#withRec601SettingsMixin':: d.fn(help='"Set the colorspace to Rec. 601."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rec601Settings', type=d.T.object)]),
                withRec601SettingsMixin(rec601Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec601Settings+: rec601Settings } } } },
                '#withRec709Settings':: d.fn(help='"Set the colorspace to Rec. 709."', args=[d.arg(name='rec709Settings', type=d.T.object)]),
                withRec709Settings(rec709Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec709Settings: rec709Settings } } } },
                '#withRec709SettingsMixin':: d.fn(help='"Set the colorspace to Rec. 709."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rec709Settings', type=d.T.object)]),
                withRec709SettingsMixin(rec709Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec709Settings+: rec709Settings } } } },
              },
              '#filterSettings':: d.obj(help='"Filters to apply to an encode. See H264 Filter Settings for more details."'),
              filterSettings: {
                '#temporalFilterSettings':: d.obj(help='"Temporal filter settings. See Temporal Filter Settings"'),
                temporalFilterSettings: {
                  '#withPostFilterSharpening':: d.fn(help='"Post filter sharpening."', args=[d.arg(name='postFilterSharpening', type=d.T.string)]),
                  withPostFilterSharpening(postFilterSharpening): { codecSettings+: { h265Settings+: { filterSettings+: { temporalFilterSettings+: { postFilterSharpening: postFilterSharpening } } } } },
                  '#withStrength':: d.fn(help='"Filter strength."', args=[d.arg(name='strength', type=d.T.string)]),
                  withStrength(strength): { codecSettings+: { h265Settings+: { filterSettings+: { temporalFilterSettings+: { strength: strength } } } } },
                },
              },
              '#timecodeBurninSettings':: d.obj(help='"Apply a burned in timecode. See H265 Timecode Burnin Settings for more details."'),
              timecodeBurninSettings: {
                '#withPrefix':: d.fn(help='"Set a prefix on the burned in timecode."', args=[d.arg(name='prefix', type=d.T.string)]),
                withPrefix(prefix): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { prefix: prefix } } } },
                '#withTimecodeBurninFontSize':: d.fn(help='"Sets the size of the burned in timecode."', args=[d.arg(name='timecodeBurninFontSize', type=d.T.string)]),
                withTimecodeBurninFontSize(timecodeBurninFontSize): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { timecodeBurninFontSize: timecodeBurninFontSize } } } },
                '#withTimecodeBurninPosition':: d.fn(help='"Sets the position of the burned in timecode."', args=[d.arg(name='timecodeBurninPosition', type=d.T.string)]),
                withTimecodeBurninPosition(timecodeBurninPosition): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { timecodeBurninPosition: timecodeBurninPosition } } } },
              },
              '#withAdaptiveQuantization':: d.fn(help='"Enables or disables adaptive quantization."', args=[d.arg(name='adaptiveQuantization', type=d.T.string)]),
              withAdaptiveQuantization(adaptiveQuantization): { codecSettings+: { h265Settings+: { adaptiveQuantization: adaptiveQuantization } } },
              '#withAfdSignaling':: d.fn(help='"Indicates that AFD values will be written into the output stream."', args=[d.arg(name='afdSignaling', type=d.T.string)]),
              withAfdSignaling(afdSignaling): { codecSettings+: { h265Settings+: { afdSignaling: afdSignaling } } },
              '#withAlternativeTransferFunction':: d.fn(help='"Whether or not EML should insert an Alternative Transfer Function SEI message."', args=[d.arg(name='alternativeTransferFunction', type=d.T.string)]),
              withAlternativeTransferFunction(alternativeTransferFunction): { codecSettings+: { h265Settings+: { alternativeTransferFunction: alternativeTransferFunction } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { h265Settings+: { bitrate: bitrate } } },
              '#withBufSize':: d.fn(help='"Size of buffer in bits."', args=[d.arg(name='bufSize', type=d.T.number)]),
              withBufSize(bufSize): { codecSettings+: { h265Settings+: { bufSize: bufSize } } },
              '#withColorMetadata':: d.fn(help='"Includes color space metadata in the output."', args=[d.arg(name='colorMetadata', type=d.T.string)]),
              withColorMetadata(colorMetadata): { codecSettings+: { h265Settings+: { colorMetadata: colorMetadata } } },
              '#withFixedAfd':: d.fn(help='"Four bit AFD value to write on all frames of video in the output stream."', args=[d.arg(name='fixedAfd', type=d.T.string)]),
              withFixedAfd(fixedAfd): { codecSettings+: { h265Settings+: { fixedAfd: fixedAfd } } },
              '#withFlickerAq':: d.fn(help='', args=[d.arg(name='flickerAq', type=d.T.string)]),
              withFlickerAq(flickerAq): { codecSettings+: { h265Settings+: { flickerAq: flickerAq } } },
              '#withFramerateDenominator':: d.fn(help='"Framerate denominator."', args=[d.arg(name='framerateDenominator', type=d.T.number)]),
              withFramerateDenominator(framerateDenominator): { codecSettings+: { h265Settings+: { framerateDenominator: framerateDenominator } } },
              '#withFramerateNumerator':: d.fn(help='"Framerate numerator."', args=[d.arg(name='framerateNumerator', type=d.T.number)]),
              withFramerateNumerator(framerateNumerator): { codecSettings+: { h265Settings+: { framerateNumerator: framerateNumerator } } },
              '#withGopClosedCadence':: d.fn(help='"Frequency of closed GOPs."', args=[d.arg(name='gopClosedCadence', type=d.T.number)]),
              withGopClosedCadence(gopClosedCadence): { codecSettings+: { h265Settings+: { gopClosedCadence: gopClosedCadence } } },
              '#withGopSize':: d.fn(help='"GOP size in units of either frames of seconds per gop_size_units."', args=[d.arg(name='gopSize', type=d.T.number)]),
              withGopSize(gopSize): { codecSettings+: { h265Settings+: { gopSize: gopSize } } },
              '#withGopSizeUnits':: d.fn(help='"Indicates if the gop_size is specified in frames or seconds."', args=[d.arg(name='gopSizeUnits', type=d.T.string)]),
              withGopSizeUnits(gopSizeUnits): { codecSettings+: { h265Settings+: { gopSizeUnits: gopSizeUnits } } },
              '#withLevel':: d.fn(help='"H264 level."', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { codecSettings+: { h265Settings+: { level: level } } },
              '#withLookAheadRateControl':: d.fn(help='"Amount of lookahead."', args=[d.arg(name='lookAheadRateControl', type=d.T.string)]),
              withLookAheadRateControl(lookAheadRateControl): { codecSettings+: { h265Settings+: { lookAheadRateControl: lookAheadRateControl } } },
              '#withMaxBitrate':: d.fn(help='"Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video."', args=[d.arg(name='maxBitrate', type=d.T.number)]),
              withMaxBitrate(maxBitrate): { codecSettings+: { h265Settings+: { maxBitrate: maxBitrate } } },
              '#withMinIInterval':: d.fn(help='"Min interval."', args=[d.arg(name='minIInterval', type=d.T.number)]),
              withMinIInterval(minIInterval): { codecSettings+: { h265Settings+: { minIInterval: minIInterval } } },
              '#withMinQp':: d.fn(help='"Set the minimum QP."', args=[d.arg(name='minQp', type=d.T.number)]),
              withMinQp(minQp): { codecSettings+: { h265Settings+: { minQp: minQp } } },
              '#withMvOverPictureBoundaries':: d.fn(help='"Enables or disables motion vector over picture boundaries."', args=[d.arg(name='mvOverPictureBoundaries', type=d.T.string)]),
              withMvOverPictureBoundaries(mvOverPictureBoundaries): { codecSettings+: { h265Settings+: { mvOverPictureBoundaries: mvOverPictureBoundaries } } },
              '#withMvTemporalPredictor':: d.fn(help='"Enables or disables the motion vector temporal predictor."', args=[d.arg(name='mvTemporalPredictor', type=d.T.string)]),
              withMvTemporalPredictor(mvTemporalPredictor): { codecSettings+: { h265Settings+: { mvTemporalPredictor: mvTemporalPredictor } } },
              '#withParDenominator':: d.fn(help='"Pixel Aspect Ratio denominator."', args=[d.arg(name='parDenominator', type=d.T.number)]),
              withParDenominator(parDenominator): { codecSettings+: { h265Settings+: { parDenominator: parDenominator } } },
              '#withParNumerator':: d.fn(help='"Pixel Aspect Ratio numerator."', args=[d.arg(name='parNumerator', type=d.T.number)]),
              withParNumerator(parNumerator): { codecSettings+: { h265Settings+: { parNumerator: parNumerator } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { h265Settings+: { profile: profile } } },
              '#withQvbrQualityLevel':: d.fn(help='"Controls the target quality for the video encode."', args=[d.arg(name='qvbrQualityLevel', type=d.T.number)]),
              withQvbrQualityLevel(qvbrQualityLevel): { codecSettings+: { h265Settings+: { qvbrQualityLevel: qvbrQualityLevel } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { h265Settings+: { rateControlMode: rateControlMode } } },
              '#withScanType':: d.fn(help='"Sets the scan type of the output."', args=[d.arg(name='scanType', type=d.T.string)]),
              withScanType(scanType): { codecSettings+: { h265Settings+: { scanType: scanType } } },
              '#withSceneChangeDetect':: d.fn(help='"Scene change detection."', args=[d.arg(name='sceneChangeDetect', type=d.T.string)]),
              withSceneChangeDetect(sceneChangeDetect): { codecSettings+: { h265Settings+: { sceneChangeDetect: sceneChangeDetect } } },
              '#withSlices':: d.fn(help='"Number of slices per picture."', args=[d.arg(name='slices', type=d.T.number)]),
              withSlices(slices): { codecSettings+: { h265Settings+: { slices: slices } } },
              '#withTier':: d.fn(help='"Set the H265 tier in the output."', args=[d.arg(name='tier', type=d.T.string)]),
              withTier(tier): { codecSettings+: { h265Settings+: { tier: tier } } },
              '#withTileHeight':: d.fn(help='"Sets the height of tiles."', args=[d.arg(name='tileHeight', type=d.T.number)]),
              withTileHeight(tileHeight): { codecSettings+: { h265Settings+: { tileHeight: tileHeight } } },
              '#withTilePadding':: d.fn(help='"Enables or disables padding of tiles."', args=[d.arg(name='tilePadding', type=d.T.string)]),
              withTilePadding(tilePadding): { codecSettings+: { h265Settings+: { tilePadding: tilePadding } } },
              '#withTileWidth':: d.fn(help='"Sets the width of tiles."', args=[d.arg(name='tileWidth', type=d.T.number)]),
              withTileWidth(tileWidth): { codecSettings+: { h265Settings+: { tileWidth: tileWidth } } },
              '#withTimecodeInsertion':: d.fn(help='"Determines how timecodes should be inserted into the video elementary stream."', args=[d.arg(name='timecodeInsertion', type=d.T.string)]),
              withTimecodeInsertion(timecodeInsertion): { codecSettings+: { h265Settings+: { timecodeInsertion: timecodeInsertion } } },
              '#withTreeblockSize':: d.fn(help='"Sets the size of the treeblock."', args=[d.arg(name='treeblockSize', type=d.T.string)]),
              withTreeblockSize(treeblockSize): { codecSettings+: { h265Settings+: { treeblockSize: treeblockSize } } },
            },
          },
          '#withHeight':: d.fn(help='"See the description in left_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, \\"80\\" means the rectangle height is 80% of the underlying frame height. The top_offset and rectangle_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard."', args=[d.arg(name='height', type=d.T.number)]),
          withHeight(height): { height: height },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withRespondToAfd':: d.fn(help='"Indicate how to respond to the AFD values that might be in the input video."', args=[d.arg(name='respondToAfd', type=d.T.string)]),
          withRespondToAfd(respondToAfd): { respondToAfd: respondToAfd },
          '#withScalingBehavior':: d.fn(help='"Behavior on how to scale."', args=[d.arg(name='scalingBehavior', type=d.T.string)]),
          withScalingBehavior(scalingBehavior): { scalingBehavior: scalingBehavior },
          '#withSharpness':: d.fn(help='"Changes the strength of the anti-alias filter used for scaling."', args=[d.arg(name='sharpness', type=d.T.number)]),
          withSharpness(sharpness): { sharpness: sharpness },
          '#withWidth':: d.fn(help='"See the description in left_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, \\"80\\" means the rectangle width is 80% of the underlying frame width. The left_offset and rectangle_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard."', args=[d.arg(name='width', type=d.T.number)]),
          withWidth(width): { width: width },
        },
        '#withAudioDescriptions':: d.fn(help='"Audio descriptions for the channel. See Audio Descriptions for more details."', args=[d.arg(name='audioDescriptions', type=d.T.array)]),
        withAudioDescriptions(audioDescriptions): { spec+: { forProvider+: { encoderSettings+: { audioDescriptions: if std.isArray(v=audioDescriptions) then audioDescriptions else [audioDescriptions] } } } },
        '#withAudioDescriptionsMixin':: d.fn(help='"Audio descriptions for the channel. See Audio Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioDescriptions', type=d.T.array)]),
        withAudioDescriptionsMixin(audioDescriptions): { spec+: { forProvider+: { encoderSettings+: { audioDescriptions+: if std.isArray(v=audioDescriptions) then audioDescriptions else [audioDescriptions] } } } },
        '#withCaptionDescriptions':: d.fn(help='"Caption Descriptions. See Caption Descriptions for more details."', args=[d.arg(name='captionDescriptions', type=d.T.array)]),
        withCaptionDescriptions(captionDescriptions): { spec+: { forProvider+: { encoderSettings+: { captionDescriptions: if std.isArray(v=captionDescriptions) then captionDescriptions else [captionDescriptions] } } } },
        '#withCaptionDescriptionsMixin':: d.fn(help='"Caption Descriptions. See Caption Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionDescriptions', type=d.T.array)]),
        withCaptionDescriptionsMixin(captionDescriptions): { spec+: { forProvider+: { encoderSettings+: { captionDescriptions+: if std.isArray(v=captionDescriptions) then captionDescriptions else [captionDescriptions] } } } },
        '#withOutputGroups':: d.fn(help='"Output groups for the channel. See Output Groups for more details."', args=[d.arg(name='outputGroups', type=d.T.array)]),
        withOutputGroups(outputGroups): { spec+: { forProvider+: { encoderSettings+: { outputGroups: if std.isArray(v=outputGroups) then outputGroups else [outputGroups] } } } },
        '#withOutputGroupsMixin':: d.fn(help='"Output groups for the channel. See Output Groups for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='outputGroups', type=d.T.array)]),
        withOutputGroupsMixin(outputGroups): { spec+: { forProvider+: { encoderSettings+: { outputGroups+: if std.isArray(v=outputGroups) then outputGroups else [outputGroups] } } } },
        '#withVideoDescriptions':: d.fn(help='"Video Descriptions. See Video Descriptions for more details."', args=[d.arg(name='videoDescriptions', type=d.T.array)]),
        withVideoDescriptions(videoDescriptions): { spec+: { forProvider+: { encoderSettings+: { videoDescriptions: if std.isArray(v=videoDescriptions) then videoDescriptions else [videoDescriptions] } } } },
        '#withVideoDescriptionsMixin':: d.fn(help='"Video Descriptions. See Video Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='videoDescriptions', type=d.T.array)]),
        withVideoDescriptionsMixin(videoDescriptions): { spec+: { forProvider+: { encoderSettings+: { videoDescriptions+: if std.isArray(v=videoDescriptions) then videoDescriptions else [videoDescriptions] } } } },
      },
      '#inputAttachments':: d.obj(help='"Input attachments for the channel. See Input Attachments for more details."'),
      inputAttachments: {
        '#automaticInputFailoverSettings':: d.obj(help='"User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details."'),
        automaticInputFailoverSettings: {
          '#failoverCondition':: d.obj(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."'),
          failoverCondition: {
            '#failoverConditionSettings':: d.obj(help='"Failover condition type-specific settings. See Failover Condition Settings for more details."'),
            failoverConditionSettings: {
              '#audioSilenceSettings':: d.obj(help='"MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details."'),
              audioSilenceSettings: {
                '#withAudioSelectorName':: d.fn(help="\"The name of the audio selector in the input that MediaLive should monitor to detect silence. Select your most important rendition. If you didn't create an audio selector in this input, leave blank.\"", args=[d.arg(name='audioSelectorName', type=d.T.string)]),
                withAudioSelectorName(audioSelectorName): { failoverConditionSettings+: { audioSilenceSettings+: { audioSelectorName: audioSelectorName } } },
                '#withAudioSilenceThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS."', args=[d.arg(name='audioSilenceThresholdMsec', type=d.T.number)]),
                withAudioSilenceThresholdMsec(audioSilenceThresholdMsec): { failoverConditionSettings+: { audioSilenceSettings+: { audioSilenceThresholdMsec: audioSilenceThresholdMsec } } },
              },
              '#inputLossSettings':: d.obj(help='"MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details."'),
              inputLossSettings: {
                '#withInputLossThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur."', args=[d.arg(name='inputLossThresholdMsec', type=d.T.number)]),
                withInputLossThresholdMsec(inputLossThresholdMsec): { failoverConditionSettings+: { inputLossSettings+: { inputLossThresholdMsec: inputLossThresholdMsec } } },
              },
              '#videoBlackSettings':: d.obj(help='"MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details."'),
              videoBlackSettings: {
                '#withBlackDetectThreshold':: d.fn(help="\"A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.\"", args=[d.arg(name='blackDetectThreshold', type=d.T.number)]),
                withBlackDetectThreshold(blackDetectThreshold): { failoverConditionSettings+: { videoBlackSettings+: { blackDetectThreshold: blackDetectThreshold } } },
                '#withVideoBlackThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs."', args=[d.arg(name='videoBlackThresholdMsec', type=d.T.number)]),
                withVideoBlackThresholdMsec(videoBlackThresholdMsec): { failoverConditionSettings+: { videoBlackSettings+: { videoBlackThresholdMsec: videoBlackThresholdMsec } } },
              },
            },
          },
          '#withErrorClearTimeMsec':: d.fn(help='"This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input_preference for the failover pair is set to PRIMARY_INPUT_PREFERRED, because after this time, MediaLive will switch back to the primary input."', args=[d.arg(name='errorClearTimeMsec', type=d.T.number)]),
          withErrorClearTimeMsec(errorClearTimeMsec): { automaticInputFailoverSettings+: { errorClearTimeMsec: errorClearTimeMsec } },
          '#withFailoverCondition':: d.fn(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."', args=[d.arg(name='failoverCondition', type=d.T.array)]),
          withFailoverCondition(failoverCondition): { automaticInputFailoverSettings+: { failoverCondition: if std.isArray(v=failoverCondition) then failoverCondition else [failoverCondition] } },
          '#withFailoverConditionMixin':: d.fn(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='failoverCondition', type=d.T.array)]),
          withFailoverConditionMixin(failoverCondition): { automaticInputFailoverSettings+: { failoverCondition+: if std.isArray(v=failoverCondition) then failoverCondition else [failoverCondition] } },
          '#withInputPreference':: d.fn(help='"Input preference when deciding which input to make active when a previously failed input has recovered."', args=[d.arg(name='inputPreference', type=d.T.string)]),
          withInputPreference(inputPreference): { automaticInputFailoverSettings+: { inputPreference: inputPreference } },
          '#withSecondaryInputId':: d.fn(help='"The input ID of the secondary input in the automatic input failover pair."', args=[d.arg(name='secondaryInputId', type=d.T.string)]),
          withSecondaryInputId(secondaryInputId): { automaticInputFailoverSettings+: { secondaryInputId: secondaryInputId } },
        },
        '#inputIdRef':: d.obj(help='"Reference to a Input in medialive to populate inputId."'),
        inputIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { inputIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { inputIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { inputIdRef+: { name: name } },
        },
        '#inputIdSelector':: d.obj(help='"Selector for a Input in medialive to populate inputId."'),
        inputIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { inputIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { inputIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { inputIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { inputIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { inputIdSelector+: { matchLabels+: matchLabels } },
        },
        '#inputSettings':: d.obj(help='"Settings of an input. See Input Settings for more details."'),
        inputSettings: {
          '#audioSelector':: d.obj(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."'),
          audioSelector: {
            '#selectorSettings':: d.obj(help='"The audio selector settings. See Audio Selector Settings for more details."'),
            selectorSettings: {
              '#audioHlsRenditionSelection':: d.obj(help='"Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details."'),
              audioHlsRenditionSelection: {
                '#withGroupId':: d.fn(help='"Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition."', args=[d.arg(name='groupId', type=d.T.string)]),
                withGroupId(groupId): { selectorSettings+: { audioHlsRenditionSelection+: { groupId: groupId } } },
                '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { selectorSettings+: { audioHlsRenditionSelection+: { name: name } } },
              },
              '#audioLanguageSelection':: d.obj(help='"Audio Language Selection. See Audio Language Selection for more details."'),
              audioLanguageSelection: {
                '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
                withLanguageCode(languageCode): { selectorSettings+: { audioLanguageSelection+: { languageCode: languageCode } } },
                '#withLanguageSelectionPolicy':: d.fn(help='"When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language."', args=[d.arg(name='languageSelectionPolicy', type=d.T.string)]),
                withLanguageSelectionPolicy(languageSelectionPolicy): { selectorSettings+: { audioLanguageSelection+: { languageSelectionPolicy: languageSelectionPolicy } } },
              },
              '#audioPidSelection':: d.obj(help='"Audio Pid Selection. See Audio PID Selection for more details."'),
              audioPidSelection: {
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { audioPidSelection+: { pid: pid } } },
              },
              '#audioTrackSelection':: d.obj(help='"Audio Track Selection. See Audio Track Selection for more details."'),
              audioTrackSelection: {
                '#dolbyEDecode':: d.obj(help='"Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details."'),
                dolbyEDecode: {
                  '#withProgramSelection':: d.fn(help='"Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect."', args=[d.arg(name='programSelection', type=d.T.string)]),
                  withProgramSelection(programSelection): { selectorSettings+: { audioTrackSelection+: { dolbyEDecode+: { programSelection: programSelection } } } },
                },
                '#tracks':: d.obj(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."'),
                tracks: {
                  '#withTrack':: d.fn(help='"1-based integer value that maps to a specific audio track."', args=[d.arg(name='track', type=d.T.number)]),
                  withTrack(track): { track: track },
                },
                '#withTracks':: d.fn(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."', args=[d.arg(name='tracks', type=d.T.array)]),
                withTracks(tracks): { selectorSettings+: { audioTrackSelection+: { tracks: if std.isArray(v=tracks) then tracks else [tracks] } } },
                '#withTracksMixin':: d.fn(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tracks', type=d.T.array)]),
                withTracksMixin(tracks): { selectorSettings+: { audioTrackSelection+: { tracks+: if std.isArray(v=tracks) then tracks else [tracks] } } },
              },
            },
            '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#captionSelector':: d.obj(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."'),
          captionSelector: {
            '#selectorSettings':: d.obj(help='"The audio selector settings. See Audio Selector Settings for more details."'),
            selectorSettings: {
              '#ancillarySourceSettings':: d.obj(help='"Ancillary Source Settings. See Ancillary Source Settings for more details."'),
              ancillarySourceSettings: {
                '#withSourceAncillaryChannelNumber':: d.fn(help='"Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field."', args=[d.arg(name='sourceAncillaryChannelNumber', type=d.T.number)]),
                withSourceAncillaryChannelNumber(sourceAncillaryChannelNumber): { selectorSettings+: { ancillarySourceSettings+: { sourceAncillaryChannelNumber: sourceAncillaryChannelNumber } } },
              },
              '#dvbSubSourceSettings':: d.obj(help='"DVB Sub Source Settings. See DVB Sub Source Settings for more details."'),
              dvbSubSourceSettings: {
                '#withOcrLanguage':: d.fn(help='"If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text."', args=[d.arg(name='ocrLanguage', type=d.T.string)]),
                withOcrLanguage(ocrLanguage): { selectorSettings+: { dvbSubSourceSettings+: { ocrLanguage: ocrLanguage } } },
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { dvbSubSourceSettings+: { pid: pid } } },
              },
              '#embeddedSourceSettings':: d.obj(help='"Embedded Source Settings. See Embedded Source Settings for more details."'),
              embeddedSourceSettings: {
                '#withConvert608To708':: d.fn(help='"If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded."', args=[d.arg(name='convert608To708', type=d.T.string)]),
                withConvert608To708(convert608To708): { selectorSettings+: { embeddedSourceSettings+: { convert608To708: convert608To708 } } },
                '#withScte20Detection':: d.fn(help='"Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions."', args=[d.arg(name='scte20Detection', type=d.T.string)]),
                withScte20Detection(scte20Detection): { selectorSettings+: { embeddedSourceSettings+: { scte20Detection: scte20Detection } } },
                '#withSource608ChannelNumber':: d.fn(help='"Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough."', args=[d.arg(name='source608ChannelNumber', type=d.T.number)]),
                withSource608ChannelNumber(source608ChannelNumber): { selectorSettings+: { embeddedSourceSettings+: { source608ChannelNumber: source608ChannelNumber } } },
              },
              '#scte20SourceSettings':: d.obj(help='"SCTE20 Source Settings. See SCTE 20 Source Settings for more details."'),
              scte20SourceSettings: {
                '#withConvert608To708':: d.fn(help='"If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded."', args=[d.arg(name='convert608To708', type=d.T.string)]),
                withConvert608To708(convert608To708): { selectorSettings+: { scte20SourceSettings+: { convert608To708: convert608To708 } } },
                '#withSource608ChannelNumber':: d.fn(help='"Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough."', args=[d.arg(name='source608ChannelNumber', type=d.T.number)]),
                withSource608ChannelNumber(source608ChannelNumber): { selectorSettings+: { scte20SourceSettings+: { source608ChannelNumber: source608ChannelNumber } } },
              },
              '#scte27SourceSettings':: d.obj(help='"SCTE27 Source Settings. See SCTE 27 Source Settings for more details."'),
              scte27SourceSettings: {
                '#withOcrLanguage':: d.fn(help='"If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text."', args=[d.arg(name='ocrLanguage', type=d.T.string)]),
                withOcrLanguage(ocrLanguage): { selectorSettings+: { scte27SourceSettings+: { ocrLanguage: ocrLanguage } } },
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { scte27SourceSettings+: { pid: pid } } },
              },
              '#teletextSourceSettings':: d.obj(help='"Teletext Source Settings. See Teletext Source Settings for more details."'),
              teletextSourceSettings: {
                '#outputRectangle':: d.obj(help='"Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details."'),
                outputRectangle: {
                  '#withHeight':: d.fn(help='"See the description in left_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, \\"80\\" means the rectangle height is 80% of the underlying frame height. The top_offset and rectangle_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard."', args=[d.arg(name='height', type=d.T.number)]),
                  withHeight(height): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { height: height } } } },
                  '#withLeftOffset':: d.fn(help='"Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you don’t have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, \\"10\\" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard."', args=[d.arg(name='leftOffset', type=d.T.number)]),
                  withLeftOffset(leftOffset): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { leftOffset: leftOffset } } } },
                  '#withTopOffset':: d.fn(help='"See the description in left_offset. For top_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, \\"10\\" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard."', args=[d.arg(name='topOffset', type=d.T.number)]),
                  withTopOffset(topOffset): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { topOffset: topOffset } } } },
                  '#withWidth':: d.fn(help='"See the description in left_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, \\"80\\" means the rectangle width is 80% of the underlying frame width. The left_offset and rectangle_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard."', args=[d.arg(name='width', type=d.T.number)]),
                  withWidth(width): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { width: width } } } },
                },
                '#withPageNumber':: d.fn(help='"Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix."', args=[d.arg(name='pageNumber', type=d.T.string)]),
                withPageNumber(pageNumber): { selectorSettings+: { teletextSourceSettings+: { pageNumber: pageNumber } } },
              },
              '#withAribSourceSettings':: d.fn(help='"ARIB Source Settings."', args=[d.arg(name='aribSourceSettings', type=d.T.object)]),
              withAribSourceSettings(aribSourceSettings): { selectorSettings+: { aribSourceSettings: aribSourceSettings } },
              '#withAribSourceSettingsMixin':: d.fn(help='"ARIB Source Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aribSourceSettings', type=d.T.object)]),
              withAribSourceSettingsMixin(aribSourceSettings): { selectorSettings+: { aribSourceSettings+: aribSourceSettings } },
            },
            '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
            withLanguageCode(languageCode): { languageCode: languageCode },
            '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#networkInputSettings':: d.obj(help='"Input settings. See Network Input Settings for more details."'),
          networkInputSettings: {
            '#hlsInputSettings':: d.obj(help='"Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details."'),
            hlsInputSettings: {
              '#withBandwidth':: d.fn(help='"The bitrate is specified in bits per second, as in an HLS manifest."', args=[d.arg(name='bandwidth', type=d.T.number)]),
              withBandwidth(bandwidth): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { bandwidth: bandwidth } } } },
              '#withBufferSegments':: d.fn(help='"Buffer segments."', args=[d.arg(name='bufferSegments', type=d.T.number)]),
              withBufferSegments(bufferSegments): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { bufferSegments: bufferSegments } } } },
              '#withRetries':: d.fn(help='"The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable."', args=[d.arg(name='retries', type=d.T.number)]),
              withRetries(retries): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { retries: retries } } } },
              '#withRetryInterval':: d.fn(help='"The number of seconds between retries when an attempt to read a manifest or segment fails."', args=[d.arg(name='retryInterval', type=d.T.number)]),
              withRetryInterval(retryInterval): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { retryInterval: retryInterval } } } },
              '#withScte35Source':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='scte35Source', type=d.T.string)]),
              withScte35Source(scte35Source): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { scte35Source: scte35Source } } } },
            },
            '#withServerValidation':: d.fn(help='"Check HTTPS server certificates."', args=[d.arg(name='serverValidation', type=d.T.string)]),
            withServerValidation(serverValidation): { inputSettings+: { networkInputSettings+: { serverValidation: serverValidation } } },
          },
          '#videoSelector':: d.obj(help=''),
          videoSelector: {
            '#withColorSpace':: d.fn(help='', args=[d.arg(name='colorSpace', type=d.T.string)]),
            withColorSpace(colorSpace): { inputSettings+: { videoSelector+: { colorSpace: colorSpace } } },
            '#withColorSpaceUsage':: d.fn(help='', args=[d.arg(name='colorSpaceUsage', type=d.T.string)]),
            withColorSpaceUsage(colorSpaceUsage): { inputSettings+: { videoSelector+: { colorSpaceUsage: colorSpaceUsage } } },
          },
          '#withAudioSelector':: d.fn(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."', args=[d.arg(name='audioSelector', type=d.T.array)]),
          withAudioSelector(audioSelector): { inputSettings+: { audioSelector: if std.isArray(v=audioSelector) then audioSelector else [audioSelector] } },
          '#withAudioSelectorMixin':: d.fn(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioSelector', type=d.T.array)]),
          withAudioSelectorMixin(audioSelector): { inputSettings+: { audioSelector+: if std.isArray(v=audioSelector) then audioSelector else [audioSelector] } },
          '#withCaptionSelector':: d.fn(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."', args=[d.arg(name='captionSelector', type=d.T.array)]),
          withCaptionSelector(captionSelector): { inputSettings+: { captionSelector: if std.isArray(v=captionSelector) then captionSelector else [captionSelector] } },
          '#withCaptionSelectorMixin':: d.fn(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionSelector', type=d.T.array)]),
          withCaptionSelectorMixin(captionSelector): { inputSettings+: { captionSelector+: if std.isArray(v=captionSelector) then captionSelector else [captionSelector] } },
          '#withDeblockFilter':: d.fn(help='"Enable or disable the deblock filter when filtering."', args=[d.arg(name='deblockFilter', type=d.T.string)]),
          withDeblockFilter(deblockFilter): { inputSettings+: { deblockFilter: deblockFilter } },
          '#withDenoiseFilter':: d.fn(help='"Enable or disable the denoise filter when filtering."', args=[d.arg(name='denoiseFilter', type=d.T.string)]),
          withDenoiseFilter(denoiseFilter): { inputSettings+: { denoiseFilter: denoiseFilter } },
          '#withFilterStrength':: d.fn(help='"Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest)."', args=[d.arg(name='filterStrength', type=d.T.number)]),
          withFilterStrength(filterStrength): { inputSettings+: { filterStrength: filterStrength } },
          '#withInputFilter':: d.fn(help='"Turns on the filter for the input."', args=[d.arg(name='inputFilter', type=d.T.string)]),
          withInputFilter(inputFilter): { inputSettings+: { inputFilter: inputFilter } },
          '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.number)]),
          withScte35Pid(scte35Pid): { inputSettings+: { scte35Pid: scte35Pid } },
          '#withSmpte2038DataPreference':: d.fn(help='"Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input."', args=[d.arg(name='smpte2038DataPreference', type=d.T.string)]),
          withSmpte2038DataPreference(smpte2038DataPreference): { inputSettings+: { smpte2038DataPreference: smpte2038DataPreference } },
          '#withSourceEndBehavior':: d.fn(help='"Loop input if it is a file."', args=[d.arg(name='sourceEndBehavior', type=d.T.string)]),
          withSourceEndBehavior(sourceEndBehavior): { inputSettings+: { sourceEndBehavior: sourceEndBehavior } },
        },
        '#withInputAttachmentName':: d.fn(help='"User-specified name for the attachment."', args=[d.arg(name='inputAttachmentName', type=d.T.string)]),
        withInputAttachmentName(inputAttachmentName): { inputAttachmentName: inputAttachmentName },
        '#withInputId':: d.fn(help='"The ID of the input."', args=[d.arg(name='inputId', type=d.T.string)]),
        withInputId(inputId): { inputId: inputId },
      },
      '#inputSpecification':: d.obj(help='"Specification of network and file inputs for the channel."'),
      inputSpecification: {
        '#withCodec':: d.fn(help='', args=[d.arg(name='codec', type=d.T.string)]),
        withCodec(codec): { spec+: { forProvider+: { inputSpecification+: { codec: codec } } } },
        '#withInputResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='inputResolution', type=d.T.string)]),
        withInputResolution(inputResolution): { spec+: { forProvider+: { inputSpecification+: { inputResolution: inputResolution } } } },
        '#withMaximumBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='maximumBitrate', type=d.T.string)]),
        withMaximumBitrate(maximumBitrate): { spec+: { forProvider+: { inputSpecification+: { maximumBitrate: maximumBitrate } } } },
      },
      '#maintenance':: d.obj(help='"Maintenance settings for this channel. See Maintenance for more details."'),
      maintenance: {
        '#withMaintenanceDay':: d.fn(help='"The day of the week to use for maintenance."', args=[d.arg(name='maintenanceDay', type=d.T.string)]),
        withMaintenanceDay(maintenanceDay): { spec+: { forProvider+: { maintenance+: { maintenanceDay: maintenanceDay } } } },
        '#withMaintenanceStartTime':: d.fn(help='"The hour maintenance will start."', args=[d.arg(name='maintenanceStartTime', type=d.T.string)]),
        withMaintenanceStartTime(maintenanceStartTime): { spec+: { forProvider+: { maintenance+: { maintenanceStartTime: maintenanceStartTime } } } },
      },
      '#roleArnRef':: d.obj(help='"Reference to a Role in iam to populate roleArn."'),
      roleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { roleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { roleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { roleArnRef+: { name: name } } } },
      },
      '#roleArnSelector':: d.obj(help='"Selector for a Role in iam to populate roleArn."'),
      roleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { roleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { roleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { roleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { roleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { roleArnSelector+: { matchLabels+: matchLabels } } } },
      },
      '#vpc':: d.obj(help='"Settings for the VPC outputs. See VPC for more details."'),
      vpc: {
        '#withPublicAddressAllocationIds':: d.fn(help='"List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels."', args=[d.arg(name='publicAddressAllocationIds', type=d.T.array)]),
        withPublicAddressAllocationIds(publicAddressAllocationIds): { spec+: { forProvider+: { vpc+: { publicAddressAllocationIds: if std.isArray(v=publicAddressAllocationIds) then publicAddressAllocationIds else [publicAddressAllocationIds] } } } },
        '#withPublicAddressAllocationIdsMixin':: d.fn(help='"List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='publicAddressAllocationIds', type=d.T.array)]),
        withPublicAddressAllocationIdsMixin(publicAddressAllocationIds): { spec+: { forProvider+: { vpc+: { publicAddressAllocationIds+: if std.isArray(v=publicAddressAllocationIds) then publicAddressAllocationIds else [publicAddressAllocationIds] } } } },
        '#withSecurityGroupIds':: d.fn(help='"A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used."', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
        withSecurityGroupIds(securityGroupIds): { spec+: { forProvider+: { vpc+: { securityGroupIds: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } } },
        '#withSecurityGroupIdsMixin':: d.fn(help='"A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
        withSecurityGroupIdsMixin(securityGroupIds): { spec+: { forProvider+: { vpc+: { securityGroupIds+: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } } },
        '#withSubnetIds':: d.fn(help='"A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ)."', args=[d.arg(name='subnetIds', type=d.T.array)]),
        withSubnetIds(subnetIds): { spec+: { forProvider+: { vpc+: { subnetIds: if std.isArray(v=subnetIds) then subnetIds else [subnetIds] } } } },
        '#withSubnetIdsMixin':: d.fn(help='"A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='subnetIds', type=d.T.array)]),
        withSubnetIdsMixin(subnetIds): { spec+: { forProvider+: { vpc+: { subnetIds+: if std.isArray(v=subnetIds) then subnetIds else [subnetIds] } } } },
      },
      '#withChannelClass':: d.fn(help='"Concise argument description."', args=[d.arg(name='channelClass', type=d.T.string)]),
      withChannelClass(channelClass): { spec+: { forProvider+: { channelClass: channelClass } } },
      '#withDestinations':: d.fn(help='"Destinations for channel. See Destinations for more details."', args=[d.arg(name='destinations', type=d.T.array)]),
      withDestinations(destinations): { spec+: { forProvider+: { destinations: if std.isArray(v=destinations) then destinations else [destinations] } } },
      '#withDestinationsMixin':: d.fn(help='"Destinations for channel. See Destinations for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='destinations', type=d.T.array)]),
      withDestinationsMixin(destinations): { spec+: { forProvider+: { destinations+: if std.isArray(v=destinations) then destinations else [destinations] } } },
      '#withInputAttachments':: d.fn(help='"Input attachments for the channel. See Input Attachments for more details."', args=[d.arg(name='inputAttachments', type=d.T.array)]),
      withInputAttachments(inputAttachments): { spec+: { forProvider+: { inputAttachments: if std.isArray(v=inputAttachments) then inputAttachments else [inputAttachments] } } },
      '#withInputAttachmentsMixin':: d.fn(help='"Input attachments for the channel. See Input Attachments for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inputAttachments', type=d.T.array)]),
      withInputAttachmentsMixin(inputAttachments): { spec+: { forProvider+: { inputAttachments+: if std.isArray(v=inputAttachments) then inputAttachments else [inputAttachments] } } },
      '#withLogLevel':: d.fn(help='"The log level to write to Cloudwatch logs."', args=[d.arg(name='logLevel', type=d.T.string)]),
      withLogLevel(logLevel): { spec+: { forProvider+: { logLevel: logLevel } } },
      '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { forProvider+: { name: name } } },
      '#withRegion':: d.fn(help="\"Region where this resource will be managed. Defaults to the Region set in the provider configuration.\\nRegion is the region you'd like your resource to be created in.\"", args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { spec+: { forProvider+: { region: region } } },
      '#withRoleArn':: d.fn(help='"Concise argument description."', args=[d.arg(name='roleArn', type=d.T.string)]),
      withRoleArn(roleArn): { spec+: { forProvider+: { roleArn: roleArn } } },
      '#withStartChannel':: d.fn(help='"Whether to start/stop channel. Default: false"', args=[d.arg(name='startChannel', type=d.T.boolean)]),
      withStartChannel(startChannel): { spec+: { forProvider+: { startChannel: startChannel } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { forProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: tags } } },
    },
    '#initProvider':: d.obj(help='"THIS IS A BETA FIELD. It will be honored\\nunless the Management Policies feature flag is disabled.\\nInitProvider holds the same fields as ForProvider, with the exception\\nof Identifier and other resource reference fields. The fields that are\\nin InitProvider are merged into ForProvider when the resource is created.\\nThe same fields are also added to the terraform ignore_changes hook, to\\navoid updating them after creation. This is useful for fields that are\\nrequired on creation, but we do not desire to update them after creation,\\nfor example because of an external controller is managing them, like an\\nautoscaler."'),
    initProvider: {
      '#cdiInputSpecification':: d.obj(help='"Specification of CDI inputs for this channel. See CDI Input Specification for more details."'),
      cdiInputSpecification: {
        '#withResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { initProvider+: { cdiInputSpecification+: { resolution: resolution } } } },
      },
      '#destinations':: d.obj(help='"Destinations for channel. See Destinations for more details."'),
      destinations: {
        '#mediaPackageSettings':: d.obj(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."'),
        mediaPackageSettings: {
          '#withChannelId':: d.fn(help='"ID of the channel in MediaPackage that is the destination for this output group."', args=[d.arg(name='channelId', type=d.T.string)]),
          withChannelId(channelId): { channelId: channelId },
        },
        '#multiplexSettings':: d.obj(help='"Destination settings for a Multiplex output; one destination for both encoders. See Multiplex Settings for more details."'),
        multiplexSettings: {
          '#withMultiplexId':: d.fn(help='"The ID of the Multiplex that the encoder is providing output to."', args=[d.arg(name='multiplexId', type=d.T.string)]),
          withMultiplexId(multiplexId): { multiplexSettings+: { multiplexId: multiplexId } },
          '#withProgramName':: d.fn(help='"The program name of the Multiplex program that the encoder is providing output to."', args=[d.arg(name='programName', type=d.T.string)]),
          withProgramName(programName): { multiplexSettings+: { programName: programName } },
        },
        '#settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
        settings: {
          '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
          withPasswordParam(passwordParam): { passwordParam: passwordParam },
          '#withStreamName':: d.fn(help='"Stream name RTMP destinations (URLs of type rtmp://)"', args=[d.arg(name='streamName', type=d.T.string)]),
          withStreamName(streamName): { streamName: streamName },
          '#withUrl':: d.fn(help='"A URL specifying a destination."', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
          '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { username: username },
        },
        '#withId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='id', type=d.T.string)]),
        withId(id): { id: id },
        '#withMediaPackageSettings':: d.fn(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."', args=[d.arg(name='mediaPackageSettings', type=d.T.array)]),
        withMediaPackageSettings(mediaPackageSettings): { mediaPackageSettings: if std.isArray(v=mediaPackageSettings) then mediaPackageSettings else [mediaPackageSettings] },
        '#withMediaPackageSettingsMixin':: d.fn(help='"Destination settings for a MediaPackage output; one destination for both encoders. See Media Package Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mediaPackageSettings', type=d.T.array)]),
        withMediaPackageSettingsMixin(mediaPackageSettings): { mediaPackageSettings+: if std.isArray(v=mediaPackageSettings) then mediaPackageSettings else [mediaPackageSettings] },
        '#withSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='settings', type=d.T.array)]),
        withSettings(settings): { settings: if std.isArray(v=settings) then settings else [settings] },
        '#withSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='settings', type=d.T.array)]),
        withSettingsMixin(settings): { settings+: if std.isArray(v=settings) then settings else [settings] },
      },
      '#encoderSettings':: d.obj(help='"Encoder settings. See Encoder Settings for more details."'),
      encoderSettings: {
        '#audioDescriptions':: d.obj(help='"Audio descriptions for the channel. See Audio Descriptions for more details."'),
        audioDescriptions: {
          '#audioNormalizationSettings':: d.obj(help='"Advanced audio normalization settings. See Audio Normalization Settings for more details."'),
          audioNormalizationSettings: {
            '#withAlgorithm':: d.fn(help='"Audio normalization algorithm to use. itu17701 conforms to the CALM Act specification, itu17702 to the EBU R-128 specification."', args=[d.arg(name='algorithm', type=d.T.string)]),
            withAlgorithm(algorithm): { audioNormalizationSettings+: { algorithm: algorithm } },
            '#withAlgorithmControl':: d.fn(help='"Algorithm control for the audio description."', args=[d.arg(name='algorithmControl', type=d.T.string)]),
            withAlgorithmControl(algorithmControl): { audioNormalizationSettings+: { algorithmControl: algorithmControl } },
            '#withTargetLkfs':: d.fn(help='"Target LKFS (loudness) to adjust volume to."', args=[d.arg(name='targetLkfs', type=d.T.number)]),
            withTargetLkfs(targetLkfs): { audioNormalizationSettings+: { targetLkfs: targetLkfs } },
          },
          '#audioWatermarkSettings':: d.obj(help='"Settings to configure one or more solutions that insert audio watermarks in the audio encode. See Audio Watermark Settings for more details."'),
          audioWatermarkSettings: {
            '#nielsenWatermarksSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            nielsenWatermarksSettings: {
              '#nielsenCbetSettings':: d.obj(help='"Used to insert watermarks of type Nielsen CBET. See Nielsen CBET Settings for more details."'),
              nielsenCbetSettings: {
                '#withCbetCheckDigitString':: d.fn(help='', args=[d.arg(name='cbetCheckDigitString', type=d.T.string)]),
                withCbetCheckDigitString(cbetCheckDigitString): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { cbetCheckDigitString: cbetCheckDigitString } } } },
                '#withCbetStepaside':: d.fn(help='"Determines the method of CBET insertion mode when prior encoding is detected on the same layer."', args=[d.arg(name='cbetStepaside', type=d.T.string)]),
                withCbetStepaside(cbetStepaside): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { cbetStepaside: cbetStepaside } } } },
                '#withCsid':: d.fn(help='"CBET source ID to use in the watermark."', args=[d.arg(name='csid', type=d.T.string)]),
                withCsid(csid): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenCbetSettings+: { csid: csid } } } },
              },
              '#nielsenNaesIiNwSettings':: d.obj(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."'),
              nielsenNaesIiNwSettings: {
                '#withCheckDigitString':: d.fn(help='', args=[d.arg(name='checkDigitString', type=d.T.string)]),
                withCheckDigitString(checkDigitString): { checkDigitString: checkDigitString },
                '#withSid':: d.fn(help='"The Nielsen Source ID to include in the watermark."', args=[d.arg(name='sid', type=d.T.number)]),
                withSid(sid): { sid: sid },
              },
              '#withNielsenDistributionType':: d.fn(help='"Distribution types to assign to the watermarks. Options are PROGRAM_CONTENT and FINAL_DISTRIBUTOR."', args=[d.arg(name='nielsenDistributionType', type=d.T.string)]),
              withNielsenDistributionType(nielsenDistributionType): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenDistributionType: nielsenDistributionType } } },
              '#withNielsenNaesIiNwSettings':: d.fn(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."', args=[d.arg(name='nielsenNaesIiNwSettings', type=d.T.array)]),
              withNielsenNaesIiNwSettings(nielsenNaesIiNwSettings): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenNaesIiNwSettings: if std.isArray(v=nielsenNaesIiNwSettings) then nielsenNaesIiNwSettings else [nielsenNaesIiNwSettings] } } },
              '#withNielsenNaesIiNwSettingsMixin':: d.fn(help='"Used to insert watermarks of type Nielsen NAES, II (N2) and Nielsen NAES VI (NW). See Nielsen NAES II NW Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nielsenNaesIiNwSettings', type=d.T.array)]),
              withNielsenNaesIiNwSettingsMixin(nielsenNaesIiNwSettings): { audioWatermarkSettings+: { nielsenWatermarksSettings+: { nielsenNaesIiNwSettings+: if std.isArray(v=nielsenNaesIiNwSettings) then nielsenNaesIiNwSettings else [nielsenNaesIiNwSettings] } } },
            },
          },
          '#codecSettings':: d.obj(help='"Audio codec settings. See Audio Codec Settings for more details."'),
          codecSettings: {
            '#aacSettings':: d.obj(help='"Aac Settings. See AAC Settings for more details."'),
            aacSettings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { aacSettings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { aacSettings+: { codingMode: codingMode } } },
              '#withInputType':: d.fn(help='"Set to \\"broadcasterMixedAd\\" when input contains pre-mixed main audio + AD (narration) as a stereo pair."', args=[d.arg(name='inputType', type=d.T.string)]),
              withInputType(inputType): { codecSettings+: { aacSettings+: { inputType: inputType } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { aacSettings+: { profile: profile } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { aacSettings+: { rateControlMode: rateControlMode } } },
              '#withRawFormat':: d.fn(help='"Sets LATM/LOAS AAC output for raw containers."', args=[d.arg(name='rawFormat', type=d.T.string)]),
              withRawFormat(rawFormat): { codecSettings+: { aacSettings+: { rawFormat: rawFormat } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { aacSettings+: { sampleRate: sampleRate } } },
              '#withSpec':: d.fn(help='"Use MPEG-2 AAC audio instead of MPEG-4 AAC audio for raw or MPEG-2 Transport Stream containers."', args=[d.arg(name='spec', type=d.T.string)]),
              withSpec(spec): { codecSettings+: { aacSettings+: { spec: spec } } },
              '#withVbrQuality':: d.fn(help='"VBR Quality Level - Only used if rateControlMode is VBR."', args=[d.arg(name='vbrQuality', type=d.T.string)]),
              withVbrQuality(vbrQuality): { codecSettings+: { aacSettings+: { vbrQuality: vbrQuality } } },
            },
            '#ac3Settings':: d.obj(help='"Ac3 Settings. See AC3 Settings for more details."'),
            ac3Settings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { ac3Settings+: { bitrate: bitrate } } },
              '#withBitstreamMode':: d.fn(help='"Specifies the bitstream mode (bsmod) for the emitted AC-3 stream."', args=[d.arg(name='bitstreamMode', type=d.T.string)]),
              withBitstreamMode(bitstreamMode): { codecSettings+: { ac3Settings+: { bitstreamMode: bitstreamMode } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { ac3Settings+: { codingMode: codingMode } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { ac3Settings+: { dialnorm: dialnorm } } },
              '#withDrcProfile':: d.fn(help='"If set to filmStandard, adds dynamic range compression signaling to the output bitstream as defined in the Dolby Digital specification."', args=[d.arg(name='drcProfile', type=d.T.string)]),
              withDrcProfile(drcProfile): { codecSettings+: { ac3Settings+: { drcProfile: drcProfile } } },
              '#withLfeFilter':: d.fn(help='"When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding."', args=[d.arg(name='lfeFilter', type=d.T.string)]),
              withLfeFilter(lfeFilter): { codecSettings+: { ac3Settings+: { lfeFilter: lfeFilter } } },
              '#withMetadataControl':: d.fn(help='"Metadata control."', args=[d.arg(name='metadataControl', type=d.T.string)]),
              withMetadataControl(metadataControl): { codecSettings+: { ac3Settings+: { metadataControl: metadataControl } } },
            },
            '#eac3AtmosSettings':: d.obj(help='"- Eac3 Atmos Settings. See EAC3 Atmos Settings"'),
            eac3AtmosSettings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { eac3AtmosSettings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { eac3AtmosSettings+: { codingMode: codingMode } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { eac3AtmosSettings+: { dialnorm: dialnorm } } },
              '#withDrcLine':: d.fn(help='"Sets the Dolby dynamic range compression profile."', args=[d.arg(name='drcLine', type=d.T.string)]),
              withDrcLine(drcLine): { codecSettings+: { eac3AtmosSettings+: { drcLine: drcLine } } },
              '#withDrcRf':: d.fn(help='"Sets the profile for heavy Dolby dynamic range compression."', args=[d.arg(name='drcRf', type=d.T.string)]),
              withDrcRf(drcRf): { codecSettings+: { eac3AtmosSettings+: { drcRf: drcRf } } },
              '#withHeightTrim':: d.fn(help='"Height dimensional trim."', args=[d.arg(name='heightTrim', type=d.T.number)]),
              withHeightTrim(heightTrim): { codecSettings+: { eac3AtmosSettings+: { heightTrim: heightTrim } } },
              '#withSurroundTrim':: d.fn(help='"Surround dimensional trim."', args=[d.arg(name='surroundTrim', type=d.T.number)]),
              withSurroundTrim(surroundTrim): { codecSettings+: { eac3AtmosSettings+: { surroundTrim: surroundTrim } } },
            },
            '#eac3Settings':: d.obj(help='"- Eac3 Settings. See EAC3 Settings"'),
            eac3Settings: {
              '#withAttenuationControl':: d.fn(help='"Sets the attenuation control."', args=[d.arg(name='attenuationControl', type=d.T.string)]),
              withAttenuationControl(attenuationControl): { codecSettings+: { eac3Settings+: { attenuationControl: attenuationControl } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { eac3Settings+: { bitrate: bitrate } } },
              '#withBitstreamMode':: d.fn(help='"Specifies the bitstream mode (bsmod) for the emitted AC-3 stream."', args=[d.arg(name='bitstreamMode', type=d.T.string)]),
              withBitstreamMode(bitstreamMode): { codecSettings+: { eac3Settings+: { bitstreamMode: bitstreamMode } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { eac3Settings+: { codingMode: codingMode } } },
              '#withDcFilter':: d.fn(help='', args=[d.arg(name='dcFilter', type=d.T.string)]),
              withDcFilter(dcFilter): { codecSettings+: { eac3Settings+: { dcFilter: dcFilter } } },
              '#withDialnorm':: d.fn(help='"Sets the dialnorm of the output."', args=[d.arg(name='dialnorm', type=d.T.number)]),
              withDialnorm(dialnorm): { codecSettings+: { eac3Settings+: { dialnorm: dialnorm } } },
              '#withDrcLine':: d.fn(help='"Sets the Dolby dynamic range compression profile."', args=[d.arg(name='drcLine', type=d.T.string)]),
              withDrcLine(drcLine): { codecSettings+: { eac3Settings+: { drcLine: drcLine } } },
              '#withDrcRf':: d.fn(help='"Sets the profile for heavy Dolby dynamic range compression."', args=[d.arg(name='drcRf', type=d.T.string)]),
              withDrcRf(drcRf): { codecSettings+: { eac3Settings+: { drcRf: drcRf } } },
              '#withLfeControl':: d.fn(help='', args=[d.arg(name='lfeControl', type=d.T.string)]),
              withLfeControl(lfeControl): { codecSettings+: { eac3Settings+: { lfeControl: lfeControl } } },
              '#withLfeFilter':: d.fn(help='"When set to enabled, applies a 120Hz lowpass filter to the LFE channel prior to encoding."', args=[d.arg(name='lfeFilter', type=d.T.string)]),
              withLfeFilter(lfeFilter): { codecSettings+: { eac3Settings+: { lfeFilter: lfeFilter } } },
              '#withLoRoCenterMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='loRoCenterMixLevel', type=d.T.number)]),
              withLoRoCenterMixLevel(loRoCenterMixLevel): { codecSettings+: { eac3Settings+: { loRoCenterMixLevel: loRoCenterMixLevel } } },
              '#withLoRoSurroundMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='loRoSurroundMixLevel', type=d.T.number)]),
              withLoRoSurroundMixLevel(loRoSurroundMixLevel): { codecSettings+: { eac3Settings+: { loRoSurroundMixLevel: loRoSurroundMixLevel } } },
              '#withLtRtCenterMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='ltRtCenterMixLevel', type=d.T.number)]),
              withLtRtCenterMixLevel(ltRtCenterMixLevel): { codecSettings+: { eac3Settings+: { ltRtCenterMixLevel: ltRtCenterMixLevel } } },
              '#withLtRtSurroundMixLevel':: d.fn(help='"H264 level."', args=[d.arg(name='ltRtSurroundMixLevel', type=d.T.number)]),
              withLtRtSurroundMixLevel(ltRtSurroundMixLevel): { codecSettings+: { eac3Settings+: { ltRtSurroundMixLevel: ltRtSurroundMixLevel } } },
              '#withMetadataControl':: d.fn(help='"Metadata control."', args=[d.arg(name='metadataControl', type=d.T.string)]),
              withMetadataControl(metadataControl): { codecSettings+: { eac3Settings+: { metadataControl: metadataControl } } },
              '#withPassthroughControl':: d.fn(help='', args=[d.arg(name='passthroughControl', type=d.T.string)]),
              withPassthroughControl(passthroughControl): { codecSettings+: { eac3Settings+: { passthroughControl: passthroughControl } } },
              '#withPhaseControl':: d.fn(help='', args=[d.arg(name='phaseControl', type=d.T.string)]),
              withPhaseControl(phaseControl): { codecSettings+: { eac3Settings+: { phaseControl: phaseControl } } },
              '#withStereoDownmix':: d.fn(help='', args=[d.arg(name='stereoDownmix', type=d.T.string)]),
              withStereoDownmix(stereoDownmix): { codecSettings+: { eac3Settings+: { stereoDownmix: stereoDownmix } } },
              '#withSurroundExMode':: d.fn(help='', args=[d.arg(name='surroundExMode', type=d.T.string)]),
              withSurroundExMode(surroundExMode): { codecSettings+: { eac3Settings+: { surroundExMode: surroundExMode } } },
              '#withSurroundMode':: d.fn(help='', args=[d.arg(name='surroundMode', type=d.T.string)]),
              withSurroundMode(surroundMode): { codecSettings+: { eac3Settings+: { surroundMode: surroundMode } } },
            },
            '#mp2Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            mp2Settings: {
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { mp2Settings+: { bitrate: bitrate } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { mp2Settings+: { codingMode: codingMode } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { mp2Settings+: { sampleRate: sampleRate } } },
            },
            '#wavSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            wavSettings: {
              '#withBitDepth':: d.fn(help='', args=[d.arg(name='bitDepth', type=d.T.number)]),
              withBitDepth(bitDepth): { codecSettings+: { wavSettings+: { bitDepth: bitDepth } } },
              '#withCodingMode':: d.fn(help='"Mono, Stereo, or 5.1 channel layout."', args=[d.arg(name='codingMode', type=d.T.string)]),
              withCodingMode(codingMode): { codecSettings+: { wavSettings+: { codingMode: codingMode } } },
              '#withSampleRate':: d.fn(help='"Sample rate in Hz."', args=[d.arg(name='sampleRate', type=d.T.number)]),
              withSampleRate(sampleRate): { codecSettings+: { wavSettings+: { sampleRate: sampleRate } } },
            },
            '#withPassThroughSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='passThroughSettings', type=d.T.object)]),
            withPassThroughSettings(passThroughSettings): { codecSettings+: { passThroughSettings: passThroughSettings } },
            '#withPassThroughSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='passThroughSettings', type=d.T.object)]),
            withPassThroughSettingsMixin(passThroughSettings): { codecSettings+: { passThroughSettings+: passThroughSettings } },
          },
          '#remixSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
          remixSettings: {
            '#channelMappings':: d.obj(help=''),
            channelMappings: {
              '#inputChannelLevels':: d.obj(help=''),
              inputChannelLevels: {
                '#withGain':: d.fn(help='', args=[d.arg(name='gain', type=d.T.number)]),
                withGain(gain): { gain: gain },
                '#withInputChannel':: d.fn(help='', args=[d.arg(name='inputChannel', type=d.T.number)]),
                withInputChannel(inputChannel): { inputChannel: inputChannel },
              },
              '#withInputChannelLevels':: d.fn(help='', args=[d.arg(name='inputChannelLevels', type=d.T.array)]),
              withInputChannelLevels(inputChannelLevels): { inputChannelLevels: if std.isArray(v=inputChannelLevels) then inputChannelLevels else [inputChannelLevels] },
              '#withInputChannelLevelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inputChannelLevels', type=d.T.array)]),
              withInputChannelLevelsMixin(inputChannelLevels): { inputChannelLevels+: if std.isArray(v=inputChannelLevels) then inputChannelLevels else [inputChannelLevels] },
              '#withOutputChannel':: d.fn(help='', args=[d.arg(name='outputChannel', type=d.T.number)]),
              withOutputChannel(outputChannel): { outputChannel: outputChannel },
            },
            '#withChannelMappings':: d.fn(help='', args=[d.arg(name='channelMappings', type=d.T.array)]),
            withChannelMappings(channelMappings): { remixSettings+: { channelMappings: if std.isArray(v=channelMappings) then channelMappings else [channelMappings] } },
            '#withChannelMappingsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='channelMappings', type=d.T.array)]),
            withChannelMappingsMixin(channelMappings): { remixSettings+: { channelMappings+: if std.isArray(v=channelMappings) then channelMappings else [channelMappings] } },
            '#withChannelsIn':: d.fn(help='', args=[d.arg(name='channelsIn', type=d.T.number)]),
            withChannelsIn(channelsIn): { remixSettings+: { channelsIn: channelsIn } },
            '#withChannelsOut':: d.fn(help='', args=[d.arg(name='channelsOut', type=d.T.number)]),
            withChannelsOut(channelsOut): { remixSettings+: { channelsOut: channelsOut } },
          },
          '#withAudioSelectorName':: d.fn(help="\"The name of the audio selector in the input that MediaLive should monitor to detect silence. Select your most important rendition. If you didn't create an audio selector in this input, leave blank.\"", args=[d.arg(name='audioSelectorName', type=d.T.string)]),
          withAudioSelectorName(audioSelectorName): { audioSelectorName: audioSelectorName },
          '#withAudioType':: d.fn(help='"Applies only if audioTypeControl is useConfigured. The values for audioType are defined in ISO-IEC 13818-1."', args=[d.arg(name='audioType', type=d.T.string)]),
          withAudioType(audioType): { audioType: audioType },
          '#withAudioTypeControl':: d.fn(help='"Determined how audio type is determined."', args=[d.arg(name='audioTypeControl', type=d.T.string)]),
          withAudioTypeControl(audioTypeControl): { audioTypeControl: audioTypeControl },
          '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
          withLanguageCode(languageCode): { languageCode: languageCode },
          '#withLanguageCodeControl':: d.fn(help='', args=[d.arg(name='languageCodeControl', type=d.T.string)]),
          withLanguageCodeControl(languageCodeControl): { languageCodeControl: languageCodeControl },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withStreamName':: d.fn(help='"Stream name RTMP destinations (URLs of type rtmp://)"', args=[d.arg(name='streamName', type=d.T.string)]),
          withStreamName(streamName): { streamName: streamName },
        },
        '#availBlanking':: d.obj(help='"Settings for ad avail blanking. See Avail Blanking for more details."'),
        availBlanking: {
          '#availBlankingImage':: d.obj(help='"Blanking image to be used. See Avail Blanking Image for more details."'),
          availBlankingImage: {
            '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
            withPasswordParam(passwordParam): { spec+: { initProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { passwordParam: passwordParam } } } } } },
            '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
            withUri(uri): { spec+: { initProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { uri: uri } } } } } },
            '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
            withUsername(username): { spec+: { initProvider+: { encoderSettings+: { availBlanking+: { availBlankingImage+: { username: username } } } } } },
          },
          '#withState':: d.fn(help='"When set to enabled, causes video, audio and captions to be blanked when insertion metadata is added."', args=[d.arg(name='state', type=d.T.string)]),
          withState(state): { spec+: { initProvider+: { encoderSettings+: { availBlanking+: { state: state } } } } },
        },
        '#captionDescriptions':: d.obj(help='"Caption Descriptions. See Caption Descriptions for more details."'),
        captionDescriptions: {
          '#destinationSettings':: d.obj(help='"Additional settings for captions destination that depend on the destination type. See Destination Settings for more details."'),
          destinationSettings: {
            '#burnInDestinationSettings':: d.obj(help='"Burn In Destination Settings. See Burn In Destination Settings for more details."'),
            burnInDestinationSettings: {
              '#font':: d.obj(help='"External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details."'),
              font: {
                '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                withPasswordParam(passwordParam): { destinationSettings+: { burnInDestinationSettings+: { font+: { passwordParam: passwordParam } } } },
                '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                withUri(uri): { destinationSettings+: { burnInDestinationSettings+: { font+: { uri: uri } } } },
                '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                withUsername(username): { destinationSettings+: { burnInDestinationSettings+: { font+: { username: username } } } },
              },
              '#withAlignment':: d.fn(help='"If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='alignment', type=d.T.string)]),
              withAlignment(alignment): { destinationSettings+: { burnInDestinationSettings+: { alignment: alignment } } },
              '#withBackgroundColor':: d.fn(help='"Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundColor', type=d.T.string)]),
              withBackgroundColor(backgroundColor): { destinationSettings+: { burnInDestinationSettings+: { backgroundColor: backgroundColor } } },
              '#withBackgroundOpacity':: d.fn(help='"Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundOpacity', type=d.T.number)]),
              withBackgroundOpacity(backgroundOpacity): { destinationSettings+: { burnInDestinationSettings+: { backgroundOpacity: backgroundOpacity } } },
              '#withFontColor':: d.fn(help='"Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontColor', type=d.T.string)]),
              withFontColor(fontColor): { destinationSettings+: { burnInDestinationSettings+: { fontColor: fontColor } } },
              '#withFontOpacity':: d.fn(help='"Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontOpacity', type=d.T.number)]),
              withFontOpacity(fontOpacity): { destinationSettings+: { burnInDestinationSettings+: { fontOpacity: fontOpacity } } },
              '#withFontResolution':: d.fn(help='"Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontResolution', type=d.T.number)]),
              withFontResolution(fontResolution): { destinationSettings+: { burnInDestinationSettings+: { fontResolution: fontResolution } } },
              '#withFontSize':: d.fn(help='"When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontSize', type=d.T.string)]),
              withFontSize(fontSize): { destinationSettings+: { burnInDestinationSettings+: { fontSize: fontSize } } },
              '#withOutlineColor':: d.fn(help='"Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineColor', type=d.T.string)]),
              withOutlineColor(outlineColor): { destinationSettings+: { burnInDestinationSettings+: { outlineColor: outlineColor } } },
              '#withOutlineSize':: d.fn(help='"Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineSize', type=d.T.number)]),
              withOutlineSize(outlineSize): { destinationSettings+: { burnInDestinationSettings+: { outlineSize: outlineSize } } },
              '#withShadowColor':: d.fn(help='"Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowColor', type=d.T.string)]),
              withShadowColor(shadowColor): { destinationSettings+: { burnInDestinationSettings+: { shadowColor: shadowColor } } },
              '#withShadowOpacity':: d.fn(help='"Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowOpacity', type=d.T.number)]),
              withShadowOpacity(shadowOpacity): { destinationSettings+: { burnInDestinationSettings+: { shadowOpacity: shadowOpacity } } },
              '#withShadowXOffset':: d.fn(help='"Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowXOffset', type=d.T.number)]),
              withShadowXOffset(shadowXOffset): { destinationSettings+: { burnInDestinationSettings+: { shadowXOffset: shadowXOffset } } },
              '#withShadowYOffset':: d.fn(help='"Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowYOffset', type=d.T.number)]),
              withShadowYOffset(shadowYOffset): { destinationSettings+: { burnInDestinationSettings+: { shadowYOffset: shadowYOffset } } },
              '#withTeletextGridControl':: d.fn(help='"Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs."', args=[d.arg(name='teletextGridControl', type=d.T.string)]),
              withTeletextGridControl(teletextGridControl): { destinationSettings+: { burnInDestinationSettings+: { teletextGridControl: teletextGridControl } } },
              '#withXPosition':: d.fn(help='"Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='xPosition', type=d.T.number)]),
              withXPosition(xPosition): { destinationSettings+: { burnInDestinationSettings+: { xPosition: xPosition } } },
              '#withYPosition':: d.fn(help='"Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='yPosition', type=d.T.number)]),
              withYPosition(yPosition): { destinationSettings+: { burnInDestinationSettings+: { yPosition: yPosition } } },
            },
            '#dvbSubDestinationSettings':: d.obj(help='"DVB Sub Destination Settings. See DVB Sub Destination Settings for more details."'),
            dvbSubDestinationSettings: {
              '#font':: d.obj(help='"External font file used for caption burn-in. File extension must be ‘ttf’ or ‘tte’. Although the user can select output fonts for many different types of input captions, embedded, STL and teletext sources use a strict grid system. Using external fonts with these caption sources could cause unexpected display of proportional fonts. All burn-in and DVB-Sub font settings must match. See Font for more details."'),
              font: {
                '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                withPasswordParam(passwordParam): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { passwordParam: passwordParam } } } },
                '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                withUri(uri): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { uri: uri } } } },
                '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                withUsername(username): { destinationSettings+: { dvbSubDestinationSettings+: { font+: { username: username } } } },
              },
              '#withAlignment':: d.fn(help='"If no explicit xPosition or yPosition is provided, setting alignment to centered will place the captions at the bottom center of the output. Similarly, setting a left alignment will align captions to the bottom left of the output. If x and y positions are given in conjunction with the alignment parameter, the font will be justified (either left or centered) relative to those coordinates. Selecting “smart” justification will left-justify live subtitles and center-justify pre-recorded subtitles. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='alignment', type=d.T.string)]),
              withAlignment(alignment): { destinationSettings+: { dvbSubDestinationSettings+: { alignment: alignment } } },
              '#withBackgroundColor':: d.fn(help='"Specifies the color of the rectangle behind the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundColor', type=d.T.string)]),
              withBackgroundColor(backgroundColor): { destinationSettings+: { dvbSubDestinationSettings+: { backgroundColor: backgroundColor } } },
              '#withBackgroundOpacity':: d.fn(help='"Specifies the opacity of the background rectangle. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='backgroundOpacity', type=d.T.number)]),
              withBackgroundOpacity(backgroundOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { backgroundOpacity: backgroundOpacity } } },
              '#withFontColor':: d.fn(help='"Specifies the color of the burned-in captions. This option is not valid for source captions that are STL, 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontColor', type=d.T.string)]),
              withFontColor(fontColor): { destinationSettings+: { dvbSubDestinationSettings+: { fontColor: fontColor } } },
              '#withFontOpacity':: d.fn(help='"Specifies the opacity of the burned-in captions. 255 is opaque; 0 is transparent. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontOpacity', type=d.T.number)]),
              withFontOpacity(fontOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { fontOpacity: fontOpacity } } },
              '#withFontResolution':: d.fn(help='"Font resolution in DPI (dots per inch); default is 96 dpi. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontResolution', type=d.T.number)]),
              withFontResolution(fontResolution): { destinationSettings+: { dvbSubDestinationSettings+: { fontResolution: fontResolution } } },
              '#withFontSize':: d.fn(help='"When set to ‘auto’ fontSize will scale depending on the size of the output. Giving a positive integer will specify the exact font size in points. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='fontSize', type=d.T.string)]),
              withFontSize(fontSize): { destinationSettings+: { dvbSubDestinationSettings+: { fontSize: fontSize } } },
              '#withOutlineColor':: d.fn(help='"Specifies font outline color. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineColor', type=d.T.string)]),
              withOutlineColor(outlineColor): { destinationSettings+: { dvbSubDestinationSettings+: { outlineColor: outlineColor } } },
              '#withOutlineSize':: d.fn(help='"Specifies font outline size in pixels. This option is not valid for source captions that are either 608/embedded or teletext. These source settings are already pre-defined by the caption stream. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='outlineSize', type=d.T.number)]),
              withOutlineSize(outlineSize): { destinationSettings+: { dvbSubDestinationSettings+: { outlineSize: outlineSize } } },
              '#withShadowColor':: d.fn(help='"Specifies the color of the shadow cast by the captions. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowColor', type=d.T.string)]),
              withShadowColor(shadowColor): { destinationSettings+: { dvbSubDestinationSettings+: { shadowColor: shadowColor } } },
              '#withShadowOpacity':: d.fn(help='"Specifies the opacity of the shadow. 255 is opaque; 0 is transparent. Leaving this parameter out is equivalent to setting it to 0 (transparent). All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowOpacity', type=d.T.number)]),
              withShadowOpacity(shadowOpacity): { destinationSettings+: { dvbSubDestinationSettings+: { shadowOpacity: shadowOpacity } } },
              '#withShadowXOffset':: d.fn(help='"Specifies the horizontal offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels to the left. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowXOffset', type=d.T.number)]),
              withShadowXOffset(shadowXOffset): { destinationSettings+: { dvbSubDestinationSettings+: { shadowXOffset: shadowXOffset } } },
              '#withShadowYOffset':: d.fn(help='"Specifies the vertical offset of the shadow relative to the captions in pixels. A value of -2 would result in a shadow offset 2 pixels above the text. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='shadowYOffset', type=d.T.number)]),
              withShadowYOffset(shadowYOffset): { destinationSettings+: { dvbSubDestinationSettings+: { shadowYOffset: shadowYOffset } } },
              '#withTeletextGridControl':: d.fn(help='"Controls whether a fixed grid size will be used to generate the output subtitles bitmap. Only applicable for Teletext inputs and DVB-Sub/Burn-in outputs."', args=[d.arg(name='teletextGridControl', type=d.T.string)]),
              withTeletextGridControl(teletextGridControl): { destinationSettings+: { dvbSubDestinationSettings+: { teletextGridControl: teletextGridControl } } },
              '#withXPosition':: d.fn(help='"Specifies the horizontal position of the caption relative to the left side of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the left of the output. If no explicit xPosition is provided, the horizontal caption position will be determined by the alignment parameter. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='xPosition', type=d.T.number)]),
              withXPosition(xPosition): { destinationSettings+: { dvbSubDestinationSettings+: { xPosition: xPosition } } },
              '#withYPosition':: d.fn(help='"Specifies the vertical position of the caption relative to the top of the output in pixels. A value of 10 would result in the captions starting 10 pixels from the top of the output. If no explicit yPosition is provided, the caption will be positioned towards the bottom of the output. All burn-in and DVB-Sub font settings must match."', args=[d.arg(name='yPosition', type=d.T.number)]),
              withYPosition(yPosition): { destinationSettings+: { dvbSubDestinationSettings+: { yPosition: yPosition } } },
            },
            '#ebuTtDDestinationSettings':: d.obj(help='"EBU TT D Destination Settings. See EBU TT D Destination Settings for more details."'),
            ebuTtDDestinationSettings: {
              '#withCopyrightHolder':: d.fn(help='"Complete this field if you want to include the name of the copyright holder in the copyright tag in the captions metadata."', args=[d.arg(name='copyrightHolder', type=d.T.string)]),
              withCopyrightHolder(copyrightHolder): { destinationSettings+: { ebuTtDDestinationSettings+: { copyrightHolder: copyrightHolder } } },
              '#withFillLineGap':: d.fn(help='"Specifies how to handle the gap between the lines (in multi-line captions). - enabled: Fill with the captions background color (as specified in the input captions). - disabled: Leave the gap unfilled."', args=[d.arg(name='fillLineGap', type=d.T.string)]),
              withFillLineGap(fillLineGap): { destinationSettings+: { ebuTtDDestinationSettings+: { fillLineGap: fillLineGap } } },
              '#withFontFamily':: d.fn(help='"Specifies the font family to include in the font data attached to the EBU-TT captions. Valid only if styleControl is set to include. If you leave this field empty, the font family is set to “monospaced”. (If styleControl is set to exclude, the font family is always set to “monospaced”.) You specify only the font family. All other style information (color, bold, position and so on) is copied from the input captions. The size is always set to 100% to allow the downstream player to choose the size. - Enter a list of font families, as a comma-separated list of font names, in order of preference. The name can be a font family (such as “Arial”), or a generic font family (such as “serif”), or “default” (to let the downstream player choose the font). - Leave blank to set the family to “monospace”."', args=[d.arg(name='fontFamily', type=d.T.string)]),
              withFontFamily(fontFamily): { destinationSettings+: { ebuTtDDestinationSettings+: { fontFamily: fontFamily } } },
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { ebuTtDDestinationSettings+: { styleControl: styleControl } } },
            },
            '#ttmlDestinationSettings':: d.obj(help='"TTML Destination Settings. See TTML Destination Settings for more details."'),
            ttmlDestinationSettings: {
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { ttmlDestinationSettings+: { styleControl: styleControl } } },
            },
            '#webvttDestinationSettings':: d.obj(help='"WebVTT Destination Settings. See WebVTT Destination Settings for more details."'),
            webvttDestinationSettings: {
              '#withStyleControl':: d.fn(help='"Specifies the style information (font color, font position, and so on) to include in the font data that is attached to the EBU-TT captions. - include: Take the style information (font color, font position, and so on) from the source captions and include that information in the font data attached to the EBU-TT captions. This option is valid only if the source captions are Embedded or Teletext. - exclude: In the font data attached to the EBU-TT captions, set the font family to “monospaced”. Do not include any other style information."', args=[d.arg(name='styleControl', type=d.T.string)]),
              withStyleControl(styleControl): { destinationSettings+: { webvttDestinationSettings+: { styleControl: styleControl } } },
            },
            '#withAribDestinationSettings':: d.fn(help='"ARIB Destination Settings."', args=[d.arg(name='aribDestinationSettings', type=d.T.object)]),
            withAribDestinationSettings(aribDestinationSettings): { destinationSettings+: { aribDestinationSettings: aribDestinationSettings } },
            '#withAribDestinationSettingsMixin':: d.fn(help='"ARIB Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aribDestinationSettings', type=d.T.object)]),
            withAribDestinationSettingsMixin(aribDestinationSettings): { destinationSettings+: { aribDestinationSettings+: aribDestinationSettings } },
            '#withEmbeddedDestinationSettings':: d.fn(help='"Embedded Destination Settings."', args=[d.arg(name='embeddedDestinationSettings', type=d.T.object)]),
            withEmbeddedDestinationSettings(embeddedDestinationSettings): { destinationSettings+: { embeddedDestinationSettings: embeddedDestinationSettings } },
            '#withEmbeddedDestinationSettingsMixin':: d.fn(help='"Embedded Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='embeddedDestinationSettings', type=d.T.object)]),
            withEmbeddedDestinationSettingsMixin(embeddedDestinationSettings): { destinationSettings+: { embeddedDestinationSettings+: embeddedDestinationSettings } },
            '#withEmbeddedPlusScte20DestinationSettings':: d.fn(help='"Embedded Plus SCTE20 Destination Settings."', args=[d.arg(name='embeddedPlusScte20DestinationSettings', type=d.T.object)]),
            withEmbeddedPlusScte20DestinationSettings(embeddedPlusScte20DestinationSettings): { destinationSettings+: { embeddedPlusScte20DestinationSettings: embeddedPlusScte20DestinationSettings } },
            '#withEmbeddedPlusScte20DestinationSettingsMixin':: d.fn(help='"Embedded Plus SCTE20 Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='embeddedPlusScte20DestinationSettings', type=d.T.object)]),
            withEmbeddedPlusScte20DestinationSettingsMixin(embeddedPlusScte20DestinationSettings): { destinationSettings+: { embeddedPlusScte20DestinationSettings+: embeddedPlusScte20DestinationSettings } },
            '#withRtmpCaptionInfoDestinationSettings':: d.fn(help='"RTMP Caption Info Destination Settings."', args=[d.arg(name='rtmpCaptionInfoDestinationSettings', type=d.T.object)]),
            withRtmpCaptionInfoDestinationSettings(rtmpCaptionInfoDestinationSettings): { destinationSettings+: { rtmpCaptionInfoDestinationSettings: rtmpCaptionInfoDestinationSettings } },
            '#withRtmpCaptionInfoDestinationSettingsMixin':: d.fn(help='"RTMP Caption Info Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rtmpCaptionInfoDestinationSettings', type=d.T.object)]),
            withRtmpCaptionInfoDestinationSettingsMixin(rtmpCaptionInfoDestinationSettings): { destinationSettings+: { rtmpCaptionInfoDestinationSettings+: rtmpCaptionInfoDestinationSettings } },
            '#withScte20PlusEmbeddedDestinationSettings':: d.fn(help='"SCTE20 Plus Embedded Destination Settings."', args=[d.arg(name='scte20PlusEmbeddedDestinationSettings', type=d.T.object)]),
            withScte20PlusEmbeddedDestinationSettings(scte20PlusEmbeddedDestinationSettings): { destinationSettings+: { scte20PlusEmbeddedDestinationSettings: scte20PlusEmbeddedDestinationSettings } },
            '#withScte20PlusEmbeddedDestinationSettingsMixin':: d.fn(help='"SCTE20 Plus Embedded Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scte20PlusEmbeddedDestinationSettings', type=d.T.object)]),
            withScte20PlusEmbeddedDestinationSettingsMixin(scte20PlusEmbeddedDestinationSettings): { destinationSettings+: { scte20PlusEmbeddedDestinationSettings+: scte20PlusEmbeddedDestinationSettings } },
            '#withScte27DestinationSettings':: d.fn(help='"SCTE27 Destination Settings."', args=[d.arg(name='scte27DestinationSettings', type=d.T.object)]),
            withScte27DestinationSettings(scte27DestinationSettings): { destinationSettings+: { scte27DestinationSettings: scte27DestinationSettings } },
            '#withScte27DestinationSettingsMixin':: d.fn(help='"SCTE27 Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scte27DestinationSettings', type=d.T.object)]),
            withScte27DestinationSettingsMixin(scte27DestinationSettings): { destinationSettings+: { scte27DestinationSettings+: scte27DestinationSettings } },
            '#withSmpteTtDestinationSettings':: d.fn(help='"SMPTE TT Destination Settings."', args=[d.arg(name='smpteTtDestinationSettings', type=d.T.object)]),
            withSmpteTtDestinationSettings(smpteTtDestinationSettings): { destinationSettings+: { smpteTtDestinationSettings: smpteTtDestinationSettings } },
            '#withSmpteTtDestinationSettingsMixin':: d.fn(help='"SMPTE TT Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='smpteTtDestinationSettings', type=d.T.object)]),
            withSmpteTtDestinationSettingsMixin(smpteTtDestinationSettings): { destinationSettings+: { smpteTtDestinationSettings+: smpteTtDestinationSettings } },
            '#withTeletextDestinationSettings':: d.fn(help='"Teletext Destination Settings."', args=[d.arg(name='teletextDestinationSettings', type=d.T.object)]),
            withTeletextDestinationSettings(teletextDestinationSettings): { destinationSettings+: { teletextDestinationSettings: teletextDestinationSettings } },
            '#withTeletextDestinationSettingsMixin':: d.fn(help='"Teletext Destination Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='teletextDestinationSettings', type=d.T.object)]),
            withTeletextDestinationSettingsMixin(teletextDestinationSettings): { destinationSettings+: { teletextDestinationSettings+: teletextDestinationSettings } },
          },
          '#withAccessibility':: d.fn(help='"Indicates whether the caption track implements accessibility features such as written descriptions of spoken dialog, music, and sounds."', args=[d.arg(name='accessibility', type=d.T.string)]),
          withAccessibility(accessibility): { accessibility: accessibility },
          '#withCaptionSelectorName':: d.fn(help='"Specifies which input caption selector to use as a caption source when generating output captions. This field should match a captionSelector name."', args=[d.arg(name='captionSelectorName', type=d.T.string)]),
          withCaptionSelectorName(captionSelectorName): { captionSelectorName: captionSelectorName },
          '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
          withLanguageCode(languageCode): { languageCode: languageCode },
          '#withLanguageDescription':: d.fn(help='"Human readable information to indicate captions available for players (eg. English, or Spanish)."', args=[d.arg(name='languageDescription', type=d.T.string)]),
          withLanguageDescription(languageDescription): { languageDescription: languageDescription },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#globalConfiguration':: d.obj(help='"Configuration settings that apply to the event as a whole. See Global Configuration for more details."'),
        globalConfiguration: {
          '#inputLossBehavior':: d.obj(help='"Settings for system actions when input is lost. See Input Loss Behavior for more details."'),
          inputLossBehavior: {
            '#inputLossImageSlate':: d.obj(help=''),
            inputLossImageSlate: {
              '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
              withPasswordParam(passwordParam): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { passwordParam: passwordParam } } } } } } },
              '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
              withUri(uri): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { uri: uri } } } } } } },
              '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
              withUsername(username): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageSlate+: { username: username } } } } } } },
            },
            '#withBlackFrameMsec':: d.fn(help='', args=[d.arg(name='blackFrameMsec', type=d.T.number)]),
            withBlackFrameMsec(blackFrameMsec): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { blackFrameMsec: blackFrameMsec } } } } } },
            '#withInputLossImageColor':: d.fn(help='', args=[d.arg(name='inputLossImageColor', type=d.T.string)]),
            withInputLossImageColor(inputLossImageColor): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageColor: inputLossImageColor } } } } } },
            '#withInputLossImageType':: d.fn(help='', args=[d.arg(name='inputLossImageType', type=d.T.string)]),
            withInputLossImageType(inputLossImageType): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { inputLossImageType: inputLossImageType } } } } } },
            '#withRepeatFrameMsec':: d.fn(help='', args=[d.arg(name='repeatFrameMsec', type=d.T.number)]),
            withRepeatFrameMsec(repeatFrameMsec): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputLossBehavior+: { repeatFrameMsec: repeatFrameMsec } } } } } },
          },
          '#withInitialAudioGain':: d.fn(help='"Value to set the initial audio gain for the Live Event."', args=[d.arg(name='initialAudioGain', type=d.T.number)]),
          withInitialAudioGain(initialAudioGain): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { initialAudioGain: initialAudioGain } } } } },
          '#withInputEndAction':: d.fn(help='"Indicates the action to take when the current input completes (e.g. end-of-file). When switchAndLoopInputs is configured the encoder will restart at the beginning of the first input. When “none” is configured the encoder will transcode either black, a solid color, or a user specified slate images per the “Input Loss Behavior” configuration until the next input switch occurs (which is controlled through the Channel Schedule API)."', args=[d.arg(name='inputEndAction', type=d.T.string)]),
          withInputEndAction(inputEndAction): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { inputEndAction: inputEndAction } } } } },
          '#withOutputLockingMode':: d.fn(help='"Indicates how MediaLive pipelines are synchronized. PIPELINE_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the other. EPOCH_LOCKING - MediaLive will attempt to synchronize the output of each pipeline to the Unix epoch."', args=[d.arg(name='outputLockingMode', type=d.T.string)]),
          withOutputLockingMode(outputLockingMode): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { outputLockingMode: outputLockingMode } } } } },
          '#withOutputTimingSource':: d.fn(help='"Indicates whether the rate of frames emitted by the Live encoder should be paced by its system clock (which optionally may be locked to another source via NTP) or should be locked to the clock of the source that is providing the input stream."', args=[d.arg(name='outputTimingSource', type=d.T.string)]),
          withOutputTimingSource(outputTimingSource): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { outputTimingSource: outputTimingSource } } } } },
          '#withSupportLowFramerateInputs':: d.fn(help='"Adjusts video input buffer for streams with very low video framerates. This is commonly set to enabled for music channels with less than one video frame per second."', args=[d.arg(name='supportLowFramerateInputs', type=d.T.string)]),
          withSupportLowFramerateInputs(supportLowFramerateInputs): { spec+: { initProvider+: { encoderSettings+: { globalConfiguration+: { supportLowFramerateInputs: supportLowFramerateInputs } } } } },
        },
        '#motionGraphicsConfiguration':: d.obj(help='"Settings for motion graphics. See Motion Graphics Configuration for more details."'),
        motionGraphicsConfiguration: {
          '#motionGraphicsSettings':: d.obj(help='"–  Motion Graphics Settings. See Motion Graphics Settings for more details."'),
          motionGraphicsSettings: {
            '#withHtmlMotionGraphicsSettings':: d.fn(help='"Html Motion Graphics Settings."', args=[d.arg(name='htmlMotionGraphicsSettings', type=d.T.object)]),
            withHtmlMotionGraphicsSettings(htmlMotionGraphicsSettings): { spec+: { initProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsSettings+: { htmlMotionGraphicsSettings: htmlMotionGraphicsSettings } } } } } },
            '#withHtmlMotionGraphicsSettingsMixin':: d.fn(help='"Html Motion Graphics Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='htmlMotionGraphicsSettings', type=d.T.object)]),
            withHtmlMotionGraphicsSettingsMixin(htmlMotionGraphicsSettings): { spec+: { initProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsSettings+: { htmlMotionGraphicsSettings+: htmlMotionGraphicsSettings } } } } } },
          },
          '#withMotionGraphicsInsertion':: d.fn(help='"Motion Graphics Insertion."', args=[d.arg(name='motionGraphicsInsertion', type=d.T.string)]),
          withMotionGraphicsInsertion(motionGraphicsInsertion): { spec+: { initProvider+: { encoderSettings+: { motionGraphicsConfiguration+: { motionGraphicsInsertion: motionGraphicsInsertion } } } } },
        },
        '#nielsenConfiguration':: d.obj(help='"Nielsen configuration settings. See Nielsen Configuration for more details."'),
        nielsenConfiguration: {
          '#withDistributorId':: d.fn(help='"Enter the Distributor ID assigned to your organization by Nielsen."', args=[d.arg(name='distributorId', type=d.T.string)]),
          withDistributorId(distributorId): { spec+: { initProvider+: { encoderSettings+: { nielsenConfiguration+: { distributorId: distributorId } } } } },
          '#withNielsenPcmToId3Tagging':: d.fn(help='"Enables Nielsen PCM to ID3 tagging."', args=[d.arg(name='nielsenPcmToId3Tagging', type=d.T.string)]),
          withNielsenPcmToId3Tagging(nielsenPcmToId3Tagging): { spec+: { initProvider+: { encoderSettings+: { nielsenConfiguration+: { nielsenPcmToId3Tagging: nielsenPcmToId3Tagging } } } } },
        },
        '#outputGroups':: d.obj(help='"Output groups for the channel. See Output Groups for more details."'),
        outputGroups: {
          '#outputGroupSettings':: d.obj(help='"Settings associated with the output group. See Output Group Settings for more details."'),
          outputGroupSettings: {
            '#archiveGroupSettings':: d.obj(help='"Archive group settings. See Archive Group Settings for more details."'),
            archiveGroupSettings: {
              '#archiveCdnSettings':: d.obj(help='"Parameters that control the interactions with the CDN. See Archive CDN Settings for more details."'),
              archiveCdnSettings: {
                '#archiveS3Settings':: d.obj(help='"Archive S3 Settings. See Archive S3 Settings for more details."'),
                archiveS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { archiveCdnSettings+: { archiveS3Settings+: { cannedAcl: cannedAcl } } },
                },
              },
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { destination+: { destinationRefId: destinationRefId } },
              },
              '#withRolloverInterval':: d.fn(help='"Number of seconds to write to archive file before closing and starting a new one."', args=[d.arg(name='rolloverInterval', type=d.T.number)]),
              withRolloverInterval(rolloverInterval): { rolloverInterval: rolloverInterval },
            },
            '#frameCaptureGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            frameCaptureGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { frameCaptureGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#frameCaptureCdnSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              frameCaptureCdnSettings: {
                '#frameCaptureS3Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                frameCaptureS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { outputGroupSettings+: { frameCaptureGroupSettings+: { frameCaptureCdnSettings+: { frameCaptureS3Settings+: { cannedAcl: cannedAcl } } } } },
                },
              },
            },
            '#hlsGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            hlsGroupSettings: {
              '#captionLanguageMappings':: d.obj(help=''),
              captionLanguageMappings: {
                '#withCaptionChannel':: d.fn(help='', args=[d.arg(name='captionChannel', type=d.T.number)]),
                withCaptionChannel(captionChannel): { captionChannel: captionChannel },
                '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
                withLanguageCode(languageCode): { languageCode: languageCode },
                '#withLanguageDescription':: d.fn(help='"Human readable information to indicate captions available for players (eg. English, or Spanish)."', args=[d.arg(name='languageDescription', type=d.T.string)]),
                withLanguageDescription(languageDescription): { languageDescription: languageDescription },
              },
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { hlsGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#hlsCdnSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              hlsCdnSettings: {
                '#hlsAkamaiSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsAkamaiSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsAkamaiSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsAkamaiSettings+: { filecacheDuration: filecacheDuration } },
                  '#withHttpTransferMode':: d.fn(help='', args=[d.arg(name='httpTransferMode', type=d.T.string)]),
                  withHttpTransferMode(httpTransferMode): { hlsAkamaiSettings+: { httpTransferMode: httpTransferMode } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsAkamaiSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsAkamaiSettings+: { restartDelay: restartDelay } },
                  '#withSalt':: d.fn(help='', args=[d.arg(name='salt', type=d.T.string)]),
                  withSalt(salt): { hlsAkamaiSettings+: { salt: salt } },
                  '#withToken':: d.fn(help='', args=[d.arg(name='token', type=d.T.string)]),
                  withToken(token): { hlsAkamaiSettings+: { token: token } },
                },
                '#hlsBasicPutSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsBasicPutSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsBasicPutSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsBasicPutSettings+: { filecacheDuration: filecacheDuration } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsBasicPutSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsBasicPutSettings+: { restartDelay: restartDelay } },
                },
                '#hlsMediaStoreSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsMediaStoreSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsMediaStoreSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsMediaStoreSettings+: { filecacheDuration: filecacheDuration } },
                  '#withMediaStoreStorageClass':: d.fn(help='', args=[d.arg(name='mediaStoreStorageClass', type=d.T.string)]),
                  withMediaStoreStorageClass(mediaStoreStorageClass): { hlsMediaStoreSettings+: { mediaStoreStorageClass: mediaStoreStorageClass } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsMediaStoreSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsMediaStoreSettings+: { restartDelay: restartDelay } },
                },
                '#hlsS3Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsS3Settings: {
                  '#withCannedAcl':: d.fn(help='"Specify the canned ACL to apply to each S3 request."', args=[d.arg(name='cannedAcl', type=d.T.string)]),
                  withCannedAcl(cannedAcl): { hlsS3Settings+: { cannedAcl: cannedAcl } },
                },
                '#hlsWebdavSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsWebdavSettings: {
                  '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                  withConnectionRetryInterval(connectionRetryInterval): { hlsWebdavSettings+: { connectionRetryInterval: connectionRetryInterval } },
                  '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
                  withFilecacheDuration(filecacheDuration): { hlsWebdavSettings+: { filecacheDuration: filecacheDuration } },
                  '#withHttpTransferMode':: d.fn(help='', args=[d.arg(name='httpTransferMode', type=d.T.string)]),
                  withHttpTransferMode(httpTransferMode): { hlsWebdavSettings+: { httpTransferMode: httpTransferMode } },
                  '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                  withNumRetries(numRetries): { hlsWebdavSettings+: { numRetries: numRetries } },
                  '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
                  withRestartDelay(restartDelay): { hlsWebdavSettings+: { restartDelay: restartDelay } },
                },
              },
              '#keyProviderSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
              keyProviderSettings: {
                '#staticKeySettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                staticKeySettings: {
                  '#keyProviderServer':: d.obj(help=''),
                  keyProviderServer: {
                    '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                    withPasswordParam(passwordParam): { keyProviderServer+: { passwordParam: passwordParam } },
                    '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                    withUri(uri): { keyProviderServer+: { uri: uri } },
                    '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                    withUsername(username): { keyProviderServer+: { username: username } },
                  },
                  '#withStaticKeyValue':: d.fn(help='', args=[d.arg(name='staticKeyValue', type=d.T.string)]),
                  withStaticKeyValue(staticKeyValue): { staticKeyValue: staticKeyValue },
                },
                '#withStaticKeySettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='staticKeySettings', type=d.T.array)]),
                withStaticKeySettings(staticKeySettings): { outputGroupSettings+: { hlsGroupSettings+: { keyProviderSettings+: { staticKeySettings: if std.isArray(v=staticKeySettings) then staticKeySettings else [staticKeySettings] } } } },
                '#withStaticKeySettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='staticKeySettings', type=d.T.array)]),
                withStaticKeySettingsMixin(staticKeySettings): { outputGroupSettings+: { hlsGroupSettings+: { keyProviderSettings+: { staticKeySettings+: if std.isArray(v=staticKeySettings) then staticKeySettings else [staticKeySettings] } } } },
              },
              '#withAdMarkers':: d.fn(help='"The ad marker type for this output group."', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkers(adMarkers): { outputGroupSettings+: { hlsGroupSettings+: { adMarkers: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAdMarkersMixin':: d.fn(help='"The ad marker type for this output group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkersMixin(adMarkers): { outputGroupSettings+: { hlsGroupSettings+: { adMarkers+: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withBaseUrlContent':: d.fn(help='', args=[d.arg(name='baseUrlContent', type=d.T.string)]),
              withBaseUrlContent(baseUrlContent): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlContent: baseUrlContent } } },
              '#withBaseUrlContent1':: d.fn(help='', args=[d.arg(name='baseUrlContent1', type=d.T.string)]),
              withBaseUrlContent1(baseUrlContent1): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlContent1: baseUrlContent1 } } },
              '#withBaseUrlManifest':: d.fn(help='', args=[d.arg(name='baseUrlManifest', type=d.T.string)]),
              withBaseUrlManifest(baseUrlManifest): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlManifest: baseUrlManifest } } },
              '#withBaseUrlManifest1':: d.fn(help='', args=[d.arg(name='baseUrlManifest1', type=d.T.string)]),
              withBaseUrlManifest1(baseUrlManifest1): { outputGroupSettings+: { hlsGroupSettings+: { baseUrlManifest1: baseUrlManifest1 } } },
              '#withCaptionLanguageMappings':: d.fn(help='', args=[d.arg(name='captionLanguageMappings', type=d.T.array)]),
              withCaptionLanguageMappings(captionLanguageMappings): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageMappings: if std.isArray(v=captionLanguageMappings) then captionLanguageMappings else [captionLanguageMappings] } } },
              '#withCaptionLanguageMappingsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionLanguageMappings', type=d.T.array)]),
              withCaptionLanguageMappingsMixin(captionLanguageMappings): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageMappings+: if std.isArray(v=captionLanguageMappings) then captionLanguageMappings else [captionLanguageMappings] } } },
              '#withCaptionLanguageSetting':: d.fn(help='', args=[d.arg(name='captionLanguageSetting', type=d.T.string)]),
              withCaptionLanguageSetting(captionLanguageSetting): { outputGroupSettings+: { hlsGroupSettings+: { captionLanguageSetting: captionLanguageSetting } } },
              '#withClientCache':: d.fn(help='', args=[d.arg(name='clientCache', type=d.T.string)]),
              withClientCache(clientCache): { outputGroupSettings+: { hlsGroupSettings+: { clientCache: clientCache } } },
              '#withCodecSpecification':: d.fn(help='', args=[d.arg(name='codecSpecification', type=d.T.string)]),
              withCodecSpecification(codecSpecification): { outputGroupSettings+: { hlsGroupSettings+: { codecSpecification: codecSpecification } } },
              '#withConstantIv':: d.fn(help='', args=[d.arg(name='constantIv', type=d.T.string)]),
              withConstantIv(constantIv): { outputGroupSettings+: { hlsGroupSettings+: { constantIv: constantIv } } },
              '#withDirectoryStructure':: d.fn(help='', args=[d.arg(name='directoryStructure', type=d.T.string)]),
              withDirectoryStructure(directoryStructure): { outputGroupSettings+: { hlsGroupSettings+: { directoryStructure: directoryStructure } } },
              '#withDiscontinuityTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='discontinuityTags', type=d.T.string)]),
              withDiscontinuityTags(discontinuityTags): { outputGroupSettings+: { hlsGroupSettings+: { discontinuityTags: discontinuityTags } } },
              '#withEncryptionType':: d.fn(help='', args=[d.arg(name='encryptionType', type=d.T.string)]),
              withEncryptionType(encryptionType): { outputGroupSettings+: { hlsGroupSettings+: { encryptionType: encryptionType } } },
              '#withHlsCdnSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='hlsCdnSettings', type=d.T.array)]),
              withHlsCdnSettings(hlsCdnSettings): { outputGroupSettings+: { hlsGroupSettings+: { hlsCdnSettings: if std.isArray(v=hlsCdnSettings) then hlsCdnSettings else [hlsCdnSettings] } } },
              '#withHlsCdnSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hlsCdnSettings', type=d.T.array)]),
              withHlsCdnSettingsMixin(hlsCdnSettings): { outputGroupSettings+: { hlsGroupSettings+: { hlsCdnSettings+: if std.isArray(v=hlsCdnSettings) then hlsCdnSettings else [hlsCdnSettings] } } },
              '#withHlsId3SegmentTagging':: d.fn(help='', args=[d.arg(name='hlsId3SegmentTagging', type=d.T.string)]),
              withHlsId3SegmentTagging(hlsId3SegmentTagging): { outputGroupSettings+: { hlsGroupSettings+: { hlsId3SegmentTagging: hlsId3SegmentTagging } } },
              '#withIframeOnlyPlaylists':: d.fn(help='', args=[d.arg(name='iframeOnlyPlaylists', type=d.T.string)]),
              withIframeOnlyPlaylists(iframeOnlyPlaylists): { outputGroupSettings+: { hlsGroupSettings+: { iframeOnlyPlaylists: iframeOnlyPlaylists } } },
              '#withIncompleteSegmentBehavior':: d.fn(help='', args=[d.arg(name='incompleteSegmentBehavior', type=d.T.string)]),
              withIncompleteSegmentBehavior(incompleteSegmentBehavior): { outputGroupSettings+: { hlsGroupSettings+: { incompleteSegmentBehavior: incompleteSegmentBehavior } } },
              '#withIndexNSegments':: d.fn(help='', args=[d.arg(name='indexNSegments', type=d.T.number)]),
              withIndexNSegments(indexNSegments): { outputGroupSettings+: { hlsGroupSettings+: { indexNSegments: indexNSegments } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { hlsGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withIvInManifest':: d.fn(help='', args=[d.arg(name='ivInManifest', type=d.T.string)]),
              withIvInManifest(ivInManifest): { outputGroupSettings+: { hlsGroupSettings+: { ivInManifest: ivInManifest } } },
              '#withIvSource':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='ivSource', type=d.T.string)]),
              withIvSource(ivSource): { outputGroupSettings+: { hlsGroupSettings+: { ivSource: ivSource } } },
              '#withKeepSegments':: d.fn(help='', args=[d.arg(name='keepSegments', type=d.T.number)]),
              withKeepSegments(keepSegments): { outputGroupSettings+: { hlsGroupSettings+: { keepSegments: keepSegments } } },
              '#withKeyFormat':: d.fn(help='', args=[d.arg(name='keyFormat', type=d.T.string)]),
              withKeyFormat(keyFormat): { outputGroupSettings+: { hlsGroupSettings+: { keyFormat: keyFormat } } },
              '#withKeyFormatVersions':: d.fn(help='', args=[d.arg(name='keyFormatVersions', type=d.T.string)]),
              withKeyFormatVersions(keyFormatVersions): { outputGroupSettings+: { hlsGroupSettings+: { keyFormatVersions: keyFormatVersions } } },
              '#withManifestCompression':: d.fn(help='', args=[d.arg(name='manifestCompression', type=d.T.string)]),
              withManifestCompression(manifestCompression): { outputGroupSettings+: { hlsGroupSettings+: { manifestCompression: manifestCompression } } },
              '#withManifestDurationFormat':: d.fn(help='', args=[d.arg(name='manifestDurationFormat', type=d.T.string)]),
              withManifestDurationFormat(manifestDurationFormat): { outputGroupSettings+: { hlsGroupSettings+: { manifestDurationFormat: manifestDurationFormat } } },
              '#withMinSegmentLength':: d.fn(help='', args=[d.arg(name='minSegmentLength', type=d.T.number)]),
              withMinSegmentLength(minSegmentLength): { outputGroupSettings+: { hlsGroupSettings+: { minSegmentLength: minSegmentLength } } },
              '#withMode':: d.fn(help='', args=[d.arg(name='mode', type=d.T.string)]),
              withMode(mode): { outputGroupSettings+: { hlsGroupSettings+: { mode: mode } } },
              '#withOutputSelection':: d.fn(help='', args=[d.arg(name='outputSelection', type=d.T.string)]),
              withOutputSelection(outputSelection): { outputGroupSettings+: { hlsGroupSettings+: { outputSelection: outputSelection } } },
              '#withProgramDateTime':: d.fn(help='', args=[d.arg(name='programDateTime', type=d.T.string)]),
              withProgramDateTime(programDateTime): { outputGroupSettings+: { hlsGroupSettings+: { programDateTime: programDateTime } } },
              '#withProgramDateTimeClock':: d.fn(help='', args=[d.arg(name='programDateTimeClock', type=d.T.string)]),
              withProgramDateTimeClock(programDateTimeClock): { outputGroupSettings+: { hlsGroupSettings+: { programDateTimeClock: programDateTimeClock } } },
              '#withProgramDateTimePeriod':: d.fn(help='', args=[d.arg(name='programDateTimePeriod', type=d.T.number)]),
              withProgramDateTimePeriod(programDateTimePeriod): { outputGroupSettings+: { hlsGroupSettings+: { programDateTimePeriod: programDateTimePeriod } } },
              '#withRedundantManifest':: d.fn(help='', args=[d.arg(name='redundantManifest', type=d.T.string)]),
              withRedundantManifest(redundantManifest): { outputGroupSettings+: { hlsGroupSettings+: { redundantManifest: redundantManifest } } },
              '#withSegmentLength':: d.fn(help='', args=[d.arg(name='segmentLength', type=d.T.number)]),
              withSegmentLength(segmentLength): { outputGroupSettings+: { hlsGroupSettings+: { segmentLength: segmentLength } } },
              '#withSegmentsPerSubdirectory':: d.fn(help='', args=[d.arg(name='segmentsPerSubdirectory', type=d.T.number)]),
              withSegmentsPerSubdirectory(segmentsPerSubdirectory): { outputGroupSettings+: { hlsGroupSettings+: { segmentsPerSubdirectory: segmentsPerSubdirectory } } },
              '#withStreamInfResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='streamInfResolution', type=d.T.string)]),
              withStreamInfResolution(streamInfResolution): { outputGroupSettings+: { hlsGroupSettings+: { streamInfResolution: streamInfResolution } } },
              '#withTimedMetadataId3Frame':: d.fn(help='"Indicates ID3 frame that has the timecode."', args=[d.arg(name='timedMetadataId3Frame', type=d.T.string)]),
              withTimedMetadataId3Frame(timedMetadataId3Frame): { outputGroupSettings+: { hlsGroupSettings+: { timedMetadataId3Frame: timedMetadataId3Frame } } },
              '#withTimedMetadataId3Period':: d.fn(help='', args=[d.arg(name='timedMetadataId3Period', type=d.T.number)]),
              withTimedMetadataId3Period(timedMetadataId3Period): { outputGroupSettings+: { hlsGroupSettings+: { timedMetadataId3Period: timedMetadataId3Period } } },
              '#withTimestampDeltaMilliseconds':: d.fn(help='', args=[d.arg(name='timestampDeltaMilliseconds', type=d.T.number)]),
              withTimestampDeltaMilliseconds(timestampDeltaMilliseconds): { outputGroupSettings+: { hlsGroupSettings+: { timestampDeltaMilliseconds: timestampDeltaMilliseconds } } },
              '#withTsFileMode':: d.fn(help='', args=[d.arg(name='tsFileMode', type=d.T.string)]),
              withTsFileMode(tsFileMode): { outputGroupSettings+: { hlsGroupSettings+: { tsFileMode: tsFileMode } } },
            },
            '#mediaPackageGroupSettings':: d.obj(help='"Media package group settings. See Media Package Group Settings for more details."'),
            mediaPackageGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { mediaPackageGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
            },
            '#msSmoothGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            msSmoothGroupSettings: {
              '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
              destination: {
                '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                withDestinationRefId(destinationRefId): { outputGroupSettings+: { msSmoothGroupSettings+: { destination+: { destinationRefId: destinationRefId } } } },
              },
              '#withAcquisitionPointId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='acquisitionPointId', type=d.T.string)]),
              withAcquisitionPointId(acquisitionPointId): { outputGroupSettings+: { msSmoothGroupSettings+: { acquisitionPointId: acquisitionPointId } } },
              '#withAudioOnlyTimecodeControl':: d.fn(help='', args=[d.arg(name='audioOnlyTimecodeControl', type=d.T.string)]),
              withAudioOnlyTimecodeControl(audioOnlyTimecodeControl): { outputGroupSettings+: { msSmoothGroupSettings+: { audioOnlyTimecodeControl: audioOnlyTimecodeControl } } },
              '#withCertificateMode':: d.fn(help='"Setting to allow self signed or verified RTMP certificates."', args=[d.arg(name='certificateMode', type=d.T.string)]),
              withCertificateMode(certificateMode): { outputGroupSettings+: { msSmoothGroupSettings+: { certificateMode: certificateMode } } },
              '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
              withConnectionRetryInterval(connectionRetryInterval): { outputGroupSettings+: { msSmoothGroupSettings+: { connectionRetryInterval: connectionRetryInterval } } },
              '#withEventId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='eventId', type=d.T.string)]),
              withEventId(eventId): { outputGroupSettings+: { msSmoothGroupSettings+: { eventId: eventId } } },
              '#withEventIdMode':: d.fn(help='', args=[d.arg(name='eventIdMode', type=d.T.string)]),
              withEventIdMode(eventIdMode): { outputGroupSettings+: { msSmoothGroupSettings+: { eventIdMode: eventIdMode } } },
              '#withEventStopBehavior':: d.fn(help='', args=[d.arg(name='eventStopBehavior', type=d.T.string)]),
              withEventStopBehavior(eventStopBehavior): { outputGroupSettings+: { msSmoothGroupSettings+: { eventStopBehavior: eventStopBehavior } } },
              '#withFilecacheDuration':: d.fn(help='', args=[d.arg(name='filecacheDuration', type=d.T.number)]),
              withFilecacheDuration(filecacheDuration): { outputGroupSettings+: { msSmoothGroupSettings+: { filecacheDuration: filecacheDuration } } },
              '#withFragmentLength':: d.fn(help='', args=[d.arg(name='fragmentLength', type=d.T.number)]),
              withFragmentLength(fragmentLength): { outputGroupSettings+: { msSmoothGroupSettings+: { fragmentLength: fragmentLength } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { msSmoothGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
              withNumRetries(numRetries): { outputGroupSettings+: { msSmoothGroupSettings+: { numRetries: numRetries } } },
              '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
              withRestartDelay(restartDelay): { outputGroupSettings+: { msSmoothGroupSettings+: { restartDelay: restartDelay } } },
              '#withSegmentationMode':: d.fn(help='', args=[d.arg(name='segmentationMode', type=d.T.string)]),
              withSegmentationMode(segmentationMode): { outputGroupSettings+: { msSmoothGroupSettings+: { segmentationMode: segmentationMode } } },
              '#withSendDelayMs':: d.fn(help='', args=[d.arg(name='sendDelayMs', type=d.T.number)]),
              withSendDelayMs(sendDelayMs): { outputGroupSettings+: { msSmoothGroupSettings+: { sendDelayMs: sendDelayMs } } },
              '#withSparseTrackType':: d.fn(help='', args=[d.arg(name='sparseTrackType', type=d.T.string)]),
              withSparseTrackType(sparseTrackType): { outputGroupSettings+: { msSmoothGroupSettings+: { sparseTrackType: sparseTrackType } } },
              '#withStreamManifestBehavior':: d.fn(help='', args=[d.arg(name='streamManifestBehavior', type=d.T.string)]),
              withStreamManifestBehavior(streamManifestBehavior): { outputGroupSettings+: { msSmoothGroupSettings+: { streamManifestBehavior: streamManifestBehavior } } },
              '#withTimestampOffset':: d.fn(help='', args=[d.arg(name='timestampOffset', type=d.T.string)]),
              withTimestampOffset(timestampOffset): { outputGroupSettings+: { msSmoothGroupSettings+: { timestampOffset: timestampOffset } } },
              '#withTimestampOffsetMode':: d.fn(help='', args=[d.arg(name='timestampOffsetMode', type=d.T.string)]),
              withTimestampOffsetMode(timestampOffsetMode): { outputGroupSettings+: { msSmoothGroupSettings+: { timestampOffsetMode: timestampOffsetMode } } },
            },
            '#rtmpGroupSettings':: d.obj(help='"RTMP group settings. See RTMP Group Settings for more details."'),
            rtmpGroupSettings: {
              '#withAdMarkers':: d.fn(help='"The ad marker type for this output group."', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkers(adMarkers): { outputGroupSettings+: { rtmpGroupSettings+: { adMarkers: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAdMarkersMixin':: d.fn(help='"The ad marker type for this output group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='adMarkers', type=d.T.array)]),
              withAdMarkersMixin(adMarkers): { outputGroupSettings+: { rtmpGroupSettings+: { adMarkers+: if std.isArray(v=adMarkers) then adMarkers else [adMarkers] } } },
              '#withAuthenticationScheme':: d.fn(help='"Authentication scheme to use when connecting with CDN."', args=[d.arg(name='authenticationScheme', type=d.T.string)]),
              withAuthenticationScheme(authenticationScheme): { outputGroupSettings+: { rtmpGroupSettings+: { authenticationScheme: authenticationScheme } } },
              '#withCacheFullBehavior':: d.fn(help='"Controls behavior when content cache fills up."', args=[d.arg(name='cacheFullBehavior', type=d.T.string)]),
              withCacheFullBehavior(cacheFullBehavior): { outputGroupSettings+: { rtmpGroupSettings+: { cacheFullBehavior: cacheFullBehavior } } },
              '#withCacheLength':: d.fn(help='"Cache length in seconds, is used to calculate buffer size."', args=[d.arg(name='cacheLength', type=d.T.number)]),
              withCacheLength(cacheLength): { outputGroupSettings+: { rtmpGroupSettings+: { cacheLength: cacheLength } } },
              '#withCaptionData':: d.fn(help='"Controls the types of data that passes to onCaptionInfo outputs."', args=[d.arg(name='captionData', type=d.T.string)]),
              withCaptionData(captionData): { outputGroupSettings+: { rtmpGroupSettings+: { captionData: captionData } } },
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { rtmpGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withRestartDelay':: d.fn(help='"Number of seconds to wait until a restart is initiated."', args=[d.arg(name='restartDelay', type=d.T.number)]),
              withRestartDelay(restartDelay): { outputGroupSettings+: { rtmpGroupSettings+: { restartDelay: restartDelay } } },
            },
            '#udpGroupSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            udpGroupSettings: {
              '#withInputLossAction':: d.fn(help='"Controls the behavior of the RTMP group if input becomes unavailable."', args=[d.arg(name='inputLossAction', type=d.T.string)]),
              withInputLossAction(inputLossAction): { outputGroupSettings+: { udpGroupSettings+: { inputLossAction: inputLossAction } } },
              '#withTimedMetadataId3Frame':: d.fn(help='"Indicates ID3 frame that has the timecode."', args=[d.arg(name='timedMetadataId3Frame', type=d.T.string)]),
              withTimedMetadataId3Frame(timedMetadataId3Frame): { outputGroupSettings+: { udpGroupSettings+: { timedMetadataId3Frame: timedMetadataId3Frame } } },
              '#withTimedMetadataId3Period':: d.fn(help='', args=[d.arg(name='timedMetadataId3Period', type=d.T.number)]),
              withTimedMetadataId3Period(timedMetadataId3Period): { outputGroupSettings+: { udpGroupSettings+: { timedMetadataId3Period: timedMetadataId3Period } } },
            },
            '#withArchiveGroupSettings':: d.fn(help='"Archive group settings. See Archive Group Settings for more details."', args=[d.arg(name='archiveGroupSettings', type=d.T.array)]),
            withArchiveGroupSettings(archiveGroupSettings): { outputGroupSettings+: { archiveGroupSettings: if std.isArray(v=archiveGroupSettings) then archiveGroupSettings else [archiveGroupSettings] } },
            '#withArchiveGroupSettingsMixin':: d.fn(help='"Archive group settings. See Archive Group Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='archiveGroupSettings', type=d.T.array)]),
            withArchiveGroupSettingsMixin(archiveGroupSettings): { outputGroupSettings+: { archiveGroupSettings+: if std.isArray(v=archiveGroupSettings) then archiveGroupSettings else [archiveGroupSettings] } },
            '#withMultiplexGroupSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='multiplexGroupSettings', type=d.T.object)]),
            withMultiplexGroupSettings(multiplexGroupSettings): { outputGroupSettings+: { multiplexGroupSettings: multiplexGroupSettings } },
            '#withMultiplexGroupSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='multiplexGroupSettings', type=d.T.object)]),
            withMultiplexGroupSettingsMixin(multiplexGroupSettings): { outputGroupSettings+: { multiplexGroupSettings+: multiplexGroupSettings } },
          },
          '#outputs':: d.obj(help='"List of outputs. See Outputs for more details."'),
          outputs: {
            '#outputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
            outputSettings: {
              '#archiveOutputSettings':: d.obj(help='"Archive output settings. See Archive Output Settings for more details."'),
              archiveOutputSettings: {
                '#containerSettings':: d.obj(help='"Settings specific to the container type of the file. See Container Settings for more details."'),
                containerSettings: {
                  '#m2tsSettings':: d.obj(help='"M2TS Settings. See M2TS Settings for more details."'),
                  m2tsSettings: {
                    '#dvbNitSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbNitSettings: {
                      '#withNetworkId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='networkId', type=d.T.number)]),
                      withNetworkId(networkId): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkId: networkId } } } } } },
                      '#withNetworkName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='networkName', type=d.T.string)]),
                      withNetworkName(networkName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkName: networkName } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#dvbSdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbSdtSettings: {
                      '#withOutputSdt':: d.fn(help='', args=[d.arg(name='outputSdt', type=d.T.string)]),
                      withOutputSdt(outputSdt): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { outputSdt: outputSdt } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { repInterval: repInterval } } } } } },
                      '#withServiceName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceName', type=d.T.string)]),
                      withServiceName(serviceName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceName: serviceName } } } } } },
                      '#withServiceProviderName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceProviderName', type=d.T.string)]),
                      withServiceProviderName(serviceProviderName): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceProviderName: serviceProviderName } } } } } },
                    },
                    '#dvbTdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbTdtSettings: {
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTdtSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#withAbsentInputAudioBehavior':: d.fn(help='', args=[d.arg(name='absentInputAudioBehavior', type=d.T.string)]),
                    withAbsentInputAudioBehavior(absentInputAudioBehavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { absentInputAudioBehavior: absentInputAudioBehavior } } } } },
                    '#withArib':: d.fn(help='', args=[d.arg(name='arib', type=d.T.string)]),
                    withArib(arib): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { arib: arib } } } } },
                    '#withAribCaptionsPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='aribCaptionsPid', type=d.T.string)]),
                    withAribCaptionsPid(aribCaptionsPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPid: aribCaptionsPid } } } } },
                    '#withAribCaptionsPidControl':: d.fn(help='', args=[d.arg(name='aribCaptionsPidControl', type=d.T.string)]),
                    withAribCaptionsPidControl(aribCaptionsPidControl): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPidControl: aribCaptionsPidControl } } } } },
                    '#withAudioBufferModel':: d.fn(help='', args=[d.arg(name='audioBufferModel', type=d.T.string)]),
                    withAudioBufferModel(audioBufferModel): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioBufferModel: audioBufferModel } } } } },
                    '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                    withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioFramesPerPes: audioFramesPerPes } } } } },
                    '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                    withAudioPids(audioPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioPids: audioPids } } } } },
                    '#withAudioStreamType':: d.fn(help='', args=[d.arg(name='audioStreamType', type=d.T.string)]),
                    withAudioStreamType(audioStreamType): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { audioStreamType: audioStreamType } } } } },
                    '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
                    withBitrate(bitrate): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { bitrate: bitrate } } } } },
                    '#withBufferModel':: d.fn(help='', args=[d.arg(name='bufferModel', type=d.T.string)]),
                    withBufferModel(bufferModel): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { bufferModel: bufferModel } } } } },
                    '#withCcDescriptor':: d.fn(help='', args=[d.arg(name='ccDescriptor', type=d.T.string)]),
                    withCcDescriptor(ccDescriptor): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ccDescriptor: ccDescriptor } } } } },
                    '#withDvbSubPids':: d.fn(help='', args=[d.arg(name='dvbSubPids', type=d.T.string)]),
                    withDvbSubPids(dvbSubPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSubPids: dvbSubPids } } } } },
                    '#withDvbTeletextPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='dvbTeletextPid', type=d.T.string)]),
                    withDvbTeletextPid(dvbTeletextPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTeletextPid: dvbTeletextPid } } } } },
                    '#withEbif':: d.fn(help='', args=[d.arg(name='ebif', type=d.T.string)]),
                    withEbif(ebif): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebif: ebif } } } } },
                    '#withEbpAudioInterval':: d.fn(help='', args=[d.arg(name='ebpAudioInterval', type=d.T.string)]),
                    withEbpAudioInterval(ebpAudioInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpAudioInterval: ebpAudioInterval } } } } },
                    '#withEbpLookaheadMs':: d.fn(help='', args=[d.arg(name='ebpLookaheadMs', type=d.T.number)]),
                    withEbpLookaheadMs(ebpLookaheadMs): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpLookaheadMs: ebpLookaheadMs } } } } },
                    '#withEbpPlacement':: d.fn(help='', args=[d.arg(name='ebpPlacement', type=d.T.string)]),
                    withEbpPlacement(ebpPlacement): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpPlacement: ebpPlacement } } } } },
                    '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                    withEcmPid(ecmPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { ecmPid: ecmPid } } } } },
                    '#withEsRateInPes':: d.fn(help='', args=[d.arg(name='esRateInPes', type=d.T.string)]),
                    withEsRateInPes(esRateInPes): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { esRateInPes: esRateInPes } } } } },
                    '#withEtvPlatformPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvPlatformPid', type=d.T.string)]),
                    withEtvPlatformPid(etvPlatformPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { etvPlatformPid: etvPlatformPid } } } } },
                    '#withEtvSignalPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvSignalPid', type=d.T.string)]),
                    withEtvSignalPid(etvSignalPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { etvSignalPid: etvSignalPid } } } } },
                    '#withFragmentTime':: d.fn(help='', args=[d.arg(name='fragmentTime', type=d.T.number)]),
                    withFragmentTime(fragmentTime): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { fragmentTime: fragmentTime } } } } },
                    '#withKlv':: d.fn(help='', args=[d.arg(name='klv', type=d.T.string)]),
                    withKlv(klv): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { klv: klv } } } } },
                    '#withKlvDataPids':: d.fn(help='', args=[d.arg(name='klvDataPids', type=d.T.string)]),
                    withKlvDataPids(klvDataPids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { klvDataPids: klvDataPids } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withNullPacketBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='nullPacketBitrate', type=d.T.number)]),
                    withNullPacketBitrate(nullPacketBitrate): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { nullPacketBitrate: nullPacketBitrate } } } } },
                    '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                    withPatInterval(patInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { patInterval: patInterval } } } } },
                    '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                    withPcrControl(pcrControl): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrControl: pcrControl } } } } },
                    '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                    withPcrPeriod(pcrPeriod): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPeriod: pcrPeriod } } } } },
                    '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                    withPcrPid(pcrPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPid: pcrPid } } } } },
                    '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                    withPmtInterval(pmtInterval): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtInterval: pmtInterval } } } } },
                    '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                    withPmtPid(pmtPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtPid: pmtPid } } } } },
                    '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                    withProgramNum(programNum): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { programNum: programNum } } } } },
                    '#withRateMode':: d.fn(help='', args=[d.arg(name='rateMode', type=d.T.string)]),
                    withRateMode(rateMode): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { rateMode: rateMode } } } } },
                    '#withScte27Pids':: d.fn(help='', args=[d.arg(name='scte27Pids', type=d.T.string)]),
                    withScte27Pids(scte27Pids): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte27Pids: scte27Pids } } } } },
                    '#withScte35Control':: d.fn(help='', args=[d.arg(name='scte35Control', type=d.T.string)]),
                    withScte35Control(scte35Control): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Control: scte35Control } } } } },
                    '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                    withScte35Pid(scte35Pid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Pid: scte35Pid } } } } },
                    '#withSegmentationMarkers':: d.fn(help='', args=[d.arg(name='segmentationMarkers', type=d.T.string)]),
                    withSegmentationMarkers(segmentationMarkers): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationMarkers: segmentationMarkers } } } } },
                    '#withSegmentationStyle':: d.fn(help='', args=[d.arg(name='segmentationStyle', type=d.T.string)]),
                    withSegmentationStyle(segmentationStyle): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationStyle: segmentationStyle } } } } },
                    '#withSegmentationTime':: d.fn(help='', args=[d.arg(name='segmentationTime', type=d.T.number)]),
                    withSegmentationTime(segmentationTime): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationTime: segmentationTime } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                    '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                    withTimedMetadataPid(timedMetadataPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataPid: timedMetadataPid } } } } },
                    '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                    withTransportStreamId(transportStreamId): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { transportStreamId: transportStreamId } } } } },
                    '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                    withVideoPid(videoPid): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { m2tsSettings+: { videoPid: videoPid } } } } },
                  },
                  '#withRawSettings':: d.fn(help='"Raw Settings. This can be set as an empty block."', args=[d.arg(name='rawSettings', type=d.T.object)]),
                  withRawSettings(rawSettings): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { rawSettings: rawSettings } } } },
                  '#withRawSettingsMixin':: d.fn(help='"Raw Settings. This can be set as an empty block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rawSettings', type=d.T.object)]),
                  withRawSettingsMixin(rawSettings): { outputSettings+: { archiveOutputSettings+: { containerSettings+: { rawSettings+: rawSettings } } } },
                },
                '#withExtension':: d.fn(help='"Output file extension."', args=[d.arg(name='extension', type=d.T.string)]),
                withExtension(extension): { outputSettings+: { archiveOutputSettings+: { extension: extension } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { archiveOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#frameCaptureOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              frameCaptureOutputSettings: {
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { frameCaptureOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#hlsOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              hlsOutputSettings: {
                '#hlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                hlsSettings: {
                  '#audioOnlyHlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  audioOnlyHlsSettings: {
                    '#audioOnlyImage':: d.obj(help=''),
                    audioOnlyImage: {
                      '#withPasswordParam':: d.fn(help='"Key used to extract the password from EC2 Parameter store."', args=[d.arg(name='passwordParam', type=d.T.string)]),
                      withPasswordParam(passwordParam): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { passwordParam: passwordParam } } } } } },
                      '#withUri':: d.fn(help='"Path to a file accessible to the live stream."', args=[d.arg(name='uri', type=d.T.string)]),
                      withUri(uri): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { uri: uri } } } } } },
                      '#withUsername':: d.fn(help='"Username for destination."', args=[d.arg(name='username', type=d.T.string)]),
                      withUsername(username): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioOnlyImage+: { username: username } } } } } },
                    },
                    '#withAudioGroupId':: d.fn(help='"Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition."', args=[d.arg(name='audioGroupId', type=d.T.string)]),
                    withAudioGroupId(audioGroupId): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioGroupId: audioGroupId } } } } },
                    '#withAudioTrackType':: d.fn(help='', args=[d.arg(name='audioTrackType', type=d.T.string)]),
                    withAudioTrackType(audioTrackType): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { audioTrackType: audioTrackType } } } } },
                    '#withSegmentType':: d.fn(help='', args=[d.arg(name='segmentType', type=d.T.string)]),
                    withSegmentType(segmentType): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { audioOnlyHlsSettings+: { segmentType: segmentType } } } } },
                  },
                  '#fmp4HlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  fmp4HlsSettings: {
                    '#withAudioRenditionSets':: d.fn(help='', args=[d.arg(name='audioRenditionSets', type=d.T.string)]),
                    withAudioRenditionSets(audioRenditionSets): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { audioRenditionSets: audioRenditionSets } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { fmp4HlsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                  },
                  '#standardHlsSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                  standardHlsSettings: {
                    '#m3u8Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    m3u8Settings: {
                      '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                      withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { audioFramesPerPes: audioFramesPerPes } } } } } },
                      '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                      withAudioPids(audioPids): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { audioPids: audioPids } } } } } },
                      '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                      withEcmPid(ecmPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { ecmPid: ecmPid } } } } } },
                      '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                      withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { nielsenId3Behavior: nielsenId3Behavior } } } } } },
                      '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                      withPatInterval(patInterval): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { patInterval: patInterval } } } } } },
                      '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                      withPcrControl(pcrControl): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrControl: pcrControl } } } } } },
                      '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                      withPcrPeriod(pcrPeriod): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrPeriod: pcrPeriod } } } } } },
                      '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                      withPcrPid(pcrPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pcrPid: pcrPid } } } } } },
                      '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                      withPmtInterval(pmtInterval): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pmtInterval: pmtInterval } } } } } },
                      '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                      withPmtPid(pmtPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { pmtPid: pmtPid } } } } } },
                      '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                      withProgramNum(programNum): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { programNum: programNum } } } } } },
                      '#withScte35Behavior':: d.fn(help='', args=[d.arg(name='scte35Behavior', type=d.T.string)]),
                      withScte35Behavior(scte35Behavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { scte35Behavior: scte35Behavior } } } } } },
                      '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                      withScte35Pid(scte35Pid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { scte35Pid: scte35Pid } } } } } },
                      '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                      withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { timedMetadataBehavior: timedMetadataBehavior } } } } } },
                      '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                      withTimedMetadataPid(timedMetadataPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { timedMetadataPid: timedMetadataPid } } } } } },
                      '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                      withTransportStreamId(transportStreamId): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { transportStreamId: transportStreamId } } } } } },
                      '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                      withVideoPid(videoPid): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { m3u8Settings+: { videoPid: videoPid } } } } } },
                    },
                    '#withAudioRenditionSets':: d.fn(help='', args=[d.arg(name='audioRenditionSets', type=d.T.string)]),
                    withAudioRenditionSets(audioRenditionSets): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { standardHlsSettings+: { audioRenditionSets: audioRenditionSets } } } } },
                  },
                  '#withFrameCaptureHlsSettings':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."', args=[d.arg(name='frameCaptureHlsSettings', type=d.T.object)]),
                  withFrameCaptureHlsSettings(frameCaptureHlsSettings): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { frameCaptureHlsSettings: frameCaptureHlsSettings } } } },
                  '#withFrameCaptureHlsSettingsMixin':: d.fn(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='frameCaptureHlsSettings', type=d.T.object)]),
                  withFrameCaptureHlsSettingsMixin(frameCaptureHlsSettings): { outputSettings+: { hlsOutputSettings+: { hlsSettings+: { frameCaptureHlsSettings+: frameCaptureHlsSettings } } } },
                },
                '#withH265PackagingType':: d.fn(help='', args=[d.arg(name='h265PackagingType', type=d.T.string)]),
                withH265PackagingType(h265PackagingType): { outputSettings+: { hlsOutputSettings+: { h265PackagingType: h265PackagingType } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { hlsOutputSettings+: { nameModifier: nameModifier } } },
                '#withSegmentModifier':: d.fn(help='', args=[d.arg(name='segmentModifier', type=d.T.string)]),
                withSegmentModifier(segmentModifier): { outputSettings+: { hlsOutputSettings+: { segmentModifier: segmentModifier } } },
              },
              '#msSmoothOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
              msSmoothOutputSettings: {
                '#withH265PackagingType':: d.fn(help='', args=[d.arg(name='h265PackagingType', type=d.T.string)]),
                withH265PackagingType(h265PackagingType): { outputSettings+: { msSmoothOutputSettings+: { h265PackagingType: h265PackagingType } } },
                '#withNameModifier':: d.fn(help='"String concatenated to the end of the destination filename. Required for multiple outputs of the same type."', args=[d.arg(name='nameModifier', type=d.T.string)]),
                withNameModifier(nameModifier): { outputSettings+: { msSmoothOutputSettings+: { nameModifier: nameModifier } } },
              },
              '#multiplexOutputSettings':: d.obj(help='"Multiplex output settings. See Multiplex Output Settings for more details."'),
              multiplexOutputSettings: {
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { multiplexOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
              },
              '#rtmpOutputSettings':: d.obj(help='"RTMP output settings. See RTMP Output Settings for more details."'),
              rtmpOutputSettings: {
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { rtmpOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
                '#withCertificateMode':: d.fn(help='"Setting to allow self signed or verified RTMP certificates."', args=[d.arg(name='certificateMode', type=d.T.string)]),
                withCertificateMode(certificateMode): { outputSettings+: { rtmpOutputSettings+: { certificateMode: certificateMode } } },
                '#withConnectionRetryInterval':: d.fn(help='"Number of seconds to wait before retrying connection to the flash media server if the connection is lost."', args=[d.arg(name='connectionRetryInterval', type=d.T.number)]),
                withConnectionRetryInterval(connectionRetryInterval): { outputSettings+: { rtmpOutputSettings+: { connectionRetryInterval: connectionRetryInterval } } },
                '#withNumRetries':: d.fn(help='"Number of retry attempts."', args=[d.arg(name='numRetries', type=d.T.number)]),
                withNumRetries(numRetries): { outputSettings+: { rtmpOutputSettings+: { numRetries: numRetries } } },
              },
              '#udpOutputSettings':: d.obj(help='"UDP output settings. See UDP Output Settings for more details."'),
              udpOutputSettings: {
                '#containerSettings':: d.obj(help='"Settings specific to the container type of the file. See Container Settings for more details."'),
                containerSettings: {
                  '#m2tsSettings':: d.obj(help='"M2TS Settings. See M2TS Settings for more details."'),
                  m2tsSettings: {
                    '#dvbNitSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbNitSettings: {
                      '#withNetworkId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='networkId', type=d.T.number)]),
                      withNetworkId(networkId): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkId: networkId } } } } } },
                      '#withNetworkName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='networkName', type=d.T.string)]),
                      withNetworkName(networkName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { networkName: networkName } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbNitSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#dvbSdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbSdtSettings: {
                      '#withOutputSdt':: d.fn(help='', args=[d.arg(name='outputSdt', type=d.T.string)]),
                      withOutputSdt(outputSdt): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { outputSdt: outputSdt } } } } } },
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { repInterval: repInterval } } } } } },
                      '#withServiceName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceName', type=d.T.string)]),
                      withServiceName(serviceName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceName: serviceName } } } } } },
                      '#withServiceProviderName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='serviceProviderName', type=d.T.string)]),
                      withServiceProviderName(serviceProviderName): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSdtSettings+: { serviceProviderName: serviceProviderName } } } } } },
                    },
                    '#dvbTdtSettings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
                    dvbTdtSettings: {
                      '#withRepInterval':: d.fn(help='', args=[d.arg(name='repInterval', type=d.T.number)]),
                      withRepInterval(repInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTdtSettings+: { repInterval: repInterval } } } } } },
                    },
                    '#withAbsentInputAudioBehavior':: d.fn(help='', args=[d.arg(name='absentInputAudioBehavior', type=d.T.string)]),
                    withAbsentInputAudioBehavior(absentInputAudioBehavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { absentInputAudioBehavior: absentInputAudioBehavior } } } } },
                    '#withArib':: d.fn(help='', args=[d.arg(name='arib', type=d.T.string)]),
                    withArib(arib): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { arib: arib } } } } },
                    '#withAribCaptionsPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='aribCaptionsPid', type=d.T.string)]),
                    withAribCaptionsPid(aribCaptionsPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPid: aribCaptionsPid } } } } },
                    '#withAribCaptionsPidControl':: d.fn(help='', args=[d.arg(name='aribCaptionsPidControl', type=d.T.string)]),
                    withAribCaptionsPidControl(aribCaptionsPidControl): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { aribCaptionsPidControl: aribCaptionsPidControl } } } } },
                    '#withAudioBufferModel':: d.fn(help='', args=[d.arg(name='audioBufferModel', type=d.T.string)]),
                    withAudioBufferModel(audioBufferModel): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioBufferModel: audioBufferModel } } } } },
                    '#withAudioFramesPerPes':: d.fn(help='', args=[d.arg(name='audioFramesPerPes', type=d.T.number)]),
                    withAudioFramesPerPes(audioFramesPerPes): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioFramesPerPes: audioFramesPerPes } } } } },
                    '#withAudioPids':: d.fn(help='', args=[d.arg(name='audioPids', type=d.T.string)]),
                    withAudioPids(audioPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioPids: audioPids } } } } },
                    '#withAudioStreamType':: d.fn(help='', args=[d.arg(name='audioStreamType', type=d.T.string)]),
                    withAudioStreamType(audioStreamType): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { audioStreamType: audioStreamType } } } } },
                    '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
                    withBitrate(bitrate): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { bitrate: bitrate } } } } },
                    '#withBufferModel':: d.fn(help='', args=[d.arg(name='bufferModel', type=d.T.string)]),
                    withBufferModel(bufferModel): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { bufferModel: bufferModel } } } } },
                    '#withCcDescriptor':: d.fn(help='', args=[d.arg(name='ccDescriptor', type=d.T.string)]),
                    withCcDescriptor(ccDescriptor): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ccDescriptor: ccDescriptor } } } } },
                    '#withDvbSubPids':: d.fn(help='', args=[d.arg(name='dvbSubPids', type=d.T.string)]),
                    withDvbSubPids(dvbSubPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbSubPids: dvbSubPids } } } } },
                    '#withDvbTeletextPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='dvbTeletextPid', type=d.T.string)]),
                    withDvbTeletextPid(dvbTeletextPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { dvbTeletextPid: dvbTeletextPid } } } } },
                    '#withEbif':: d.fn(help='', args=[d.arg(name='ebif', type=d.T.string)]),
                    withEbif(ebif): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebif: ebif } } } } },
                    '#withEbpAudioInterval':: d.fn(help='', args=[d.arg(name='ebpAudioInterval', type=d.T.string)]),
                    withEbpAudioInterval(ebpAudioInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpAudioInterval: ebpAudioInterval } } } } },
                    '#withEbpLookaheadMs':: d.fn(help='', args=[d.arg(name='ebpLookaheadMs', type=d.T.number)]),
                    withEbpLookaheadMs(ebpLookaheadMs): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpLookaheadMs: ebpLookaheadMs } } } } },
                    '#withEbpPlacement':: d.fn(help='', args=[d.arg(name='ebpPlacement', type=d.T.string)]),
                    withEbpPlacement(ebpPlacement): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ebpPlacement: ebpPlacement } } } } },
                    '#withEcmPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='ecmPid', type=d.T.string)]),
                    withEcmPid(ecmPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { ecmPid: ecmPid } } } } },
                    '#withEsRateInPes':: d.fn(help='', args=[d.arg(name='esRateInPes', type=d.T.string)]),
                    withEsRateInPes(esRateInPes): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { esRateInPes: esRateInPes } } } } },
                    '#withEtvPlatformPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvPlatformPid', type=d.T.string)]),
                    withEtvPlatformPid(etvPlatformPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { etvPlatformPid: etvPlatformPid } } } } },
                    '#withEtvSignalPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='etvSignalPid', type=d.T.string)]),
                    withEtvSignalPid(etvSignalPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { etvSignalPid: etvSignalPid } } } } },
                    '#withFragmentTime':: d.fn(help='', args=[d.arg(name='fragmentTime', type=d.T.number)]),
                    withFragmentTime(fragmentTime): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { fragmentTime: fragmentTime } } } } },
                    '#withKlv':: d.fn(help='', args=[d.arg(name='klv', type=d.T.string)]),
                    withKlv(klv): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { klv: klv } } } } },
                    '#withKlvDataPids':: d.fn(help='', args=[d.arg(name='klvDataPids', type=d.T.string)]),
                    withKlvDataPids(klvDataPids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { klvDataPids: klvDataPids } } } } },
                    '#withNielsenId3Behavior':: d.fn(help='', args=[d.arg(name='nielsenId3Behavior', type=d.T.string)]),
                    withNielsenId3Behavior(nielsenId3Behavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { nielsenId3Behavior: nielsenId3Behavior } } } } },
                    '#withNullPacketBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='nullPacketBitrate', type=d.T.number)]),
                    withNullPacketBitrate(nullPacketBitrate): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { nullPacketBitrate: nullPacketBitrate } } } } },
                    '#withPatInterval':: d.fn(help='', args=[d.arg(name='patInterval', type=d.T.number)]),
                    withPatInterval(patInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { patInterval: patInterval } } } } },
                    '#withPcrControl':: d.fn(help='', args=[d.arg(name='pcrControl', type=d.T.string)]),
                    withPcrControl(pcrControl): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrControl: pcrControl } } } } },
                    '#withPcrPeriod':: d.fn(help='', args=[d.arg(name='pcrPeriod', type=d.T.number)]),
                    withPcrPeriod(pcrPeriod): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPeriod: pcrPeriod } } } } },
                    '#withPcrPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pcrPid', type=d.T.string)]),
                    withPcrPid(pcrPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pcrPid: pcrPid } } } } },
                    '#withPmtInterval':: d.fn(help='', args=[d.arg(name='pmtInterval', type=d.T.number)]),
                    withPmtInterval(pmtInterval): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtInterval: pmtInterval } } } } },
                    '#withPmtPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pmtPid', type=d.T.string)]),
                    withPmtPid(pmtPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { pmtPid: pmtPid } } } } },
                    '#withProgramNum':: d.fn(help='', args=[d.arg(name='programNum', type=d.T.number)]),
                    withProgramNum(programNum): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { programNum: programNum } } } } },
                    '#withRateMode':: d.fn(help='', args=[d.arg(name='rateMode', type=d.T.string)]),
                    withRateMode(rateMode): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { rateMode: rateMode } } } } },
                    '#withScte27Pids':: d.fn(help='', args=[d.arg(name='scte27Pids', type=d.T.string)]),
                    withScte27Pids(scte27Pids): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte27Pids: scte27Pids } } } } },
                    '#withScte35Control':: d.fn(help='', args=[d.arg(name='scte35Control', type=d.T.string)]),
                    withScte35Control(scte35Control): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Control: scte35Control } } } } },
                    '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.string)]),
                    withScte35Pid(scte35Pid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { scte35Pid: scte35Pid } } } } },
                    '#withSegmentationMarkers':: d.fn(help='', args=[d.arg(name='segmentationMarkers', type=d.T.string)]),
                    withSegmentationMarkers(segmentationMarkers): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationMarkers: segmentationMarkers } } } } },
                    '#withSegmentationStyle':: d.fn(help='', args=[d.arg(name='segmentationStyle', type=d.T.string)]),
                    withSegmentationStyle(segmentationStyle): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationStyle: segmentationStyle } } } } },
                    '#withSegmentationTime':: d.fn(help='', args=[d.arg(name='segmentationTime', type=d.T.number)]),
                    withSegmentationTime(segmentationTime): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { segmentationTime: segmentationTime } } } } },
                    '#withTimedMetadataBehavior':: d.fn(help='', args=[d.arg(name='timedMetadataBehavior', type=d.T.string)]),
                    withTimedMetadataBehavior(timedMetadataBehavior): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataBehavior: timedMetadataBehavior } } } } },
                    '#withTimedMetadataPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='timedMetadataPid', type=d.T.string)]),
                    withTimedMetadataPid(timedMetadataPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { timedMetadataPid: timedMetadataPid } } } } },
                    '#withTransportStreamId':: d.fn(help='"User-specified id. Ths is used in an output group or an output."', args=[d.arg(name='transportStreamId', type=d.T.number)]),
                    withTransportStreamId(transportStreamId): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { transportStreamId: transportStreamId } } } } },
                    '#withVideoPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='videoPid', type=d.T.string)]),
                    withVideoPid(videoPid): { outputSettings+: { udpOutputSettings+: { containerSettings+: { m2tsSettings+: { videoPid: videoPid } } } } },
                  },
                },
                '#destination':: d.obj(help='"A director and base filename where archive files should be written. See Destination for more details."'),
                destination: {
                  '#withDestinationRefId':: d.fn(help='"Reference ID for the destination."', args=[d.arg(name='destinationRefId', type=d.T.string)]),
                  withDestinationRefId(destinationRefId): { outputSettings+: { udpOutputSettings+: { destination+: { destinationRefId: destinationRefId } } } },
                },
                '#fecOutputSettings':: d.obj(help='"Settings for output. See Output Settings for more details."'),
                fecOutputSettings: {
                  '#withColumnDepth':: d.fn(help='"The height of the FEC protection matrix."', args=[d.arg(name='columnDepth', type=d.T.number)]),
                  withColumnDepth(columnDepth): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { columnDepth: columnDepth } } } },
                  '#withIncludeFec':: d.fn(help='"Enables column only or column and row based FEC."', args=[d.arg(name='includeFec', type=d.T.string)]),
                  withIncludeFec(includeFec): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { includeFec: includeFec } } } },
                  '#withRowLength':: d.fn(help='"The width of the FEC protection matrix."', args=[d.arg(name='rowLength', type=d.T.number)]),
                  withRowLength(rowLength): { outputSettings+: { udpOutputSettings+: { fecOutputSettings+: { rowLength: rowLength } } } },
                },
                '#withBufferMsec':: d.fn(help='"UDP output buffering in milliseconds."', args=[d.arg(name='bufferMsec', type=d.T.number)]),
                withBufferMsec(bufferMsec): { outputSettings+: { udpOutputSettings+: { bufferMsec: bufferMsec } } },
              },
              '#withMediaPackageOutputSettings':: d.fn(help='"Media package output settings. This can be set as an empty block."', args=[d.arg(name='mediaPackageOutputSettings', type=d.T.object)]),
              withMediaPackageOutputSettings(mediaPackageOutputSettings): { outputSettings+: { mediaPackageOutputSettings: mediaPackageOutputSettings } },
              '#withMediaPackageOutputSettingsMixin':: d.fn(help='"Media package output settings. This can be set as an empty block."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mediaPackageOutputSettings', type=d.T.object)]),
              withMediaPackageOutputSettingsMixin(mediaPackageOutputSettings): { outputSettings+: { mediaPackageOutputSettings+: mediaPackageOutputSettings } },
            },
            '#withAudioDescriptionNames':: d.fn(help='"The names of the audio descriptions used as audio sources for the output."', args=[d.arg(name='audioDescriptionNames', type=d.T.array)]),
            withAudioDescriptionNames(audioDescriptionNames): { audioDescriptionNames: if std.isArray(v=audioDescriptionNames) then audioDescriptionNames else [audioDescriptionNames] },
            '#withAudioDescriptionNamesMixin':: d.fn(help='"The names of the audio descriptions used as audio sources for the output."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioDescriptionNames', type=d.T.array)]),
            withAudioDescriptionNamesMixin(audioDescriptionNames): { audioDescriptionNames+: if std.isArray(v=audioDescriptionNames) then audioDescriptionNames else [audioDescriptionNames] },
            '#withCaptionDescriptionNames':: d.fn(help='"The names of the caption descriptions used as caption sources for the output."', args=[d.arg(name='captionDescriptionNames', type=d.T.array)]),
            withCaptionDescriptionNames(captionDescriptionNames): { captionDescriptionNames: if std.isArray(v=captionDescriptionNames) then captionDescriptionNames else [captionDescriptionNames] },
            '#withCaptionDescriptionNamesMixin':: d.fn(help='"The names of the caption descriptions used as caption sources for the output."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionDescriptionNames', type=d.T.array)]),
            withCaptionDescriptionNamesMixin(captionDescriptionNames): { captionDescriptionNames+: if std.isArray(v=captionDescriptionNames) then captionDescriptionNames else [captionDescriptionNames] },
            '#withOutputName':: d.fn(help='"The name used to identify an output."', args=[d.arg(name='outputName', type=d.T.string)]),
            withOutputName(outputName): { outputName: outputName },
            '#withVideoDescriptionName':: d.fn(help='"The name of the video description used as video source for the output."', args=[d.arg(name='videoDescriptionName', type=d.T.string)]),
            withVideoDescriptionName(videoDescriptionName): { videoDescriptionName: videoDescriptionName },
          },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withOutputs':: d.fn(help='"List of outputs. See Outputs for more details."', args=[d.arg(name='outputs', type=d.T.array)]),
          withOutputs(outputs): { outputs: if std.isArray(v=outputs) then outputs else [outputs] },
          '#withOutputsMixin':: d.fn(help='"List of outputs. See Outputs for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='outputs', type=d.T.array)]),
          withOutputsMixin(outputs): { outputs+: if std.isArray(v=outputs) then outputs else [outputs] },
        },
        '#timecodeConfig':: d.obj(help='"Contains settings used to acquire and adjust timecode information from inputs. See Timecode Config for more details."'),
        timecodeConfig: {
          '#withSource':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='source', type=d.T.string)]),
          withSource(source): { spec+: { initProvider+: { encoderSettings+: { timecodeConfig+: { source: source } } } } },
          '#withSyncThreshold':: d.fn(help='"Threshold in frames beyond which output timecode is resynchronized to the input timecode."', args=[d.arg(name='syncThreshold', type=d.T.number)]),
          withSyncThreshold(syncThreshold): { spec+: { initProvider+: { encoderSettings+: { timecodeConfig+: { syncThreshold: syncThreshold } } } } },
        },
        '#videoDescriptions':: d.obj(help='"Video Descriptions. See Video Descriptions for more details."'),
        videoDescriptions: {
          '#codecSettings':: d.obj(help='"Audio codec settings. See Audio Codec Settings for more details."'),
          codecSettings: {
            '#frameCaptureSettings':: d.obj(help='"Frame capture settings. See Frame Capture Settings for more details."'),
            frameCaptureSettings: {
              '#withCaptureInterval':: d.fn(help='"The frequency at which to capture frames for inclusion in the output."', args=[d.arg(name='captureInterval', type=d.T.number)]),
              withCaptureInterval(captureInterval): { codecSettings+: { frameCaptureSettings+: { captureInterval: captureInterval } } },
              '#withCaptureIntervalUnits':: d.fn(help='"Unit for the frame capture interval."', args=[d.arg(name='captureIntervalUnits', type=d.T.string)]),
              withCaptureIntervalUnits(captureIntervalUnits): { codecSettings+: { frameCaptureSettings+: { captureIntervalUnits: captureIntervalUnits } } },
            },
            '#h264Settings':: d.obj(help='"H264 settings. See H264 Settings for more details."'),
            h264Settings: {
              '#filterSettings':: d.obj(help='"Filters to apply to an encode. See H264 Filter Settings for more details."'),
              filterSettings: {
                '#temporalFilterSettings':: d.obj(help='"Temporal filter settings. See Temporal Filter Settings"'),
                temporalFilterSettings: {
                  '#withPostFilterSharpening':: d.fn(help='"Post filter sharpening."', args=[d.arg(name='postFilterSharpening', type=d.T.string)]),
                  withPostFilterSharpening(postFilterSharpening): { codecSettings+: { h264Settings+: { filterSettings+: { temporalFilterSettings+: { postFilterSharpening: postFilterSharpening } } } } },
                  '#withStrength':: d.fn(help='"Filter strength."', args=[d.arg(name='strength', type=d.T.string)]),
                  withStrength(strength): { codecSettings+: { h264Settings+: { filterSettings+: { temporalFilterSettings+: { strength: strength } } } } },
                },
              },
              '#withAdaptiveQuantization':: d.fn(help='"Enables or disables adaptive quantization."', args=[d.arg(name='adaptiveQuantization', type=d.T.string)]),
              withAdaptiveQuantization(adaptiveQuantization): { codecSettings+: { h264Settings+: { adaptiveQuantization: adaptiveQuantization } } },
              '#withAfdSignaling':: d.fn(help='"Indicates that AFD values will be written into the output stream."', args=[d.arg(name='afdSignaling', type=d.T.string)]),
              withAfdSignaling(afdSignaling): { codecSettings+: { h264Settings+: { afdSignaling: afdSignaling } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { h264Settings+: { bitrate: bitrate } } },
              '#withBufFillPct':: d.fn(help='', args=[d.arg(name='bufFillPct', type=d.T.number)]),
              withBufFillPct(bufFillPct): { codecSettings+: { h264Settings+: { bufFillPct: bufFillPct } } },
              '#withBufSize':: d.fn(help='"Size of buffer in bits."', args=[d.arg(name='bufSize', type=d.T.number)]),
              withBufSize(bufSize): { codecSettings+: { h264Settings+: { bufSize: bufSize } } },
              '#withColorMetadata':: d.fn(help='"Includes color space metadata in the output."', args=[d.arg(name='colorMetadata', type=d.T.string)]),
              withColorMetadata(colorMetadata): { codecSettings+: { h264Settings+: { colorMetadata: colorMetadata } } },
              '#withEntropyEncoding':: d.fn(help='"Entropy encoding mode."', args=[d.arg(name='entropyEncoding', type=d.T.string)]),
              withEntropyEncoding(entropyEncoding): { codecSettings+: { h264Settings+: { entropyEncoding: entropyEncoding } } },
              '#withFixedAfd':: d.fn(help='"Four bit AFD value to write on all frames of video in the output stream."', args=[d.arg(name='fixedAfd', type=d.T.string)]),
              withFixedAfd(fixedAfd): { codecSettings+: { h264Settings+: { fixedAfd: fixedAfd } } },
              '#withFlickerAq':: d.fn(help='', args=[d.arg(name='flickerAq', type=d.T.string)]),
              withFlickerAq(flickerAq): { codecSettings+: { h264Settings+: { flickerAq: flickerAq } } },
              '#withForceFieldPictures':: d.fn(help='"Controls whether coding is performed on a field basis or on a frame basis."', args=[d.arg(name='forceFieldPictures', type=d.T.string)]),
              withForceFieldPictures(forceFieldPictures): { codecSettings+: { h264Settings+: { forceFieldPictures: forceFieldPictures } } },
              '#withFramerateControl':: d.fn(help='"Indicates how the output video frame rate is specified."', args=[d.arg(name='framerateControl', type=d.T.string)]),
              withFramerateControl(framerateControl): { codecSettings+: { h264Settings+: { framerateControl: framerateControl } } },
              '#withFramerateDenominator':: d.fn(help='"Framerate denominator."', args=[d.arg(name='framerateDenominator', type=d.T.number)]),
              withFramerateDenominator(framerateDenominator): { codecSettings+: { h264Settings+: { framerateDenominator: framerateDenominator } } },
              '#withFramerateNumerator':: d.fn(help='"Framerate numerator."', args=[d.arg(name='framerateNumerator', type=d.T.number)]),
              withFramerateNumerator(framerateNumerator): { codecSettings+: { h264Settings+: { framerateNumerator: framerateNumerator } } },
              '#withGopBReference':: d.fn(help='"GOP-B reference."', args=[d.arg(name='gopBReference', type=d.T.string)]),
              withGopBReference(gopBReference): { codecSettings+: { h264Settings+: { gopBReference: gopBReference } } },
              '#withGopClosedCadence':: d.fn(help='"Frequency of closed GOPs."', args=[d.arg(name='gopClosedCadence', type=d.T.number)]),
              withGopClosedCadence(gopClosedCadence): { codecSettings+: { h264Settings+: { gopClosedCadence: gopClosedCadence } } },
              '#withGopNumBFrames':: d.fn(help='"Number of B-frames between reference frames."', args=[d.arg(name='gopNumBFrames', type=d.T.number)]),
              withGopNumBFrames(gopNumBFrames): { codecSettings+: { h264Settings+: { gopNumBFrames: gopNumBFrames } } },
              '#withGopSize':: d.fn(help='"GOP size in units of either frames of seconds per gop_size_units."', args=[d.arg(name='gopSize', type=d.T.number)]),
              withGopSize(gopSize): { codecSettings+: { h264Settings+: { gopSize: gopSize } } },
              '#withGopSizeUnits':: d.fn(help='"Indicates if the gop_size is specified in frames or seconds."', args=[d.arg(name='gopSizeUnits', type=d.T.string)]),
              withGopSizeUnits(gopSizeUnits): { codecSettings+: { h264Settings+: { gopSizeUnits: gopSizeUnits } } },
              '#withLevel':: d.fn(help='"H264 level."', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { codecSettings+: { h264Settings+: { level: level } } },
              '#withLookAheadRateControl':: d.fn(help='"Amount of lookahead."', args=[d.arg(name='lookAheadRateControl', type=d.T.string)]),
              withLookAheadRateControl(lookAheadRateControl): { codecSettings+: { h264Settings+: { lookAheadRateControl: lookAheadRateControl } } },
              '#withMaxBitrate':: d.fn(help='"Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video."', args=[d.arg(name='maxBitrate', type=d.T.number)]),
              withMaxBitrate(maxBitrate): { codecSettings+: { h264Settings+: { maxBitrate: maxBitrate } } },
              '#withMinIInterval':: d.fn(help='"Min interval."', args=[d.arg(name='minIInterval', type=d.T.number)]),
              withMinIInterval(minIInterval): { codecSettings+: { h264Settings+: { minIInterval: minIInterval } } },
              '#withNumRefFrames':: d.fn(help='"Number of reference frames to use."', args=[d.arg(name='numRefFrames', type=d.T.number)]),
              withNumRefFrames(numRefFrames): { codecSettings+: { h264Settings+: { numRefFrames: numRefFrames } } },
              '#withParControl':: d.fn(help='"Indicates how the output pixel aspect ratio is specified."', args=[d.arg(name='parControl', type=d.T.string)]),
              withParControl(parControl): { codecSettings+: { h264Settings+: { parControl: parControl } } },
              '#withParDenominator':: d.fn(help='"Pixel Aspect Ratio denominator."', args=[d.arg(name='parDenominator', type=d.T.number)]),
              withParDenominator(parDenominator): { codecSettings+: { h264Settings+: { parDenominator: parDenominator } } },
              '#withParNumerator':: d.fn(help='"Pixel Aspect Ratio numerator."', args=[d.arg(name='parNumerator', type=d.T.number)]),
              withParNumerator(parNumerator): { codecSettings+: { h264Settings+: { parNumerator: parNumerator } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { h264Settings+: { profile: profile } } },
              '#withQualityLevel':: d.fn(help='"Quality level."', args=[d.arg(name='qualityLevel', type=d.T.string)]),
              withQualityLevel(qualityLevel): { codecSettings+: { h264Settings+: { qualityLevel: qualityLevel } } },
              '#withQvbrQualityLevel':: d.fn(help='"Controls the target quality for the video encode."', args=[d.arg(name='qvbrQualityLevel', type=d.T.number)]),
              withQvbrQualityLevel(qvbrQualityLevel): { codecSettings+: { h264Settings+: { qvbrQualityLevel: qvbrQualityLevel } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { h264Settings+: { rateControlMode: rateControlMode } } },
              '#withScanType':: d.fn(help='"Sets the scan type of the output."', args=[d.arg(name='scanType', type=d.T.string)]),
              withScanType(scanType): { codecSettings+: { h264Settings+: { scanType: scanType } } },
              '#withSceneChangeDetect':: d.fn(help='"Scene change detection."', args=[d.arg(name='sceneChangeDetect', type=d.T.string)]),
              withSceneChangeDetect(sceneChangeDetect): { codecSettings+: { h264Settings+: { sceneChangeDetect: sceneChangeDetect } } },
              '#withSlices':: d.fn(help='"Number of slices per picture."', args=[d.arg(name='slices', type=d.T.number)]),
              withSlices(slices): { codecSettings+: { h264Settings+: { slices: slices } } },
              '#withSoftness':: d.fn(help='"Softness."', args=[d.arg(name='softness', type=d.T.number)]),
              withSoftness(softness): { codecSettings+: { h264Settings+: { softness: softness } } },
              '#withSpatialAq':: d.fn(help='"Makes adjustments within each frame based on spatial variation of content complexity."', args=[d.arg(name='spatialAq', type=d.T.string)]),
              withSpatialAq(spatialAq): { codecSettings+: { h264Settings+: { spatialAq: spatialAq } } },
              '#withSubgopLength':: d.fn(help='"Subgop length."', args=[d.arg(name='subgopLength', type=d.T.string)]),
              withSubgopLength(subgopLength): { codecSettings+: { h264Settings+: { subgopLength: subgopLength } } },
              '#withSyntax':: d.fn(help='"Produces a bitstream compliant with SMPTE RP-2027."', args=[d.arg(name='syntax', type=d.T.string)]),
              withSyntax(syntax): { codecSettings+: { h264Settings+: { syntax: syntax } } },
              '#withTemporalAq':: d.fn(help='"Makes adjustments within each frame based on temporal variation of content complexity."', args=[d.arg(name='temporalAq', type=d.T.string)]),
              withTemporalAq(temporalAq): { codecSettings+: { h264Settings+: { temporalAq: temporalAq } } },
              '#withTimecodeInsertion':: d.fn(help='"Determines how timecodes should be inserted into the video elementary stream."', args=[d.arg(name='timecodeInsertion', type=d.T.string)]),
              withTimecodeInsertion(timecodeInsertion): { codecSettings+: { h264Settings+: { timecodeInsertion: timecodeInsertion } } },
            },
            '#h265Settings':: d.obj(help='"Destination settings for a standard output; one destination for each redundant encoder. See Settings for more details."'),
            h265Settings: {
              '#colorSpaceSettings':: d.obj(help='"Define the color metadata for the output. H265 Color Space Settings for more details."'),
              colorSpaceSettings: {
                '#hdr10Settings':: d.obj(help='"Set the colorspace to be HDR10. See H265 HDR10 Settings for more details."'),
                hdr10Settings: {
                  '#withMaxCll':: d.fn(help='"Sets the MaxCLL value for HDR10."', args=[d.arg(name='maxCll', type=d.T.number)]),
                  withMaxCll(maxCll): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { hdr10Settings+: { maxCll: maxCll } } } } },
                  '#withMaxFall':: d.fn(help='"Sets the MaxFALL value for HDR10."', args=[d.arg(name='maxFall', type=d.T.number)]),
                  withMaxFall(maxFall): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { hdr10Settings+: { maxFall: maxFall } } } } },
                },
                '#withColorSpacePassthroughSettings':: d.fn(help='"Sets the colorspace metadata to be passed through."', args=[d.arg(name='colorSpacePassthroughSettings', type=d.T.object)]),
                withColorSpacePassthroughSettings(colorSpacePassthroughSettings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { colorSpacePassthroughSettings: colorSpacePassthroughSettings } } } },
                '#withColorSpacePassthroughSettingsMixin':: d.fn(help='"Sets the colorspace metadata to be passed through."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='colorSpacePassthroughSettings', type=d.T.object)]),
                withColorSpacePassthroughSettingsMixin(colorSpacePassthroughSettings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { colorSpacePassthroughSettings+: colorSpacePassthroughSettings } } } },
                '#withDolbyVision81Settings':: d.fn(help='"Set the colorspace to Dolby Vision81."', args=[d.arg(name='dolbyVision81Settings', type=d.T.object)]),
                withDolbyVision81Settings(dolbyVision81Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { dolbyVision81Settings: dolbyVision81Settings } } } },
                '#withDolbyVision81SettingsMixin':: d.fn(help='"Set the colorspace to Dolby Vision81."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dolbyVision81Settings', type=d.T.object)]),
                withDolbyVision81SettingsMixin(dolbyVision81Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { dolbyVision81Settings+: dolbyVision81Settings } } } },
                '#withRec601Settings':: d.fn(help='"Set the colorspace to Rec. 601."', args=[d.arg(name='rec601Settings', type=d.T.object)]),
                withRec601Settings(rec601Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec601Settings: rec601Settings } } } },
                '#withRec601SettingsMixin':: d.fn(help='"Set the colorspace to Rec. 601."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rec601Settings', type=d.T.object)]),
                withRec601SettingsMixin(rec601Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec601Settings+: rec601Settings } } } },
                '#withRec709Settings':: d.fn(help='"Set the colorspace to Rec. 709."', args=[d.arg(name='rec709Settings', type=d.T.object)]),
                withRec709Settings(rec709Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec709Settings: rec709Settings } } } },
                '#withRec709SettingsMixin':: d.fn(help='"Set the colorspace to Rec. 709."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rec709Settings', type=d.T.object)]),
                withRec709SettingsMixin(rec709Settings): { codecSettings+: { h265Settings+: { colorSpaceSettings+: { rec709Settings+: rec709Settings } } } },
              },
              '#filterSettings':: d.obj(help='"Filters to apply to an encode. See H264 Filter Settings for more details."'),
              filterSettings: {
                '#temporalFilterSettings':: d.obj(help='"Temporal filter settings. See Temporal Filter Settings"'),
                temporalFilterSettings: {
                  '#withPostFilterSharpening':: d.fn(help='"Post filter sharpening."', args=[d.arg(name='postFilterSharpening', type=d.T.string)]),
                  withPostFilterSharpening(postFilterSharpening): { codecSettings+: { h265Settings+: { filterSettings+: { temporalFilterSettings+: { postFilterSharpening: postFilterSharpening } } } } },
                  '#withStrength':: d.fn(help='"Filter strength."', args=[d.arg(name='strength', type=d.T.string)]),
                  withStrength(strength): { codecSettings+: { h265Settings+: { filterSettings+: { temporalFilterSettings+: { strength: strength } } } } },
                },
              },
              '#timecodeBurninSettings':: d.obj(help='"Apply a burned in timecode. See H265 Timecode Burnin Settings for more details."'),
              timecodeBurninSettings: {
                '#withPrefix':: d.fn(help='"Set a prefix on the burned in timecode."', args=[d.arg(name='prefix', type=d.T.string)]),
                withPrefix(prefix): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { prefix: prefix } } } },
                '#withTimecodeBurninFontSize':: d.fn(help='"Sets the size of the burned in timecode."', args=[d.arg(name='timecodeBurninFontSize', type=d.T.string)]),
                withTimecodeBurninFontSize(timecodeBurninFontSize): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { timecodeBurninFontSize: timecodeBurninFontSize } } } },
                '#withTimecodeBurninPosition':: d.fn(help='"Sets the position of the burned in timecode."', args=[d.arg(name='timecodeBurninPosition', type=d.T.string)]),
                withTimecodeBurninPosition(timecodeBurninPosition): { codecSettings+: { h265Settings+: { timecodeBurninSettings+: { timecodeBurninPosition: timecodeBurninPosition } } } },
              },
              '#withAdaptiveQuantization':: d.fn(help='"Enables or disables adaptive quantization."', args=[d.arg(name='adaptiveQuantization', type=d.T.string)]),
              withAdaptiveQuantization(adaptiveQuantization): { codecSettings+: { h265Settings+: { adaptiveQuantization: adaptiveQuantization } } },
              '#withAfdSignaling':: d.fn(help='"Indicates that AFD values will be written into the output stream."', args=[d.arg(name='afdSignaling', type=d.T.string)]),
              withAfdSignaling(afdSignaling): { codecSettings+: { h265Settings+: { afdSignaling: afdSignaling } } },
              '#withAlternativeTransferFunction':: d.fn(help='"Whether or not EML should insert an Alternative Transfer Function SEI message."', args=[d.arg(name='alternativeTransferFunction', type=d.T.string)]),
              withAlternativeTransferFunction(alternativeTransferFunction): { codecSettings+: { h265Settings+: { alternativeTransferFunction: alternativeTransferFunction } } },
              '#withBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='bitrate', type=d.T.number)]),
              withBitrate(bitrate): { codecSettings+: { h265Settings+: { bitrate: bitrate } } },
              '#withBufSize':: d.fn(help='"Size of buffer in bits."', args=[d.arg(name='bufSize', type=d.T.number)]),
              withBufSize(bufSize): { codecSettings+: { h265Settings+: { bufSize: bufSize } } },
              '#withColorMetadata':: d.fn(help='"Includes color space metadata in the output."', args=[d.arg(name='colorMetadata', type=d.T.string)]),
              withColorMetadata(colorMetadata): { codecSettings+: { h265Settings+: { colorMetadata: colorMetadata } } },
              '#withFixedAfd':: d.fn(help='"Four bit AFD value to write on all frames of video in the output stream."', args=[d.arg(name='fixedAfd', type=d.T.string)]),
              withFixedAfd(fixedAfd): { codecSettings+: { h265Settings+: { fixedAfd: fixedAfd } } },
              '#withFlickerAq':: d.fn(help='', args=[d.arg(name='flickerAq', type=d.T.string)]),
              withFlickerAq(flickerAq): { codecSettings+: { h265Settings+: { flickerAq: flickerAq } } },
              '#withFramerateDenominator':: d.fn(help='"Framerate denominator."', args=[d.arg(name='framerateDenominator', type=d.T.number)]),
              withFramerateDenominator(framerateDenominator): { codecSettings+: { h265Settings+: { framerateDenominator: framerateDenominator } } },
              '#withFramerateNumerator':: d.fn(help='"Framerate numerator."', args=[d.arg(name='framerateNumerator', type=d.T.number)]),
              withFramerateNumerator(framerateNumerator): { codecSettings+: { h265Settings+: { framerateNumerator: framerateNumerator } } },
              '#withGopClosedCadence':: d.fn(help='"Frequency of closed GOPs."', args=[d.arg(name='gopClosedCadence', type=d.T.number)]),
              withGopClosedCadence(gopClosedCadence): { codecSettings+: { h265Settings+: { gopClosedCadence: gopClosedCadence } } },
              '#withGopSize':: d.fn(help='"GOP size in units of either frames of seconds per gop_size_units."', args=[d.arg(name='gopSize', type=d.T.number)]),
              withGopSize(gopSize): { codecSettings+: { h265Settings+: { gopSize: gopSize } } },
              '#withGopSizeUnits':: d.fn(help='"Indicates if the gop_size is specified in frames or seconds."', args=[d.arg(name='gopSizeUnits', type=d.T.string)]),
              withGopSizeUnits(gopSizeUnits): { codecSettings+: { h265Settings+: { gopSizeUnits: gopSizeUnits } } },
              '#withLevel':: d.fn(help='"H264 level."', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { codecSettings+: { h265Settings+: { level: level } } },
              '#withLookAheadRateControl':: d.fn(help='"Amount of lookahead."', args=[d.arg(name='lookAheadRateControl', type=d.T.string)]),
              withLookAheadRateControl(lookAheadRateControl): { codecSettings+: { h265Settings+: { lookAheadRateControl: lookAheadRateControl } } },
              '#withMaxBitrate':: d.fn(help='"Set the maximum bitrate in order to accommodate expected spikes in the complexity of the video."', args=[d.arg(name='maxBitrate', type=d.T.number)]),
              withMaxBitrate(maxBitrate): { codecSettings+: { h265Settings+: { maxBitrate: maxBitrate } } },
              '#withMinIInterval':: d.fn(help='"Min interval."', args=[d.arg(name='minIInterval', type=d.T.number)]),
              withMinIInterval(minIInterval): { codecSettings+: { h265Settings+: { minIInterval: minIInterval } } },
              '#withMinQp':: d.fn(help='"Set the minimum QP."', args=[d.arg(name='minQp', type=d.T.number)]),
              withMinQp(minQp): { codecSettings+: { h265Settings+: { minQp: minQp } } },
              '#withMvOverPictureBoundaries':: d.fn(help='"Enables or disables motion vector over picture boundaries."', args=[d.arg(name='mvOverPictureBoundaries', type=d.T.string)]),
              withMvOverPictureBoundaries(mvOverPictureBoundaries): { codecSettings+: { h265Settings+: { mvOverPictureBoundaries: mvOverPictureBoundaries } } },
              '#withMvTemporalPredictor':: d.fn(help='"Enables or disables the motion vector temporal predictor."', args=[d.arg(name='mvTemporalPredictor', type=d.T.string)]),
              withMvTemporalPredictor(mvTemporalPredictor): { codecSettings+: { h265Settings+: { mvTemporalPredictor: mvTemporalPredictor } } },
              '#withParDenominator':: d.fn(help='"Pixel Aspect Ratio denominator."', args=[d.arg(name='parDenominator', type=d.T.number)]),
              withParDenominator(parDenominator): { codecSettings+: { h265Settings+: { parDenominator: parDenominator } } },
              '#withParNumerator':: d.fn(help='"Pixel Aspect Ratio numerator."', args=[d.arg(name='parNumerator', type=d.T.number)]),
              withParNumerator(parNumerator): { codecSettings+: { h265Settings+: { parNumerator: parNumerator } } },
              '#withProfile':: d.fn(help='"AAC profile."', args=[d.arg(name='profile', type=d.T.string)]),
              withProfile(profile): { codecSettings+: { h265Settings+: { profile: profile } } },
              '#withQvbrQualityLevel':: d.fn(help='"Controls the target quality for the video encode."', args=[d.arg(name='qvbrQualityLevel', type=d.T.number)]),
              withQvbrQualityLevel(qvbrQualityLevel): { codecSettings+: { h265Settings+: { qvbrQualityLevel: qvbrQualityLevel } } },
              '#withRateControlMode':: d.fn(help='"The rate control mode."', args=[d.arg(name='rateControlMode', type=d.T.string)]),
              withRateControlMode(rateControlMode): { codecSettings+: { h265Settings+: { rateControlMode: rateControlMode } } },
              '#withScanType':: d.fn(help='"Sets the scan type of the output."', args=[d.arg(name='scanType', type=d.T.string)]),
              withScanType(scanType): { codecSettings+: { h265Settings+: { scanType: scanType } } },
              '#withSceneChangeDetect':: d.fn(help='"Scene change detection."', args=[d.arg(name='sceneChangeDetect', type=d.T.string)]),
              withSceneChangeDetect(sceneChangeDetect): { codecSettings+: { h265Settings+: { sceneChangeDetect: sceneChangeDetect } } },
              '#withSlices':: d.fn(help='"Number of slices per picture."', args=[d.arg(name='slices', type=d.T.number)]),
              withSlices(slices): { codecSettings+: { h265Settings+: { slices: slices } } },
              '#withTier':: d.fn(help='"Set the H265 tier in the output."', args=[d.arg(name='tier', type=d.T.string)]),
              withTier(tier): { codecSettings+: { h265Settings+: { tier: tier } } },
              '#withTileHeight':: d.fn(help='"Sets the height of tiles."', args=[d.arg(name='tileHeight', type=d.T.number)]),
              withTileHeight(tileHeight): { codecSettings+: { h265Settings+: { tileHeight: tileHeight } } },
              '#withTilePadding':: d.fn(help='"Enables or disables padding of tiles."', args=[d.arg(name='tilePadding', type=d.T.string)]),
              withTilePadding(tilePadding): { codecSettings+: { h265Settings+: { tilePadding: tilePadding } } },
              '#withTileWidth':: d.fn(help='"Sets the width of tiles."', args=[d.arg(name='tileWidth', type=d.T.number)]),
              withTileWidth(tileWidth): { codecSettings+: { h265Settings+: { tileWidth: tileWidth } } },
              '#withTimecodeInsertion':: d.fn(help='"Determines how timecodes should be inserted into the video elementary stream."', args=[d.arg(name='timecodeInsertion', type=d.T.string)]),
              withTimecodeInsertion(timecodeInsertion): { codecSettings+: { h265Settings+: { timecodeInsertion: timecodeInsertion } } },
              '#withTreeblockSize':: d.fn(help='"Sets the size of the treeblock."', args=[d.arg(name='treeblockSize', type=d.T.string)]),
              withTreeblockSize(treeblockSize): { codecSettings+: { h265Settings+: { treeblockSize: treeblockSize } } },
            },
          },
          '#withHeight':: d.fn(help='"See the description in left_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, \\"80\\" means the rectangle height is 80% of the underlying frame height. The top_offset and rectangle_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard."', args=[d.arg(name='height', type=d.T.number)]),
          withHeight(height): { height: height },
          '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withRespondToAfd':: d.fn(help='"Indicate how to respond to the AFD values that might be in the input video."', args=[d.arg(name='respondToAfd', type=d.T.string)]),
          withRespondToAfd(respondToAfd): { respondToAfd: respondToAfd },
          '#withScalingBehavior':: d.fn(help='"Behavior on how to scale."', args=[d.arg(name='scalingBehavior', type=d.T.string)]),
          withScalingBehavior(scalingBehavior): { scalingBehavior: scalingBehavior },
          '#withSharpness':: d.fn(help='"Changes the strength of the anti-alias filter used for scaling."', args=[d.arg(name='sharpness', type=d.T.number)]),
          withSharpness(sharpness): { sharpness: sharpness },
          '#withWidth':: d.fn(help='"See the description in left_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, \\"80\\" means the rectangle width is 80% of the underlying frame width. The left_offset and rectangle_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard."', args=[d.arg(name='width', type=d.T.number)]),
          withWidth(width): { width: width },
        },
        '#withAudioDescriptions':: d.fn(help='"Audio descriptions for the channel. See Audio Descriptions for more details."', args=[d.arg(name='audioDescriptions', type=d.T.array)]),
        withAudioDescriptions(audioDescriptions): { spec+: { initProvider+: { encoderSettings+: { audioDescriptions: if std.isArray(v=audioDescriptions) then audioDescriptions else [audioDescriptions] } } } },
        '#withAudioDescriptionsMixin':: d.fn(help='"Audio descriptions for the channel. See Audio Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioDescriptions', type=d.T.array)]),
        withAudioDescriptionsMixin(audioDescriptions): { spec+: { initProvider+: { encoderSettings+: { audioDescriptions+: if std.isArray(v=audioDescriptions) then audioDescriptions else [audioDescriptions] } } } },
        '#withCaptionDescriptions':: d.fn(help='"Caption Descriptions. See Caption Descriptions for more details."', args=[d.arg(name='captionDescriptions', type=d.T.array)]),
        withCaptionDescriptions(captionDescriptions): { spec+: { initProvider+: { encoderSettings+: { captionDescriptions: if std.isArray(v=captionDescriptions) then captionDescriptions else [captionDescriptions] } } } },
        '#withCaptionDescriptionsMixin':: d.fn(help='"Caption Descriptions. See Caption Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionDescriptions', type=d.T.array)]),
        withCaptionDescriptionsMixin(captionDescriptions): { spec+: { initProvider+: { encoderSettings+: { captionDescriptions+: if std.isArray(v=captionDescriptions) then captionDescriptions else [captionDescriptions] } } } },
        '#withOutputGroups':: d.fn(help='"Output groups for the channel. See Output Groups for more details."', args=[d.arg(name='outputGroups', type=d.T.array)]),
        withOutputGroups(outputGroups): { spec+: { initProvider+: { encoderSettings+: { outputGroups: if std.isArray(v=outputGroups) then outputGroups else [outputGroups] } } } },
        '#withOutputGroupsMixin':: d.fn(help='"Output groups for the channel. See Output Groups for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='outputGroups', type=d.T.array)]),
        withOutputGroupsMixin(outputGroups): { spec+: { initProvider+: { encoderSettings+: { outputGroups+: if std.isArray(v=outputGroups) then outputGroups else [outputGroups] } } } },
        '#withVideoDescriptions':: d.fn(help='"Video Descriptions. See Video Descriptions for more details."', args=[d.arg(name='videoDescriptions', type=d.T.array)]),
        withVideoDescriptions(videoDescriptions): { spec+: { initProvider+: { encoderSettings+: { videoDescriptions: if std.isArray(v=videoDescriptions) then videoDescriptions else [videoDescriptions] } } } },
        '#withVideoDescriptionsMixin':: d.fn(help='"Video Descriptions. See Video Descriptions for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='videoDescriptions', type=d.T.array)]),
        withVideoDescriptionsMixin(videoDescriptions): { spec+: { initProvider+: { encoderSettings+: { videoDescriptions+: if std.isArray(v=videoDescriptions) then videoDescriptions else [videoDescriptions] } } } },
      },
      '#inputAttachments':: d.obj(help='"Input attachments for the channel. See Input Attachments for more details."'),
      inputAttachments: {
        '#automaticInputFailoverSettings':: d.obj(help='"User-specified settings for defining what the conditions are for declaring the input unhealthy and failing over to a different input. See Automatic Input Failover Settings for more details."'),
        automaticInputFailoverSettings: {
          '#failoverCondition':: d.obj(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."'),
          failoverCondition: {
            '#failoverConditionSettings':: d.obj(help='"Failover condition type-specific settings. See Failover Condition Settings for more details."'),
            failoverConditionSettings: {
              '#audioSilenceSettings':: d.obj(help='"MediaLive will perform a failover if the specified audio selector is silent for the specified period. See Audio Silence Failover Settings for more details."'),
              audioSilenceSettings: {
                '#withAudioSelectorName':: d.fn(help="\"The name of the audio selector in the input that MediaLive should monitor to detect silence. Select your most important rendition. If you didn't create an audio selector in this input, leave blank.\"", args=[d.arg(name='audioSelectorName', type=d.T.string)]),
                withAudioSelectorName(audioSelectorName): { failoverConditionSettings+: { audioSilenceSettings+: { audioSelectorName: audioSelectorName } } },
                '#withAudioSilenceThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that the active input must be silent before automatic input failover occurs. Silence is defined as audio loss or audio quieter than -50 dBFS."', args=[d.arg(name='audioSilenceThresholdMsec', type=d.T.number)]),
                withAudioSilenceThresholdMsec(audioSilenceThresholdMsec): { failoverConditionSettings+: { audioSilenceSettings+: { audioSilenceThresholdMsec: audioSilenceThresholdMsec } } },
              },
              '#inputLossSettings':: d.obj(help='"MediaLive will perform a failover if content is not detected in this input for the specified period. See Input Loss Failover Settings for more details."'),
              inputLossSettings: {
                '#withInputLossThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that no input is detected. After that time, an input failover will occur."', args=[d.arg(name='inputLossThresholdMsec', type=d.T.number)]),
                withInputLossThresholdMsec(inputLossThresholdMsec): { failoverConditionSettings+: { inputLossSettings+: { inputLossThresholdMsec: inputLossThresholdMsec } } },
              },
              '#videoBlackSettings':: d.obj(help='"MediaLive will perform a failover if content is considered black for the specified period. See Video Black Failover Settings for more details."'),
              videoBlackSettings: {
                '#withBlackDetectThreshold':: d.fn(help="\"A value used in calculating the threshold below which MediaLive considers a pixel to be 'black'. For the input to be considered black, every pixel in a frame must be below this threshold. The threshold is calculated as a percentage (expressed as a decimal) of white. Therefore .1 means 10% white (or 90% black). Note how the formula works for any color depth. For example, if you set this field to 0.1 in 10-bit color depth: (10230.1=102.3), which means a pixel value of 102 or less is 'black'. If you set this field to .1 in an 8-bit color depth: (2550.1=25.5), which means a pixel value of 25 or less is 'black'. The range is 0.0 to 1.0, with any number of decimal places.\"", args=[d.arg(name='blackDetectThreshold', type=d.T.number)]),
                withBlackDetectThreshold(blackDetectThreshold): { failoverConditionSettings+: { videoBlackSettings+: { blackDetectThreshold: blackDetectThreshold } } },
                '#withVideoBlackThresholdMsec':: d.fn(help='"The amount of time (in milliseconds) that the active input must be black before automatic input failover occurs."', args=[d.arg(name='videoBlackThresholdMsec', type=d.T.number)]),
                withVideoBlackThresholdMsec(videoBlackThresholdMsec): { failoverConditionSettings+: { videoBlackSettings+: { videoBlackThresholdMsec: videoBlackThresholdMsec } } },
              },
            },
          },
          '#withErrorClearTimeMsec':: d.fn(help='"This clear time defines the requirement a recovered input must meet to be considered healthy. The input must have no failover conditions for this length of time. Enter a time in milliseconds. This value is particularly important if the input_preference for the failover pair is set to PRIMARY_INPUT_PREFERRED, because after this time, MediaLive will switch back to the primary input."', args=[d.arg(name='errorClearTimeMsec', type=d.T.number)]),
          withErrorClearTimeMsec(errorClearTimeMsec): { automaticInputFailoverSettings+: { errorClearTimeMsec: errorClearTimeMsec } },
          '#withFailoverCondition':: d.fn(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."', args=[d.arg(name='failoverCondition', type=d.T.array)]),
          withFailoverCondition(failoverCondition): { automaticInputFailoverSettings+: { failoverCondition: if std.isArray(v=failoverCondition) then failoverCondition else [failoverCondition] } },
          '#withFailoverConditionMixin':: d.fn(help='"A list of failover conditions. If any of these conditions occur, MediaLive will perform a failover to the other input. See Failover Condition Block for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='failoverCondition', type=d.T.array)]),
          withFailoverConditionMixin(failoverCondition): { automaticInputFailoverSettings+: { failoverCondition+: if std.isArray(v=failoverCondition) then failoverCondition else [failoverCondition] } },
          '#withInputPreference':: d.fn(help='"Input preference when deciding which input to make active when a previously failed input has recovered."', args=[d.arg(name='inputPreference', type=d.T.string)]),
          withInputPreference(inputPreference): { automaticInputFailoverSettings+: { inputPreference: inputPreference } },
          '#withSecondaryInputId':: d.fn(help='"The input ID of the secondary input in the automatic input failover pair."', args=[d.arg(name='secondaryInputId', type=d.T.string)]),
          withSecondaryInputId(secondaryInputId): { automaticInputFailoverSettings+: { secondaryInputId: secondaryInputId } },
        },
        '#inputIdRef':: d.obj(help='"Reference to a Input in medialive to populate inputId."'),
        inputIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { inputIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { inputIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { inputIdRef+: { name: name } },
        },
        '#inputIdSelector':: d.obj(help='"Selector for a Input in medialive to populate inputId."'),
        inputIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { inputIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { inputIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { inputIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { inputIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { inputIdSelector+: { matchLabels+: matchLabels } },
        },
        '#inputSettings':: d.obj(help='"Settings of an input. See Input Settings for more details."'),
        inputSettings: {
          '#audioSelector':: d.obj(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."'),
          audioSelector: {
            '#selectorSettings':: d.obj(help='"The audio selector settings. See Audio Selector Settings for more details."'),
            selectorSettings: {
              '#audioHlsRenditionSelection':: d.obj(help='"Audio HLS Rendition Selection. See Audio HLS Rendition Selection for more details."'),
              audioHlsRenditionSelection: {
                '#withGroupId':: d.fn(help='"Specifies the GROUP-ID in the #EXT-X-MEDIA tag of the target HLS audio rendition."', args=[d.arg(name='groupId', type=d.T.string)]),
                withGroupId(groupId): { selectorSettings+: { audioHlsRenditionSelection+: { groupId: groupId } } },
                '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { selectorSettings+: { audioHlsRenditionSelection+: { name: name } } },
              },
              '#audioLanguageSelection':: d.obj(help='"Audio Language Selection. See Audio Language Selection for more details."'),
              audioLanguageSelection: {
                '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
                withLanguageCode(languageCode): { selectorSettings+: { audioLanguageSelection+: { languageCode: languageCode } } },
                '#withLanguageSelectionPolicy':: d.fn(help='"When set to “strict”, the transport stream demux strictly identifies audio streams by their language descriptor. If a PMT update occurs such that an audio stream matching the initially selected language is no longer present then mute will be encoded until the language returns. If “loose”, then on a PMT update the demux will choose another audio stream in the program with the same stream type if it can’t find one with the same language."', args=[d.arg(name='languageSelectionPolicy', type=d.T.string)]),
                withLanguageSelectionPolicy(languageSelectionPolicy): { selectorSettings+: { audioLanguageSelection+: { languageSelectionPolicy: languageSelectionPolicy } } },
              },
              '#audioPidSelection':: d.obj(help='"Audio Pid Selection. See Audio PID Selection for more details."'),
              audioPidSelection: {
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { audioPidSelection+: { pid: pid } } },
              },
              '#audioTrackSelection':: d.obj(help='"Audio Track Selection. See Audio Track Selection for more details."'),
              audioTrackSelection: {
                '#dolbyEDecode':: d.obj(help='"Configure decoding options for Dolby E streams - these should be Dolby E frames carried in PCM streams tagged with SMPTE-337. See Dolby E Decode for more details."'),
                dolbyEDecode: {
                  '#withProgramSelection':: d.fn(help='"Applies only to Dolby E. Enter the program ID (according to the metadata in the audio) of the Dolby E program to extract from the specified track. One program extracted per audio selector. To select multiple programs, create multiple selectors with the same Track and different Program numbers. “All channels” means to ignore the program IDs and include all the channels in this selector; useful if metadata is known to be incorrect."', args=[d.arg(name='programSelection', type=d.T.string)]),
                  withProgramSelection(programSelection): { selectorSettings+: { audioTrackSelection+: { dolbyEDecode+: { programSelection: programSelection } } } },
                },
                '#tracks':: d.obj(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."'),
                tracks: {
                  '#withTrack':: d.fn(help='"1-based integer value that maps to a specific audio track."', args=[d.arg(name='track', type=d.T.number)]),
                  withTrack(track): { track: track },
                },
                '#withTracks':: d.fn(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."', args=[d.arg(name='tracks', type=d.T.array)]),
                withTracks(tracks): { selectorSettings+: { audioTrackSelection+: { tracks: if std.isArray(v=tracks) then tracks else [tracks] } } },
                '#withTracksMixin':: d.fn(help='"Selects one or more unique audio tracks from within a source. See Audio Tracks for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tracks', type=d.T.array)]),
                withTracksMixin(tracks): { selectorSettings+: { audioTrackSelection+: { tracks+: if std.isArray(v=tracks) then tracks else [tracks] } } },
              },
            },
            '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#captionSelector':: d.obj(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."'),
          captionSelector: {
            '#selectorSettings':: d.obj(help='"The audio selector settings. See Audio Selector Settings for more details."'),
            selectorSettings: {
              '#ancillarySourceSettings':: d.obj(help='"Ancillary Source Settings. See Ancillary Source Settings for more details."'),
              ancillarySourceSettings: {
                '#withSourceAncillaryChannelNumber':: d.fn(help='"Specifies the number (1 to 4) of the captions channel you want to extract from the ancillary captions. If you plan to convert the ancillary captions to another format, complete this field. If you plan to choose Embedded as the captions destination in the output (to pass through all the channels in the ancillary captions), leave this field blank because MediaLive ignores the field."', args=[d.arg(name='sourceAncillaryChannelNumber', type=d.T.number)]),
                withSourceAncillaryChannelNumber(sourceAncillaryChannelNumber): { selectorSettings+: { ancillarySourceSettings+: { sourceAncillaryChannelNumber: sourceAncillaryChannelNumber } } },
              },
              '#dvbSubSourceSettings':: d.obj(help='"DVB Sub Source Settings. See DVB Sub Source Settings for more details."'),
              dvbSubSourceSettings: {
                '#withOcrLanguage':: d.fn(help='"If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text."', args=[d.arg(name='ocrLanguage', type=d.T.string)]),
                withOcrLanguage(ocrLanguage): { selectorSettings+: { dvbSubSourceSettings+: { ocrLanguage: ocrLanguage } } },
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { dvbSubSourceSettings+: { pid: pid } } },
              },
              '#embeddedSourceSettings':: d.obj(help='"Embedded Source Settings. See Embedded Source Settings for more details."'),
              embeddedSourceSettings: {
                '#withConvert608To708':: d.fn(help='"If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded."', args=[d.arg(name='convert608To708', type=d.T.string)]),
                withConvert608To708(convert608To708): { selectorSettings+: { embeddedSourceSettings+: { convert608To708: convert608To708 } } },
                '#withScte20Detection':: d.fn(help='"Set to “auto” to handle streams with intermittent and/or non-aligned SCTE-20 and Embedded captions."', args=[d.arg(name='scte20Detection', type=d.T.string)]),
                withScte20Detection(scte20Detection): { selectorSettings+: { embeddedSourceSettings+: { scte20Detection: scte20Detection } } },
                '#withSource608ChannelNumber':: d.fn(help='"Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough."', args=[d.arg(name='source608ChannelNumber', type=d.T.number)]),
                withSource608ChannelNumber(source608ChannelNumber): { selectorSettings+: { embeddedSourceSettings+: { source608ChannelNumber: source608ChannelNumber } } },
              },
              '#scte20SourceSettings':: d.obj(help='"SCTE20 Source Settings. See SCTE 20 Source Settings for more details."'),
              scte20SourceSettings: {
                '#withConvert608To708':: d.fn(help='"If upconvert, 608 data is both passed through via the “608 compatibility bytes” fields of the 708 wrapper as well as translated into 708. 708 data present in the source content will be discarded."', args=[d.arg(name='convert608To708', type=d.T.string)]),
                withConvert608To708(convert608To708): { selectorSettings+: { scte20SourceSettings+: { convert608To708: convert608To708 } } },
                '#withSource608ChannelNumber':: d.fn(help='"Specifies the 608/708 channel number within the video track from which to extract captions. Unused for passthrough."', args=[d.arg(name='source608ChannelNumber', type=d.T.number)]),
                withSource608ChannelNumber(source608ChannelNumber): { selectorSettings+: { scte20SourceSettings+: { source608ChannelNumber: source608ChannelNumber } } },
              },
              '#scte27SourceSettings':: d.obj(help='"SCTE27 Source Settings. See SCTE 27 Source Settings for more details."'),
              scte27SourceSettings: {
                '#withOcrLanguage':: d.fn(help='"If you will configure a WebVTT caption description that references this caption selector, use this field to provide the language to consider when translating the image-based source to text."', args=[d.arg(name='ocrLanguage', type=d.T.string)]),
                withOcrLanguage(ocrLanguage): { selectorSettings+: { scte27SourceSettings+: { ocrLanguage: ocrLanguage } } },
                '#withPid':: d.fn(help='"Selects a specific PID from within a source."', args=[d.arg(name='pid', type=d.T.number)]),
                withPid(pid): { selectorSettings+: { scte27SourceSettings+: { pid: pid } } },
              },
              '#teletextSourceSettings':: d.obj(help='"Teletext Source Settings. See Teletext Source Settings for more details."'),
              teletextSourceSettings: {
                '#outputRectangle':: d.obj(help='"Optionally defines a region where TTML style captions will be displayed. See Caption Rectangle for more details."'),
                outputRectangle: {
                  '#withHeight':: d.fn(help='"See the description in left_offset. For height, specify the entire height of the rectangle as a percentage of the underlying frame height. For example, \\"80\\" means the rectangle height is 80% of the underlying frame height. The top_offset and rectangle_height must add up to 100% or less. This field corresponds to tts:extent - Y in the TTML standard."', args=[d.arg(name='height', type=d.T.number)]),
                  withHeight(height): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { height: height } } } },
                  '#withLeftOffset':: d.fn(help='"Applies only if you plan to convert these source captions to EBU-TT-D or TTML in an output. (Make sure to leave the default if you don’t have either of these formats in the output.) You can define a display rectangle for the captions that is smaller than the underlying video frame. You define the rectangle by specifying the position of the left edge, top edge, bottom edge, and right edge of the rectangle, all within the underlying video frame. The units for the measurements are percentages. If you specify a value for one of these fields, you must specify a value for all of them. For leftOffset, specify the position of the left edge of the rectangle, as a percentage of the underlying frame width, and relative to the left edge of the frame. For example, \\"10\\" means the measurement is 10% of the underlying frame width. The rectangle left edge starts at that position from the left edge of the frame. This field corresponds to tts:origin - X in the TTML standard."', args=[d.arg(name='leftOffset', type=d.T.number)]),
                  withLeftOffset(leftOffset): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { leftOffset: leftOffset } } } },
                  '#withTopOffset':: d.fn(help='"See the description in left_offset. For top_offset, specify the position of the top edge of the rectangle, as a percentage of the underlying frame height, and relative to the top edge of the frame. For example, \\"10\\" means the measurement is 10% of the underlying frame height. The rectangle top edge starts at that position from the top edge of the frame. This field corresponds to tts:origin - Y in the TTML standard."', args=[d.arg(name='topOffset', type=d.T.number)]),
                  withTopOffset(topOffset): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { topOffset: topOffset } } } },
                  '#withWidth':: d.fn(help='"See the description in left_offset. For width, specify the entire width of the rectangle as a percentage of the underlying frame width. For example, \\"80\\" means the rectangle width is 80% of the underlying frame width. The left_offset and rectangle_width must add up to 100% or less. This field corresponds to tts:extent - X in the TTML standard."', args=[d.arg(name='width', type=d.T.number)]),
                  withWidth(width): { selectorSettings+: { teletextSourceSettings+: { outputRectangle+: { width: width } } } },
                },
                '#withPageNumber':: d.fn(help='"Specifies the teletext page number within the data stream from which to extract captions. Range of 0x100 (256) to 0x8FF (2303). Unused for passthrough. Should be specified as a hexadecimal string with no “0x” prefix."', args=[d.arg(name='pageNumber', type=d.T.string)]),
                withPageNumber(pageNumber): { selectorSettings+: { teletextSourceSettings+: { pageNumber: pageNumber } } },
              },
              '#withAribSourceSettings':: d.fn(help='"ARIB Source Settings."', args=[d.arg(name='aribSourceSettings', type=d.T.object)]),
              withAribSourceSettings(aribSourceSettings): { selectorSettings+: { aribSourceSettings: aribSourceSettings } },
              '#withAribSourceSettingsMixin':: d.fn(help='"ARIB Source Settings."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aribSourceSettings', type=d.T.object)]),
              withAribSourceSettingsMixin(aribSourceSettings): { selectorSettings+: { aribSourceSettings+: aribSourceSettings } },
            },
            '#withLanguageCode':: d.fn(help='"Selects a specific three-letter language code from within an audio source."', args=[d.arg(name='languageCode', type=d.T.string)]),
            withLanguageCode(languageCode): { languageCode: languageCode },
            '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
          },
          '#networkInputSettings':: d.obj(help='"Input settings. See Network Input Settings for more details."'),
          networkInputSettings: {
            '#hlsInputSettings':: d.obj(help='"Specifies HLS input settings when the uri is for a HLS manifest. See HLS Input Settings for more details."'),
            hlsInputSettings: {
              '#withBandwidth':: d.fn(help='"The bitrate is specified in bits per second, as in an HLS manifest."', args=[d.arg(name='bandwidth', type=d.T.number)]),
              withBandwidth(bandwidth): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { bandwidth: bandwidth } } } },
              '#withBufferSegments':: d.fn(help='"Buffer segments."', args=[d.arg(name='bufferSegments', type=d.T.number)]),
              withBufferSegments(bufferSegments): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { bufferSegments: bufferSegments } } } },
              '#withRetries':: d.fn(help='"The number of consecutive times that attempts to read a manifest or segment must fail before the input is considered unavailable."', args=[d.arg(name='retries', type=d.T.number)]),
              withRetries(retries): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { retries: retries } } } },
              '#withRetryInterval':: d.fn(help='"The number of seconds between retries when an attempt to read a manifest or segment fails."', args=[d.arg(name='retryInterval', type=d.T.number)]),
              withRetryInterval(retryInterval): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { retryInterval: retryInterval } } } },
              '#withScte35Source':: d.fn(help='"The source for the timecode that will be associated with the events outputs."', args=[d.arg(name='scte35Source', type=d.T.string)]),
              withScte35Source(scte35Source): { inputSettings+: { networkInputSettings+: { hlsInputSettings+: { scte35Source: scte35Source } } } },
            },
            '#withServerValidation':: d.fn(help='"Check HTTPS server certificates."', args=[d.arg(name='serverValidation', type=d.T.string)]),
            withServerValidation(serverValidation): { inputSettings+: { networkInputSettings+: { serverValidation: serverValidation } } },
          },
          '#videoSelector':: d.obj(help=''),
          videoSelector: {
            '#withColorSpace':: d.fn(help='', args=[d.arg(name='colorSpace', type=d.T.string)]),
            withColorSpace(colorSpace): { inputSettings+: { videoSelector+: { colorSpace: colorSpace } } },
            '#withColorSpaceUsage':: d.fn(help='', args=[d.arg(name='colorSpaceUsage', type=d.T.string)]),
            withColorSpaceUsage(colorSpaceUsage): { inputSettings+: { videoSelector+: { colorSpaceUsage: colorSpaceUsage } } },
          },
          '#withAudioSelector':: d.fn(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."', args=[d.arg(name='audioSelector', type=d.T.array)]),
          withAudioSelector(audioSelector): { inputSettings+: { audioSelector: if std.isArray(v=audioSelector) then audioSelector else [audioSelector] } },
          '#withAudioSelectorMixin':: d.fn(help='"Used to select the audio stream to decode for inputs that have multiple. See Audio Selectors for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='audioSelector', type=d.T.array)]),
          withAudioSelectorMixin(audioSelector): { inputSettings+: { audioSelector+: if std.isArray(v=audioSelector) then audioSelector else [audioSelector] } },
          '#withCaptionSelector':: d.fn(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."', args=[d.arg(name='captionSelector', type=d.T.array)]),
          withCaptionSelector(captionSelector): { inputSettings+: { captionSelector: if std.isArray(v=captionSelector) then captionSelector else [captionSelector] } },
          '#withCaptionSelectorMixin':: d.fn(help='"Used to select the caption input to use for inputs that have multiple available. See Caption Selectors for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='captionSelector', type=d.T.array)]),
          withCaptionSelectorMixin(captionSelector): { inputSettings+: { captionSelector+: if std.isArray(v=captionSelector) then captionSelector else [captionSelector] } },
          '#withDeblockFilter':: d.fn(help='"Enable or disable the deblock filter when filtering."', args=[d.arg(name='deblockFilter', type=d.T.string)]),
          withDeblockFilter(deblockFilter): { inputSettings+: { deblockFilter: deblockFilter } },
          '#withDenoiseFilter':: d.fn(help='"Enable or disable the denoise filter when filtering."', args=[d.arg(name='denoiseFilter', type=d.T.string)]),
          withDenoiseFilter(denoiseFilter): { inputSettings+: { denoiseFilter: denoiseFilter } },
          '#withFilterStrength':: d.fn(help='"Adjusts the magnitude of filtering from 1 (minimal) to 5 (strongest)."', args=[d.arg(name='filterStrength', type=d.T.number)]),
          withFilterStrength(filterStrength): { inputSettings+: { filterStrength: filterStrength } },
          '#withInputFilter':: d.fn(help='"Turns on the filter for the input."', args=[d.arg(name='inputFilter', type=d.T.string)]),
          withInputFilter(inputFilter): { inputSettings+: { inputFilter: inputFilter } },
          '#withScte35Pid':: d.fn(help='"PID from which to read SCTE-35 messages."', args=[d.arg(name='scte35Pid', type=d.T.number)]),
          withScte35Pid(scte35Pid): { inputSettings+: { scte35Pid: scte35Pid } },
          '#withSmpte2038DataPreference':: d.fn(help='"Specifies whether to extract applicable ancillary data from a SMPTE-2038 source in the input."', args=[d.arg(name='smpte2038DataPreference', type=d.T.string)]),
          withSmpte2038DataPreference(smpte2038DataPreference): { inputSettings+: { smpte2038DataPreference: smpte2038DataPreference } },
          '#withSourceEndBehavior':: d.fn(help='"Loop input if it is a file."', args=[d.arg(name='sourceEndBehavior', type=d.T.string)]),
          withSourceEndBehavior(sourceEndBehavior): { inputSettings+: { sourceEndBehavior: sourceEndBehavior } },
        },
        '#withInputAttachmentName':: d.fn(help='"User-specified name for the attachment."', args=[d.arg(name='inputAttachmentName', type=d.T.string)]),
        withInputAttachmentName(inputAttachmentName): { inputAttachmentName: inputAttachmentName },
        '#withInputId':: d.fn(help='"The ID of the input."', args=[d.arg(name='inputId', type=d.T.string)]),
        withInputId(inputId): { inputId: inputId },
      },
      '#inputSpecification':: d.obj(help='"Specification of network and file inputs for the channel."'),
      inputSpecification: {
        '#withCodec':: d.fn(help='', args=[d.arg(name='codec', type=d.T.string)]),
        withCodec(codec): { spec+: { initProvider+: { inputSpecification+: { codec: codec } } } },
        '#withInputResolution':: d.fn(help='"- Maximum CDI input resolution."', args=[d.arg(name='inputResolution', type=d.T.string)]),
        withInputResolution(inputResolution): { spec+: { initProvider+: { inputSpecification+: { inputResolution: inputResolution } } } },
        '#withMaximumBitrate':: d.fn(help='"Average bitrate in bits/second."', args=[d.arg(name='maximumBitrate', type=d.T.string)]),
        withMaximumBitrate(maximumBitrate): { spec+: { initProvider+: { inputSpecification+: { maximumBitrate: maximumBitrate } } } },
      },
      '#maintenance':: d.obj(help='"Maintenance settings for this channel. See Maintenance for more details."'),
      maintenance: {
        '#withMaintenanceDay':: d.fn(help='"The day of the week to use for maintenance."', args=[d.arg(name='maintenanceDay', type=d.T.string)]),
        withMaintenanceDay(maintenanceDay): { spec+: { initProvider+: { maintenance+: { maintenanceDay: maintenanceDay } } } },
        '#withMaintenanceStartTime':: d.fn(help='"The hour maintenance will start."', args=[d.arg(name='maintenanceStartTime', type=d.T.string)]),
        withMaintenanceStartTime(maintenanceStartTime): { spec+: { initProvider+: { maintenance+: { maintenanceStartTime: maintenanceStartTime } } } },
      },
      '#roleArnRef':: d.obj(help='"Reference to a Role in iam to populate roleArn."'),
      roleArnRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { roleArnRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { roleArnRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { initProvider+: { roleArnRef+: { name: name } } } },
      },
      '#roleArnSelector':: d.obj(help='"Selector for a Role in iam to populate roleArn."'),
      roleArnSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { initProvider+: { roleArnSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { initProvider+: { roleArnSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { initProvider+: { roleArnSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { initProvider+: { roleArnSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { initProvider+: { roleArnSelector+: { matchLabels+: matchLabels } } } },
      },
      '#vpc':: d.obj(help='"Settings for the VPC outputs. See VPC for more details."'),
      vpc: {
        '#withPublicAddressAllocationIds':: d.fn(help='"List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels."', args=[d.arg(name='publicAddressAllocationIds', type=d.T.array)]),
        withPublicAddressAllocationIds(publicAddressAllocationIds): { spec+: { initProvider+: { vpc+: { publicAddressAllocationIds: if std.isArray(v=publicAddressAllocationIds) then publicAddressAllocationIds else [publicAddressAllocationIds] } } } },
        '#withPublicAddressAllocationIdsMixin':: d.fn(help='"List of public address allocation ids to associate with ENIs that will be created in Output VPC. Must specify one for SINGLE_PIPELINE, two for STANDARD channels."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='publicAddressAllocationIds', type=d.T.array)]),
        withPublicAddressAllocationIdsMixin(publicAddressAllocationIds): { spec+: { initProvider+: { vpc+: { publicAddressAllocationIds+: if std.isArray(v=publicAddressAllocationIds) then publicAddressAllocationIds else [publicAddressAllocationIds] } } } },
        '#withSecurityGroupIds':: d.fn(help='"A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used."', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
        withSecurityGroupIds(securityGroupIds): { spec+: { initProvider+: { vpc+: { securityGroupIds: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } } },
        '#withSecurityGroupIdsMixin':: d.fn(help='"A list of up to 5 EC2 VPC security group IDs to attach to the Output VPC network interfaces. If none are specified then the VPC default security group will be used."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='securityGroupIds', type=d.T.array)]),
        withSecurityGroupIdsMixin(securityGroupIds): { spec+: { initProvider+: { vpc+: { securityGroupIds+: if std.isArray(v=securityGroupIds) then securityGroupIds else [securityGroupIds] } } } },
        '#withSubnetIds':: d.fn(help='"A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ)."', args=[d.arg(name='subnetIds', type=d.T.array)]),
        withSubnetIds(subnetIds): { spec+: { initProvider+: { vpc+: { subnetIds: if std.isArray(v=subnetIds) then subnetIds else [subnetIds] } } } },
        '#withSubnetIdsMixin':: d.fn(help='"A list of VPC subnet IDs from the same VPC. If STANDARD channel, subnet IDs must be mapped to two unique availability zones (AZ)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='subnetIds', type=d.T.array)]),
        withSubnetIdsMixin(subnetIds): { spec+: { initProvider+: { vpc+: { subnetIds+: if std.isArray(v=subnetIds) then subnetIds else [subnetIds] } } } },
      },
      '#withChannelClass':: d.fn(help='"Concise argument description."', args=[d.arg(name='channelClass', type=d.T.string)]),
      withChannelClass(channelClass): { spec+: { initProvider+: { channelClass: channelClass } } },
      '#withDestinations':: d.fn(help='"Destinations for channel. See Destinations for more details."', args=[d.arg(name='destinations', type=d.T.array)]),
      withDestinations(destinations): { spec+: { initProvider+: { destinations: if std.isArray(v=destinations) then destinations else [destinations] } } },
      '#withDestinationsMixin':: d.fn(help='"Destinations for channel. See Destinations for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='destinations', type=d.T.array)]),
      withDestinationsMixin(destinations): { spec+: { initProvider+: { destinations+: if std.isArray(v=destinations) then destinations else [destinations] } } },
      '#withInputAttachments':: d.fn(help='"Input attachments for the channel. See Input Attachments for more details."', args=[d.arg(name='inputAttachments', type=d.T.array)]),
      withInputAttachments(inputAttachments): { spec+: { initProvider+: { inputAttachments: if std.isArray(v=inputAttachments) then inputAttachments else [inputAttachments] } } },
      '#withInputAttachmentsMixin':: d.fn(help='"Input attachments for the channel. See Input Attachments for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='inputAttachments', type=d.T.array)]),
      withInputAttachmentsMixin(inputAttachments): { spec+: { initProvider+: { inputAttachments+: if std.isArray(v=inputAttachments) then inputAttachments else [inputAttachments] } } },
      '#withLogLevel':: d.fn(help='"The log level to write to Cloudwatch logs."', args=[d.arg(name='logLevel', type=d.T.string)]),
      withLogLevel(logLevel): { spec+: { initProvider+: { logLevel: logLevel } } },
      '#withName':: d.fn(help='"Name of the Channel."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { initProvider+: { name: name } } },
      '#withRoleArn':: d.fn(help='"Concise argument description."', args=[d.arg(name='roleArn', type=d.T.string)]),
      withRoleArn(roleArn): { spec+: { initProvider+: { roleArn: roleArn } } },
      '#withStartChannel':: d.fn(help='"Whether to start/stop channel. Default: false"', args=[d.arg(name='startChannel', type=d.T.boolean)]),
      withStartChannel(startChannel): { spec+: { initProvider+: { startChannel: startChannel } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { initProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { initProvider+: { tags+: tags } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to\\ncreate, observe, update, and delete this managed resource should be\\nconfigured."'),
    providerConfigRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerConfigRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerConfigRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#withDeletionPolicy':: d.fn(help='"DeletionPolicy specifies what will happen to the underlying external\\nwhen this managed resource is deleted - either \\"Delete\\" or \\"Orphan\\" the\\nexternal resource.\\nThis field is planned to be deprecated in favor of the ManagementPolicies\\nfield in a future release. Currently, both could be set independently and\\nnon-default values would be honored if the feature flag is enabled.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223"', args=[d.arg(name='deletionPolicy', type=d.T.string)]),
    withDeletionPolicy(deletionPolicy): { spec+: { deletionPolicy: deletionPolicy } },
    '#withManagementPolicies':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPolicies(managementPolicies): { spec+: { managementPolicies: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#withManagementPoliciesMixin':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPoliciesMixin(managementPolicies): { spec+: { managementPolicies+: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a\\nSecret to which any connection details for this managed resource should\\nbe written. Connection details frequently include the endpoint, username,\\nand password required to connect to the managed resource."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { writeConnectionSecretToRef+: { namespace: namespace } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
