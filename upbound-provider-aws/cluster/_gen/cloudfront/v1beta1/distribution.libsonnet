{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='distribution', url='', help='"Distribution is the Schema for the Distributions API. Provides a CloudFront web distribution resource."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Distribution', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'cloudfront.aws.upbound.io/v1beta1',
    kind: 'Distribution',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"DistributionSpec defines the desired state of Distribution"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#customErrorResponse':: d.obj(help='"One or more custom error response elements (multiples allowed)."'),
      customErrorResponse: {
        '#withErrorCachingMinTtl':: d.fn(help='"Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated."', args=[d.arg(name='errorCachingMinTtl', type=d.T.number)]),
        withErrorCachingMinTtl(errorCachingMinTtl): { errorCachingMinTtl: errorCachingMinTtl },
        '#withErrorCode':: d.fn(help='"4xx or 5xx HTTP status code that you want to customize."', args=[d.arg(name='errorCode', type=d.T.number)]),
        withErrorCode(errorCode): { errorCode: errorCode },
        '#withResponseCode':: d.fn(help='"HTTP status code that you want CloudFront to return with the custom error page to the viewer."', args=[d.arg(name='responseCode', type=d.T.number)]),
        withResponseCode(responseCode): { responseCode: responseCode },
        '#withResponsePagePath':: d.fn(help='"Path of the custom error page (for example, /custom_404.html)."', args=[d.arg(name='responsePagePath', type=d.T.string)]),
        withResponsePagePath(responsePagePath): { responsePagePath: responsePagePath },
      },
      '#defaultCacheBehavior':: d.obj(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."'),
      defaultCacheBehavior: {
        '#forwardedValues':: d.obj(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."'),
        forwardedValues: {
          '#cookies':: d.obj(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."'),
          cookies: {
            '#withForward':: d.fn(help='"Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names."', args=[d.arg(name='forward', type=d.T.string)]),
            withForward(forward): { forward: forward },
            '#withWhitelistedNames':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNames(whitelistedNames): { whitelistedNames: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
            '#withWhitelistedNamesMixin':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNamesMixin(whitelistedNames): { whitelistedNames+: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
          },
          '#withCookies':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookies(cookies): { cookies: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withCookiesMixin':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookiesMixin(cookies): { cookies+: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withHeaders':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."', args=[d.arg(name='headers', type=d.T.array)]),
          withHeaders(headers): { headers: if std.isArray(v=headers) then headers else [headers] },
          '#withHeadersMixin':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
          withHeadersMixin(headers): { headers+: if std.isArray(v=headers) then headers else [headers] },
          '#withQueryString':: d.fn(help='"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior."', args=[d.arg(name='queryString', type=d.T.boolean)]),
          withQueryString(queryString): { queryString: queryString },
          '#withQueryStringCacheKeys':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeys(queryStringCacheKeys): { queryStringCacheKeys: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
          '#withQueryStringCacheKeysMixin':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeysMixin(queryStringCacheKeys): { queryStringCacheKeys+: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
        },
        '#functionAssociation':: d.obj(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."'),
        functionAssociation: {
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withFunctionArn':: d.fn(help='"ARN of the CloudFront function."', args=[d.arg(name='functionArn', type=d.T.string)]),
          withFunctionArn(functionArn): { functionArn: functionArn },
        },
        '#grpcConfig':: d.obj(help='"A config block that sets the grpc config."'),
        grpcConfig: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
        },
        '#lambdaFunctionAssociation':: d.obj(help='"A config block that triggers a lambda function with specific actions (maximum 4)."'),
        lambdaFunctionAssociation: {
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withIncludeBody':: d.fn(help='"When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false."', args=[d.arg(name='includeBody', type=d.T.boolean)]),
          withIncludeBody(includeBody): { includeBody: includeBody },
          '#withLambdaArn':: d.fn(help='"ARN of the Lambda function."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { lambdaArn: lambdaArn },
        },
        '#withAllowedMethods':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethods(allowedMethods): { allowedMethods: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedMethodsMixin':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethodsMixin(allowedMethods): { allowedMethods+: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withCachePolicyId':: d.fn(help='"Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set."', args=[d.arg(name='cachePolicyId', type=d.T.string)]),
        withCachePolicyId(cachePolicyId): { cachePolicyId: cachePolicyId },
        '#withCachedMethods':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethods(cachedMethods): { cachedMethods: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCachedMethodsMixin':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethodsMixin(cachedMethods): { cachedMethods+: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCompress':: d.fn(help='"Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false)."', args=[d.arg(name='compress', type=d.T.boolean)]),
        withCompress(compress): { compress: compress },
        '#withDefaultTtl':: d.fn(help='"Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='defaultTtl', type=d.T.number)]),
        withDefaultTtl(defaultTtl): { defaultTtl: defaultTtl },
        '#withFieldLevelEncryptionId':: d.fn(help='"Field level encryption configuration ID."', args=[d.arg(name='fieldLevelEncryptionId', type=d.T.string)]),
        withFieldLevelEncryptionId(fieldLevelEncryptionId): { fieldLevelEncryptionId: fieldLevelEncryptionId },
        '#withForwardedValues':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValues(forwardedValues): { forwardedValues: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withForwardedValuesMixin':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValuesMixin(forwardedValues): { forwardedValues+: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withFunctionAssociation':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociation(functionAssociation): { functionAssociation: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withFunctionAssociationMixin':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociationMixin(functionAssociation): { functionAssociation+: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withGrpcConfig':: d.fn(help='"A config block that sets the grpc config."', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfig(grpcConfig): { grpcConfig: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withGrpcConfigMixin':: d.fn(help='"A config block that sets the grpc config."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfigMixin(grpcConfig): { grpcConfig+: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withLambdaFunctionAssociation':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociation(lambdaFunctionAssociation): { lambdaFunctionAssociation: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withLambdaFunctionAssociationMixin':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociationMixin(lambdaFunctionAssociation): { lambdaFunctionAssociation+: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withMaxTtl':: d.fn(help='"Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='maxTtl', type=d.T.number)]),
        withMaxTtl(maxTtl): { maxTtl: maxTtl },
        '#withMinTtl':: d.fn(help='"Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='minTtl', type=d.T.number)]),
        withMinTtl(minTtl): { minTtl: minTtl },
        '#withOriginRequestPolicyId':: d.fn(help='"Unique identifier of the origin request policy that is attached to the behavior."', args=[d.arg(name='originRequestPolicyId', type=d.T.string)]),
        withOriginRequestPolicyId(originRequestPolicyId): { originRequestPolicyId: originRequestPolicyId },
        '#withRealtimeLogConfigArn':: d.fn(help='"ARN of the real-time log configuration that is attached to this cache behavior."', args=[d.arg(name='realtimeLogConfigArn', type=d.T.string)]),
        withRealtimeLogConfigArn(realtimeLogConfigArn): { realtimeLogConfigArn: realtimeLogConfigArn },
        '#withResponseHeadersPolicyId':: d.fn(help='"Identifier for a response headers policy."', args=[d.arg(name='responseHeadersPolicyId', type=d.T.string)]),
        withResponseHeadersPolicyId(responseHeadersPolicyId): { responseHeadersPolicyId: responseHeadersPolicyId },
        '#withSmoothStreaming':: d.fn(help='"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior."', args=[d.arg(name='smoothStreaming', type=d.T.boolean)]),
        withSmoothStreaming(smoothStreaming): { smoothStreaming: smoothStreaming },
        '#withTargetOriginId':: d.fn(help='"Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."', args=[d.arg(name='targetOriginId', type=d.T.string)]),
        withTargetOriginId(targetOriginId): { targetOriginId: targetOriginId },
        '#withTrustedKeyGroups':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroups(trustedKeyGroups): { trustedKeyGroups: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedKeyGroupsMixin':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroupsMixin(trustedKeyGroups): { trustedKeyGroups+: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedSigners':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSigners(trustedSigners): { trustedSigners: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withTrustedSignersMixin':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSignersMixin(trustedSigners): { trustedSigners+: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withViewerProtocolPolicy':: d.fn(help='"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https."', args=[d.arg(name='viewerProtocolPolicy', type=d.T.string)]),
        withViewerProtocolPolicy(viewerProtocolPolicy): { viewerProtocolPolicy: viewerProtocolPolicy },
      },
      '#loggingConfig':: d.obj(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."'),
      loggingConfig: {
        '#withBucket':: d.fn(help='"Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com. The bucket must have correct ACL attached with \\"FULL_CONTROL\\" permission for \\"awslogsdelivery\\" account (Canonical ID: \\"c4c1ede66af53448b93c283ce9448c4ba468c9432aa01d700d3878632f77d2d0\\") for log transfer to work."', args=[d.arg(name='bucket', type=d.T.string)]),
        withBucket(bucket): { bucket: bucket },
        '#withIncludeCookies':: d.fn(help='"Whether to include cookies in access logs (default: false)."', args=[d.arg(name='includeCookies', type=d.T.boolean)]),
        withIncludeCookies(includeCookies): { includeCookies: includeCookies },
        '#withPrefix':: d.fn(help='"Prefix to the access log filenames for this distribution, for example, myprefix/."', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
      },
      '#orderedCacheBehavior':: d.obj(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."'),
      orderedCacheBehavior: {
        '#forwardedValues':: d.obj(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."'),
        forwardedValues: {
          '#cookies':: d.obj(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."'),
          cookies: {
            '#withForward':: d.fn(help='"Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names."', args=[d.arg(name='forward', type=d.T.string)]),
            withForward(forward): { forward: forward },
            '#withWhitelistedNames':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNames(whitelistedNames): { whitelistedNames: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
            '#withWhitelistedNamesMixin':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNamesMixin(whitelistedNames): { whitelistedNames+: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
          },
          '#withCookies':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookies(cookies): { cookies: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withCookiesMixin':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookiesMixin(cookies): { cookies+: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withHeaders':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."', args=[d.arg(name='headers', type=d.T.array)]),
          withHeaders(headers): { headers: if std.isArray(v=headers) then headers else [headers] },
          '#withHeadersMixin':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
          withHeadersMixin(headers): { headers+: if std.isArray(v=headers) then headers else [headers] },
          '#withQueryString':: d.fn(help='"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior."', args=[d.arg(name='queryString', type=d.T.boolean)]),
          withQueryString(queryString): { queryString: queryString },
          '#withQueryStringCacheKeys':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeys(queryStringCacheKeys): { queryStringCacheKeys: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
          '#withQueryStringCacheKeysMixin':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeysMixin(queryStringCacheKeys): { queryStringCacheKeys+: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
        },
        '#functionAssociation':: d.obj(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."'),
        functionAssociation: {
          '#functionArnRef':: d.obj(help='"Reference to a Function in cloudfront to populate functionArn."'),
          functionArnRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { functionArnRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { functionArnRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { functionArnRef+: { name: name } },
          },
          '#functionArnSelector':: d.obj(help='"Selector for a Function in cloudfront to populate functionArn."'),
          functionArnSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { functionArnSelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { functionArnSelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { functionArnSelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { functionArnSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { functionArnSelector+: { matchLabels+: matchLabels } },
          },
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withFunctionArn':: d.fn(help='"ARN of the CloudFront function."', args=[d.arg(name='functionArn', type=d.T.string)]),
          withFunctionArn(functionArn): { functionArn: functionArn },
        },
        '#grpcConfig':: d.obj(help='"A config block that sets the grpc config."'),
        grpcConfig: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
        },
        '#lambdaFunctionAssociation':: d.obj(help='"A config block that triggers a lambda function with specific actions (maximum 4)."'),
        lambdaFunctionAssociation: {
          '#lambdaArnRef':: d.obj(help='"Reference to a Function in lambda to populate lambdaArn."'),
          lambdaArnRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { lambdaArnRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { lambdaArnRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { lambdaArnRef+: { name: name } },
          },
          '#lambdaArnSelector':: d.obj(help='"Selector for a Function in lambda to populate lambdaArn."'),
          lambdaArnSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { lambdaArnSelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { lambdaArnSelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { lambdaArnSelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { lambdaArnSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { lambdaArnSelector+: { matchLabels+: matchLabels } },
          },
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withIncludeBody':: d.fn(help='"When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false."', args=[d.arg(name='includeBody', type=d.T.boolean)]),
          withIncludeBody(includeBody): { includeBody: includeBody },
          '#withLambdaArn':: d.fn(help='"ARN of the Lambda function."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { lambdaArn: lambdaArn },
        },
        '#withAllowedMethods':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethods(allowedMethods): { allowedMethods: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedMethodsMixin':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethodsMixin(allowedMethods): { allowedMethods+: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withCachePolicyId':: d.fn(help='"Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set."', args=[d.arg(name='cachePolicyId', type=d.T.string)]),
        withCachePolicyId(cachePolicyId): { cachePolicyId: cachePolicyId },
        '#withCachedMethods':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethods(cachedMethods): { cachedMethods: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCachedMethodsMixin':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethodsMixin(cachedMethods): { cachedMethods+: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCompress':: d.fn(help='"Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false)."', args=[d.arg(name='compress', type=d.T.boolean)]),
        withCompress(compress): { compress: compress },
        '#withDefaultTtl':: d.fn(help='"Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='defaultTtl', type=d.T.number)]),
        withDefaultTtl(defaultTtl): { defaultTtl: defaultTtl },
        '#withFieldLevelEncryptionId':: d.fn(help='"Field level encryption configuration ID."', args=[d.arg(name='fieldLevelEncryptionId', type=d.T.string)]),
        withFieldLevelEncryptionId(fieldLevelEncryptionId): { fieldLevelEncryptionId: fieldLevelEncryptionId },
        '#withForwardedValues':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValues(forwardedValues): { forwardedValues: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withForwardedValuesMixin':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValuesMixin(forwardedValues): { forwardedValues+: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withFunctionAssociation':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociation(functionAssociation): { functionAssociation: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withFunctionAssociationMixin':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociationMixin(functionAssociation): { functionAssociation+: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withGrpcConfig':: d.fn(help='"A config block that sets the grpc config."', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfig(grpcConfig): { grpcConfig: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withGrpcConfigMixin':: d.fn(help='"A config block that sets the grpc config."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfigMixin(grpcConfig): { grpcConfig+: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withLambdaFunctionAssociation':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociation(lambdaFunctionAssociation): { lambdaFunctionAssociation: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withLambdaFunctionAssociationMixin':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociationMixin(lambdaFunctionAssociation): { lambdaFunctionAssociation+: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withMaxTtl':: d.fn(help='"Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='maxTtl', type=d.T.number)]),
        withMaxTtl(maxTtl): { maxTtl: maxTtl },
        '#withMinTtl':: d.fn(help='"Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='minTtl', type=d.T.number)]),
        withMinTtl(minTtl): { minTtl: minTtl },
        '#withOriginRequestPolicyId':: d.fn(help='"Unique identifier of the origin request policy that is attached to the behavior."', args=[d.arg(name='originRequestPolicyId', type=d.T.string)]),
        withOriginRequestPolicyId(originRequestPolicyId): { originRequestPolicyId: originRequestPolicyId },
        '#withPathPattern':: d.fn(help='"Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to."', args=[d.arg(name='pathPattern', type=d.T.string)]),
        withPathPattern(pathPattern): { pathPattern: pathPattern },
        '#withRealtimeLogConfigArn':: d.fn(help='"ARN of the real-time log configuration that is attached to this cache behavior."', args=[d.arg(name='realtimeLogConfigArn', type=d.T.string)]),
        withRealtimeLogConfigArn(realtimeLogConfigArn): { realtimeLogConfigArn: realtimeLogConfigArn },
        '#withResponseHeadersPolicyId':: d.fn(help='"Identifier for a response headers policy."', args=[d.arg(name='responseHeadersPolicyId', type=d.T.string)]),
        withResponseHeadersPolicyId(responseHeadersPolicyId): { responseHeadersPolicyId: responseHeadersPolicyId },
        '#withSmoothStreaming':: d.fn(help='"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior."', args=[d.arg(name='smoothStreaming', type=d.T.boolean)]),
        withSmoothStreaming(smoothStreaming): { smoothStreaming: smoothStreaming },
        '#withTargetOriginId':: d.fn(help='"Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."', args=[d.arg(name='targetOriginId', type=d.T.string)]),
        withTargetOriginId(targetOriginId): { targetOriginId: targetOriginId },
        '#withTrustedKeyGroups':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroups(trustedKeyGroups): { trustedKeyGroups: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedKeyGroupsMixin':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroupsMixin(trustedKeyGroups): { trustedKeyGroups+: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedSigners':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSigners(trustedSigners): { trustedSigners: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withTrustedSignersMixin':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSignersMixin(trustedSigners): { trustedSigners+: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withViewerProtocolPolicy':: d.fn(help='"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https."', args=[d.arg(name='viewerProtocolPolicy', type=d.T.string)]),
        withViewerProtocolPolicy(viewerProtocolPolicy): { viewerProtocolPolicy: viewerProtocolPolicy },
      },
      '#origin':: d.obj(help='"One or more origins for this distribution (multiples allowed)."'),
      origin: {
        '#customHeader':: d.obj(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."'),
        customHeader: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#customOriginConfig':: d.obj(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."'),
        customOriginConfig: {
          '#withHttpPort':: d.fn(help='"HTTP port the custom origin listens on."', args=[d.arg(name='httpPort', type=d.T.number)]),
          withHttpPort(httpPort): { httpPort: httpPort },
          '#withHttpsPort':: d.fn(help='"HTTPS port the custom origin listens on."', args=[d.arg(name='httpsPort', type=d.T.number)]),
          withHttpsPort(httpsPort): { httpsPort: httpsPort },
          '#withOriginKeepaliveTimeout':: d.fn(help='"The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5."', args=[d.arg(name='originKeepaliveTimeout', type=d.T.number)]),
          withOriginKeepaliveTimeout(originKeepaliveTimeout): { originKeepaliveTimeout: originKeepaliveTimeout },
          '#withOriginProtocolPolicy':: d.fn(help='"Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer."', args=[d.arg(name='originProtocolPolicy', type=d.T.string)]),
          withOriginProtocolPolicy(originProtocolPolicy): { originProtocolPolicy: originProtocolPolicy },
          '#withOriginReadTimeout':: d.fn(help='"The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30."', args=[d.arg(name='originReadTimeout', type=d.T.number)]),
          withOriginReadTimeout(originReadTimeout): { originReadTimeout: originReadTimeout },
          '#withOriginSslProtocols':: d.fn(help='"List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide."', args=[d.arg(name='originSslProtocols', type=d.T.array)]),
          withOriginSslProtocols(originSslProtocols): { originSslProtocols: if std.isArray(v=originSslProtocols) then originSslProtocols else [originSslProtocols] },
          '#withOriginSslProtocolsMixin':: d.fn(help='"List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originSslProtocols', type=d.T.array)]),
          withOriginSslProtocolsMixin(originSslProtocols): { originSslProtocols+: if std.isArray(v=originSslProtocols) then originSslProtocols else [originSslProtocols] },
        },
        '#originAccessControlIdRef':: d.obj(help='"Reference to a OriginAccessControl in cloudfront to populate originAccessControlId."'),
        originAccessControlIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { originAccessControlIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { originAccessControlIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { originAccessControlIdRef+: { name: name } },
        },
        '#originAccessControlIdSelector':: d.obj(help='"Selector for a OriginAccessControl in cloudfront to populate originAccessControlId."'),
        originAccessControlIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { originAccessControlIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { originAccessControlIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { originAccessControlIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { originAccessControlIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { originAccessControlIdSelector+: { matchLabels+: matchLabels } },
        },
        '#originShield':: d.obj(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."'),
        originShield: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
          '#withOriginShieldRegion':: d.fn(help='"AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2."', args=[d.arg(name='originShieldRegion', type=d.T.string)]),
          withOriginShieldRegion(originShieldRegion): { originShieldRegion: originShieldRegion },
        },
        '#s3OriginConfig':: d.obj(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."'),
        s3OriginConfig: {
          '#originAccessIdentityRef':: d.obj(help='"Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity."'),
          originAccessIdentityRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { originAccessIdentityRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { originAccessIdentityRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { originAccessIdentityRef+: { name: name } },
          },
          '#originAccessIdentitySelector':: d.obj(help='"Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity."'),
          originAccessIdentitySelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { originAccessIdentitySelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { originAccessIdentitySelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { originAccessIdentitySelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { originAccessIdentitySelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { originAccessIdentitySelector+: { matchLabels+: matchLabels } },
          },
          '#withOriginAccessIdentity':: d.fn(help='"The CloudFront origin access identity to associate with the origin."', args=[d.arg(name='originAccessIdentity', type=d.T.string)]),
          withOriginAccessIdentity(originAccessIdentity): { originAccessIdentity: originAccessIdentity },
        },
        '#vpcOriginConfig':: d.obj(help='"The VPC origin configuration."'),
        vpcOriginConfig: {
          '#withOriginKeepaliveTimeout':: d.fn(help='"The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5."', args=[d.arg(name='originKeepaliveTimeout', type=d.T.number)]),
          withOriginKeepaliveTimeout(originKeepaliveTimeout): { originKeepaliveTimeout: originKeepaliveTimeout },
          '#withOriginReadTimeout':: d.fn(help='"The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30."', args=[d.arg(name='originReadTimeout', type=d.T.number)]),
          withOriginReadTimeout(originReadTimeout): { originReadTimeout: originReadTimeout },
          '#withVpcOriginId':: d.fn(help='"The VPC origin ID."', args=[d.arg(name='vpcOriginId', type=d.T.string)]),
          withVpcOriginId(vpcOriginId): { vpcOriginId: vpcOriginId },
        },
        '#withConnectionAttempts':: d.fn(help='"Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3."', args=[d.arg(name='connectionAttempts', type=d.T.number)]),
        withConnectionAttempts(connectionAttempts): { connectionAttempts: connectionAttempts },
        '#withConnectionTimeout':: d.fn(help='"Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10."', args=[d.arg(name='connectionTimeout', type=d.T.number)]),
        withConnectionTimeout(connectionTimeout): { connectionTimeout: connectionTimeout },
        '#withCustomHeader':: d.fn(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."', args=[d.arg(name='customHeader', type=d.T.array)]),
        withCustomHeader(customHeader): { customHeader: if std.isArray(v=customHeader) then customHeader else [customHeader] },
        '#withCustomHeaderMixin':: d.fn(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customHeader', type=d.T.array)]),
        withCustomHeaderMixin(customHeader): { customHeader+: if std.isArray(v=customHeader) then customHeader else [customHeader] },
        '#withCustomOriginConfig':: d.fn(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."', args=[d.arg(name='customOriginConfig', type=d.T.array)]),
        withCustomOriginConfig(customOriginConfig): { customOriginConfig: if std.isArray(v=customOriginConfig) then customOriginConfig else [customOriginConfig] },
        '#withCustomOriginConfigMixin':: d.fn(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customOriginConfig', type=d.T.array)]),
        withCustomOriginConfigMixin(customOriginConfig): { customOriginConfig+: if std.isArray(v=customOriginConfig) then customOriginConfig else [customOriginConfig] },
        '#withDomainName':: d.fn(help='"DNS domain name of either the S3 bucket, or web site of your custom origin."', args=[d.arg(name='domainName', type=d.T.string)]),
        withDomainName(domainName): { domainName: domainName },
        '#withOriginAccessControlId':: d.fn(help='"Unique identifier of a CloudFront origin access control for this origin."', args=[d.arg(name='originAccessControlId', type=d.T.string)]),
        withOriginAccessControlId(originAccessControlId): { originAccessControlId: originAccessControlId },
        '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
        withOriginId(originId): { originId: originId },
        '#withOriginPath':: d.fn(help='"Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin."', args=[d.arg(name='originPath', type=d.T.string)]),
        withOriginPath(originPath): { originPath: originPath },
        '#withOriginShield':: d.fn(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."', args=[d.arg(name='originShield', type=d.T.array)]),
        withOriginShield(originShield): { originShield: if std.isArray(v=originShield) then originShield else [originShield] },
        '#withOriginShieldMixin':: d.fn(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originShield', type=d.T.array)]),
        withOriginShieldMixin(originShield): { originShield+: if std.isArray(v=originShield) then originShield else [originShield] },
        '#withResponseCompletionTimeout':: d.fn(help='"Time (in seconds) that a request from CloudFront to the origin can stay open and wait for a response. Must be integer greater than or equal to the value of origin_read_timeout. If omitted or explicitly set to 0, no maximum value is enforced."', args=[d.arg(name='responseCompletionTimeout', type=d.T.number)]),
        withResponseCompletionTimeout(responseCompletionTimeout): { responseCompletionTimeout: responseCompletionTimeout },
        '#withS3OriginConfig':: d.fn(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."', args=[d.arg(name='s3OriginConfig', type=d.T.array)]),
        withS3OriginConfig(s3OriginConfig): { s3OriginConfig: if std.isArray(v=s3OriginConfig) then s3OriginConfig else [s3OriginConfig] },
        '#withS3OriginConfigMixin':: d.fn(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='s3OriginConfig', type=d.T.array)]),
        withS3OriginConfigMixin(s3OriginConfig): { s3OriginConfig+: if std.isArray(v=s3OriginConfig) then s3OriginConfig else [s3OriginConfig] },
        '#withVpcOriginConfig':: d.fn(help='"The VPC origin configuration."', args=[d.arg(name='vpcOriginConfig', type=d.T.array)]),
        withVpcOriginConfig(vpcOriginConfig): { vpcOriginConfig: if std.isArray(v=vpcOriginConfig) then vpcOriginConfig else [vpcOriginConfig] },
        '#withVpcOriginConfigMixin':: d.fn(help='"The VPC origin configuration."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='vpcOriginConfig', type=d.T.array)]),
        withVpcOriginConfigMixin(vpcOriginConfig): { vpcOriginConfig+: if std.isArray(v=vpcOriginConfig) then vpcOriginConfig else [vpcOriginConfig] },
      },
      '#originGroup':: d.obj(help='"One or more origin_group for this distribution (multiples allowed)."'),
      originGroup: {
        '#failoverCriteria':: d.obj(help='"The failover criteria for when to failover to the secondary origin."'),
        failoverCriteria: {
          '#withStatusCodes':: d.fn(help='"List of HTTP status codes for the origin group."', args=[d.arg(name='statusCodes', type=d.T.array)]),
          withStatusCodes(statusCodes): { statusCodes: if std.isArray(v=statusCodes) then statusCodes else [statusCodes] },
          '#withStatusCodesMixin':: d.fn(help='"List of HTTP status codes for the origin group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='statusCodes', type=d.T.array)]),
          withStatusCodesMixin(statusCodes): { statusCodes+: if std.isArray(v=statusCodes) then statusCodes else [statusCodes] },
        },
        '#member':: d.obj(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."'),
        member: {
          '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
          withOriginId(originId): { originId: originId },
        },
        '#withFailoverCriteria':: d.fn(help='"The failover criteria for when to failover to the secondary origin."', args=[d.arg(name='failoverCriteria', type=d.T.array)]),
        withFailoverCriteria(failoverCriteria): { failoverCriteria: if std.isArray(v=failoverCriteria) then failoverCriteria else [failoverCriteria] },
        '#withFailoverCriteriaMixin':: d.fn(help='"The failover criteria for when to failover to the secondary origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='failoverCriteria', type=d.T.array)]),
        withFailoverCriteriaMixin(failoverCriteria): { failoverCriteria+: if std.isArray(v=failoverCriteria) then failoverCriteria else [failoverCriteria] },
        '#withMember':: d.fn(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."', args=[d.arg(name='member', type=d.T.array)]),
        withMember(member): { member: if std.isArray(v=member) then member else [member] },
        '#withMemberMixin':: d.fn(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='member', type=d.T.array)]),
        withMemberMixin(member): { member+: if std.isArray(v=member) then member else [member] },
        '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
        withOriginId(originId): { originId: originId },
      },
      '#restrictions':: d.obj(help='"The restriction configuration for this distribution (maximum one)."'),
      restrictions: {
        '#geoRestriction':: d.obj(help=''),
        geoRestriction: {
          '#withLocations':: d.fn(help='"ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used."', args=[d.arg(name='locations', type=d.T.array)]),
          withLocations(locations): { locations: if std.isArray(v=locations) then locations else [locations] },
          '#withLocationsMixin':: d.fn(help='"ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='locations', type=d.T.array)]),
          withLocationsMixin(locations): { locations+: if std.isArray(v=locations) then locations else [locations] },
          '#withRestrictionType':: d.fn(help='"Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist."', args=[d.arg(name='restrictionType', type=d.T.string)]),
          withRestrictionType(restrictionType): { restrictionType: restrictionType },
        },
        '#withGeoRestriction':: d.fn(help='', args=[d.arg(name='geoRestriction', type=d.T.array)]),
        withGeoRestriction(geoRestriction): { geoRestriction: if std.isArray(v=geoRestriction) then geoRestriction else [geoRestriction] },
        '#withGeoRestrictionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='geoRestriction', type=d.T.array)]),
        withGeoRestrictionMixin(geoRestriction): { geoRestriction+: if std.isArray(v=geoRestriction) then geoRestriction else [geoRestriction] },
      },
      '#viewerCertificate':: d.obj(help='"The SSL configuration for this distribution (maximum one)."'),
      viewerCertificate: {
        '#withAcmCertificateArn':: d.fn(help='"ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1."', args=[d.arg(name='acmCertificateArn', type=d.T.string)]),
        withAcmCertificateArn(acmCertificateArn): { acmCertificateArn: acmCertificateArn },
        '#withCloudfrontDefaultCertificate':: d.fn(help="\"true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.\"", args=[d.arg(name='cloudfrontDefaultCertificate', type=d.T.boolean)]),
        withCloudfrontDefaultCertificate(cloudfrontDefaultCertificate): { cloudfrontDefaultCertificate: cloudfrontDefaultCertificate },
        '#withIamCertificateId':: d.fn(help='"IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate."', args=[d.arg(name='iamCertificateId', type=d.T.string)]),
        withIamCertificateId(iamCertificateId): { iamCertificateId: iamCertificateId },
        '#withMinimumProtocolVersion':: d.fn(help='"Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under \\"Security policy.\\" Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified."', args=[d.arg(name='minimumProtocolVersion', type=d.T.string)]),
        withMinimumProtocolVersion(minimumProtocolVersion): { minimumProtocolVersion: minimumProtocolVersion },
        '#withSslSupportMethod':: d.fn(help='"How you want CloudFront to serve HTTPS requests. One of vip, sni-only, or static-ip. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges."', args=[d.arg(name='sslSupportMethod', type=d.T.string)]),
        withSslSupportMethod(sslSupportMethod): { sslSupportMethod: sslSupportMethod },
      },
      '#withAliases':: d.fn(help='"Extra CNAMEs (alternate domain names), if any, for this distribution."', args=[d.arg(name='aliases', type=d.T.array)]),
      withAliases(aliases): { spec+: { forProvider+: { aliases: if std.isArray(v=aliases) then aliases else [aliases] } } },
      '#withAliasesMixin':: d.fn(help='"Extra CNAMEs (alternate domain names), if any, for this distribution."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aliases', type=d.T.array)]),
      withAliasesMixin(aliases): { spec+: { forProvider+: { aliases+: if std.isArray(v=aliases) then aliases else [aliases] } } },
      '#withAnycastIpListId':: d.fn(help='"ID of the Anycast static IP list that is associated with the distribution."', args=[d.arg(name='anycastIpListId', type=d.T.string)]),
      withAnycastIpListId(anycastIpListId): { spec+: { forProvider+: { anycastIpListId: anycastIpListId } } },
      '#withComment':: d.fn(help='"Any comments you want to include about the distribution."', args=[d.arg(name='comment', type=d.T.string)]),
      withComment(comment): { spec+: { forProvider+: { comment: comment } } },
      '#withContinuousDeploymentPolicyId':: d.fn(help='"Identifier of a continuous deployment policy. This argument should only be set on a production distribution. See the aws_cloudfront_continuous_deployment_policy resource for additional details."', args=[d.arg(name='continuousDeploymentPolicyId', type=d.T.string)]),
      withContinuousDeploymentPolicyId(continuousDeploymentPolicyId): { spec+: { forProvider+: { continuousDeploymentPolicyId: continuousDeploymentPolicyId } } },
      '#withCustomErrorResponse':: d.fn(help='"One or more custom error response elements (multiples allowed)."', args=[d.arg(name='customErrorResponse', type=d.T.array)]),
      withCustomErrorResponse(customErrorResponse): { spec+: { forProvider+: { customErrorResponse: if std.isArray(v=customErrorResponse) then customErrorResponse else [customErrorResponse] } } },
      '#withCustomErrorResponseMixin':: d.fn(help='"One or more custom error response elements (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customErrorResponse', type=d.T.array)]),
      withCustomErrorResponseMixin(customErrorResponse): { spec+: { forProvider+: { customErrorResponse+: if std.isArray(v=customErrorResponse) then customErrorResponse else [customErrorResponse] } } },
      '#withDefaultCacheBehavior':: d.fn(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."', args=[d.arg(name='defaultCacheBehavior', type=d.T.array)]),
      withDefaultCacheBehavior(defaultCacheBehavior): { spec+: { forProvider+: { defaultCacheBehavior: if std.isArray(v=defaultCacheBehavior) then defaultCacheBehavior else [defaultCacheBehavior] } } },
      '#withDefaultCacheBehaviorMixin':: d.fn(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='defaultCacheBehavior', type=d.T.array)]),
      withDefaultCacheBehaviorMixin(defaultCacheBehavior): { spec+: { forProvider+: { defaultCacheBehavior+: if std.isArray(v=defaultCacheBehavior) then defaultCacheBehavior else [defaultCacheBehavior] } } },
      '#withDefaultRootObject':: d.fn(help='"Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL."', args=[d.arg(name='defaultRootObject', type=d.T.string)]),
      withDefaultRootObject(defaultRootObject): { spec+: { forProvider+: { defaultRootObject: defaultRootObject } } },
      '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
      withEnabled(enabled): { spec+: { forProvider+: { enabled: enabled } } },
      '#withHttpVersion':: d.fn(help='"Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2."', args=[d.arg(name='httpVersion', type=d.T.string)]),
      withHttpVersion(httpVersion): { spec+: { forProvider+: { httpVersion: httpVersion } } },
      '#withIsIpv6Enabled':: d.fn(help='"Whether the IPv6 is enabled for the distribution."', args=[d.arg(name='isIpv6Enabled', type=d.T.boolean)]),
      withIsIpv6Enabled(isIpv6Enabled): { spec+: { forProvider+: { isIpv6Enabled: isIpv6Enabled } } },
      '#withLoggingConfig':: d.fn(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."', args=[d.arg(name='loggingConfig', type=d.T.array)]),
      withLoggingConfig(loggingConfig): { spec+: { forProvider+: { loggingConfig: if std.isArray(v=loggingConfig) then loggingConfig else [loggingConfig] } } },
      '#withLoggingConfigMixin':: d.fn(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='loggingConfig', type=d.T.array)]),
      withLoggingConfigMixin(loggingConfig): { spec+: { forProvider+: { loggingConfig+: if std.isArray(v=loggingConfig) then loggingConfig else [loggingConfig] } } },
      '#withOrderedCacheBehavior':: d.fn(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."', args=[d.arg(name='orderedCacheBehavior', type=d.T.array)]),
      withOrderedCacheBehavior(orderedCacheBehavior): { spec+: { forProvider+: { orderedCacheBehavior: if std.isArray(v=orderedCacheBehavior) then orderedCacheBehavior else [orderedCacheBehavior] } } },
      '#withOrderedCacheBehaviorMixin':: d.fn(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='orderedCacheBehavior', type=d.T.array)]),
      withOrderedCacheBehaviorMixin(orderedCacheBehavior): { spec+: { forProvider+: { orderedCacheBehavior+: if std.isArray(v=orderedCacheBehavior) then orderedCacheBehavior else [orderedCacheBehavior] } } },
      '#withOrigin':: d.fn(help='"One or more origins for this distribution (multiples allowed)."', args=[d.arg(name='origin', type=d.T.array)]),
      withOrigin(origin): { spec+: { forProvider+: { origin: if std.isArray(v=origin) then origin else [origin] } } },
      '#withOriginGroup':: d.fn(help='"One or more origin_group for this distribution (multiples allowed)."', args=[d.arg(name='originGroup', type=d.T.array)]),
      withOriginGroup(originGroup): { spec+: { forProvider+: { originGroup: if std.isArray(v=originGroup) then originGroup else [originGroup] } } },
      '#withOriginGroupMixin':: d.fn(help='"One or more origin_group for this distribution (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originGroup', type=d.T.array)]),
      withOriginGroupMixin(originGroup): { spec+: { forProvider+: { originGroup+: if std.isArray(v=originGroup) then originGroup else [originGroup] } } },
      '#withOriginMixin':: d.fn(help='"One or more origins for this distribution (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='origin', type=d.T.array)]),
      withOriginMixin(origin): { spec+: { forProvider+: { origin+: if std.isArray(v=origin) then origin else [origin] } } },
      '#withPriceClass':: d.fn(help='"Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100."', args=[d.arg(name='priceClass', type=d.T.string)]),
      withPriceClass(priceClass): { spec+: { forProvider+: { priceClass: priceClass } } },
      '#withRestrictions':: d.fn(help='"The restriction configuration for this distribution (maximum one)."', args=[d.arg(name='restrictions', type=d.T.array)]),
      withRestrictions(restrictions): { spec+: { forProvider+: { restrictions: if std.isArray(v=restrictions) then restrictions else [restrictions] } } },
      '#withRestrictionsMixin':: d.fn(help='"The restriction configuration for this distribution (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='restrictions', type=d.T.array)]),
      withRestrictionsMixin(restrictions): { spec+: { forProvider+: { restrictions+: if std.isArray(v=restrictions) then restrictions else [restrictions] } } },
      '#withRetainOnDelete':: d.fn(help='"If this is set, the distribution needs to be deleted manually afterwards. Default: false."', args=[d.arg(name='retainOnDelete', type=d.T.boolean)]),
      withRetainOnDelete(retainOnDelete): { spec+: { forProvider+: { retainOnDelete: retainOnDelete } } },
      '#withStaging':: d.fn(help='"A Boolean that indicates whether this is a staging distribution. Defaults to false."', args=[d.arg(name='staging', type=d.T.boolean)]),
      withStaging(staging): { spec+: { forProvider+: { staging: staging } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { forProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: tags } } },
      '#withViewerCertificate':: d.fn(help='"The SSL configuration for this distribution (maximum one)."', args=[d.arg(name='viewerCertificate', type=d.T.array)]),
      withViewerCertificate(viewerCertificate): { spec+: { forProvider+: { viewerCertificate: if std.isArray(v=viewerCertificate) then viewerCertificate else [viewerCertificate] } } },
      '#withViewerCertificateMixin':: d.fn(help='"The SSL configuration for this distribution (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='viewerCertificate', type=d.T.array)]),
      withViewerCertificateMixin(viewerCertificate): { spec+: { forProvider+: { viewerCertificate+: if std.isArray(v=viewerCertificate) then viewerCertificate else [viewerCertificate] } } },
      '#withWaitForDeployment':: d.fn(help='"If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true."', args=[d.arg(name='waitForDeployment', type=d.T.boolean)]),
      withWaitForDeployment(waitForDeployment): { spec+: { forProvider+: { waitForDeployment: waitForDeployment } } },
      '#withWebAclId':: d.fn(help='"Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned."', args=[d.arg(name='webAclId', type=d.T.string)]),
      withWebAclId(webAclId): { spec+: { forProvider+: { webAclId: webAclId } } },
    },
    '#initProvider':: d.obj(help='"THIS IS A BETA FIELD. It will be honored\\nunless the Management Policies feature flag is disabled.\\nInitProvider holds the same fields as ForProvider, with the exception\\nof Identifier and other resource reference fields. The fields that are\\nin InitProvider are merged into ForProvider when the resource is created.\\nThe same fields are also added to the terraform ignore_changes hook, to\\navoid updating them after creation. This is useful for fields that are\\nrequired on creation, but we do not desire to update them after creation,\\nfor example because of an external controller is managing them, like an\\nautoscaler."'),
    initProvider: {
      '#customErrorResponse':: d.obj(help='"One or more custom error response elements (multiples allowed)."'),
      customErrorResponse: {
        '#withErrorCachingMinTtl':: d.fn(help='"Minimum amount of time you want HTTP error codes to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated."', args=[d.arg(name='errorCachingMinTtl', type=d.T.number)]),
        withErrorCachingMinTtl(errorCachingMinTtl): { errorCachingMinTtl: errorCachingMinTtl },
        '#withErrorCode':: d.fn(help='"4xx or 5xx HTTP status code that you want to customize."', args=[d.arg(name='errorCode', type=d.T.number)]),
        withErrorCode(errorCode): { errorCode: errorCode },
        '#withResponseCode':: d.fn(help='"HTTP status code that you want CloudFront to return with the custom error page to the viewer."', args=[d.arg(name='responseCode', type=d.T.number)]),
        withResponseCode(responseCode): { responseCode: responseCode },
        '#withResponsePagePath':: d.fn(help='"Path of the custom error page (for example, /custom_404.html)."', args=[d.arg(name='responsePagePath', type=d.T.string)]),
        withResponsePagePath(responsePagePath): { responsePagePath: responsePagePath },
      },
      '#defaultCacheBehavior':: d.obj(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."'),
      defaultCacheBehavior: {
        '#forwardedValues':: d.obj(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."'),
        forwardedValues: {
          '#cookies':: d.obj(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."'),
          cookies: {
            '#withForward':: d.fn(help='"Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names."', args=[d.arg(name='forward', type=d.T.string)]),
            withForward(forward): { forward: forward },
            '#withWhitelistedNames':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNames(whitelistedNames): { whitelistedNames: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
            '#withWhitelistedNamesMixin':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNamesMixin(whitelistedNames): { whitelistedNames+: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
          },
          '#withCookies':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookies(cookies): { cookies: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withCookiesMixin':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookiesMixin(cookies): { cookies+: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withHeaders':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."', args=[d.arg(name='headers', type=d.T.array)]),
          withHeaders(headers): { headers: if std.isArray(v=headers) then headers else [headers] },
          '#withHeadersMixin':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
          withHeadersMixin(headers): { headers+: if std.isArray(v=headers) then headers else [headers] },
          '#withQueryString':: d.fn(help='"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior."', args=[d.arg(name='queryString', type=d.T.boolean)]),
          withQueryString(queryString): { queryString: queryString },
          '#withQueryStringCacheKeys':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeys(queryStringCacheKeys): { queryStringCacheKeys: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
          '#withQueryStringCacheKeysMixin':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeysMixin(queryStringCacheKeys): { queryStringCacheKeys+: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
        },
        '#functionAssociation':: d.obj(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."'),
        functionAssociation: {
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withFunctionArn':: d.fn(help='"ARN of the CloudFront function."', args=[d.arg(name='functionArn', type=d.T.string)]),
          withFunctionArn(functionArn): { functionArn: functionArn },
        },
        '#grpcConfig':: d.obj(help='"A config block that sets the grpc config."'),
        grpcConfig: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
        },
        '#lambdaFunctionAssociation':: d.obj(help='"A config block that triggers a lambda function with specific actions (maximum 4)."'),
        lambdaFunctionAssociation: {
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withIncludeBody':: d.fn(help='"When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false."', args=[d.arg(name='includeBody', type=d.T.boolean)]),
          withIncludeBody(includeBody): { includeBody: includeBody },
          '#withLambdaArn':: d.fn(help='"ARN of the Lambda function."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { lambdaArn: lambdaArn },
        },
        '#withAllowedMethods':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethods(allowedMethods): { allowedMethods: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedMethodsMixin':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethodsMixin(allowedMethods): { allowedMethods+: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withCachePolicyId':: d.fn(help='"Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set."', args=[d.arg(name='cachePolicyId', type=d.T.string)]),
        withCachePolicyId(cachePolicyId): { cachePolicyId: cachePolicyId },
        '#withCachedMethods':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethods(cachedMethods): { cachedMethods: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCachedMethodsMixin':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethodsMixin(cachedMethods): { cachedMethods+: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCompress':: d.fn(help='"Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false)."', args=[d.arg(name='compress', type=d.T.boolean)]),
        withCompress(compress): { compress: compress },
        '#withDefaultTtl':: d.fn(help='"Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='defaultTtl', type=d.T.number)]),
        withDefaultTtl(defaultTtl): { defaultTtl: defaultTtl },
        '#withFieldLevelEncryptionId':: d.fn(help='"Field level encryption configuration ID."', args=[d.arg(name='fieldLevelEncryptionId', type=d.T.string)]),
        withFieldLevelEncryptionId(fieldLevelEncryptionId): { fieldLevelEncryptionId: fieldLevelEncryptionId },
        '#withForwardedValues':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValues(forwardedValues): { forwardedValues: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withForwardedValuesMixin':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValuesMixin(forwardedValues): { forwardedValues+: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withFunctionAssociation':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociation(functionAssociation): { functionAssociation: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withFunctionAssociationMixin':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociationMixin(functionAssociation): { functionAssociation+: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withGrpcConfig':: d.fn(help='"A config block that sets the grpc config."', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfig(grpcConfig): { grpcConfig: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withGrpcConfigMixin':: d.fn(help='"A config block that sets the grpc config."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfigMixin(grpcConfig): { grpcConfig+: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withLambdaFunctionAssociation':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociation(lambdaFunctionAssociation): { lambdaFunctionAssociation: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withLambdaFunctionAssociationMixin':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociationMixin(lambdaFunctionAssociation): { lambdaFunctionAssociation+: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withMaxTtl':: d.fn(help='"Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='maxTtl', type=d.T.number)]),
        withMaxTtl(maxTtl): { maxTtl: maxTtl },
        '#withMinTtl':: d.fn(help='"Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='minTtl', type=d.T.number)]),
        withMinTtl(minTtl): { minTtl: minTtl },
        '#withOriginRequestPolicyId':: d.fn(help='"Unique identifier of the origin request policy that is attached to the behavior."', args=[d.arg(name='originRequestPolicyId', type=d.T.string)]),
        withOriginRequestPolicyId(originRequestPolicyId): { originRequestPolicyId: originRequestPolicyId },
        '#withRealtimeLogConfigArn':: d.fn(help='"ARN of the real-time log configuration that is attached to this cache behavior."', args=[d.arg(name='realtimeLogConfigArn', type=d.T.string)]),
        withRealtimeLogConfigArn(realtimeLogConfigArn): { realtimeLogConfigArn: realtimeLogConfigArn },
        '#withResponseHeadersPolicyId':: d.fn(help='"Identifier for a response headers policy."', args=[d.arg(name='responseHeadersPolicyId', type=d.T.string)]),
        withResponseHeadersPolicyId(responseHeadersPolicyId): { responseHeadersPolicyId: responseHeadersPolicyId },
        '#withSmoothStreaming':: d.fn(help='"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior."', args=[d.arg(name='smoothStreaming', type=d.T.boolean)]),
        withSmoothStreaming(smoothStreaming): { smoothStreaming: smoothStreaming },
        '#withTargetOriginId':: d.fn(help='"Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."', args=[d.arg(name='targetOriginId', type=d.T.string)]),
        withTargetOriginId(targetOriginId): { targetOriginId: targetOriginId },
        '#withTrustedKeyGroups':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroups(trustedKeyGroups): { trustedKeyGroups: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedKeyGroupsMixin':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroupsMixin(trustedKeyGroups): { trustedKeyGroups+: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedSigners':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSigners(trustedSigners): { trustedSigners: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withTrustedSignersMixin':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSignersMixin(trustedSigners): { trustedSigners+: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withViewerProtocolPolicy':: d.fn(help='"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https."', args=[d.arg(name='viewerProtocolPolicy', type=d.T.string)]),
        withViewerProtocolPolicy(viewerProtocolPolicy): { viewerProtocolPolicy: viewerProtocolPolicy },
      },
      '#loggingConfig':: d.obj(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."'),
      loggingConfig: {
        '#withBucket':: d.fn(help='"Amazon S3 bucket to store the access logs in, for example, myawslogbucket.s3.amazonaws.com. The bucket must have correct ACL attached with \\"FULL_CONTROL\\" permission for \\"awslogsdelivery\\" account (Canonical ID: \\"c4c1ede66af53448b93c283ce9448c4ba468c9432aa01d700d3878632f77d2d0\\") for log transfer to work."', args=[d.arg(name='bucket', type=d.T.string)]),
        withBucket(bucket): { bucket: bucket },
        '#withIncludeCookies':: d.fn(help='"Whether to include cookies in access logs (default: false)."', args=[d.arg(name='includeCookies', type=d.T.boolean)]),
        withIncludeCookies(includeCookies): { includeCookies: includeCookies },
        '#withPrefix':: d.fn(help='"Prefix to the access log filenames for this distribution, for example, myprefix/."', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
      },
      '#orderedCacheBehavior':: d.obj(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."'),
      orderedCacheBehavior: {
        '#forwardedValues':: d.obj(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."'),
        forwardedValues: {
          '#cookies':: d.obj(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."'),
          cookies: {
            '#withForward':: d.fn(help='"Whether you want CloudFront to forward cookies to the origin that is associated with this cache behavior. You can specify all, none or whitelist. If whitelist, you must include the subsequent whitelisted_names."', args=[d.arg(name='forward', type=d.T.string)]),
            withForward(forward): { forward: forward },
            '#withWhitelistedNames':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNames(whitelistedNames): { whitelistedNames: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
            '#withWhitelistedNamesMixin':: d.fn(help='"If you have specified whitelist to forward, the whitelisted cookies that you want CloudFront to forward to your origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='whitelistedNames', type=d.T.array)]),
            withWhitelistedNamesMixin(whitelistedNames): { whitelistedNames+: if std.isArray(v=whitelistedNames) then whitelistedNames else [whitelistedNames] },
          },
          '#withCookies':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookies(cookies): { cookies: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withCookiesMixin':: d.fn(help='"The forwarded values cookies that specifies how CloudFront handles cookies (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cookies', type=d.T.array)]),
          withCookiesMixin(cookies): { cookies+: if std.isArray(v=cookies) then cookies else [cookies] },
          '#withHeaders':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."', args=[d.arg(name='headers', type=d.T.array)]),
          withHeaders(headers): { headers: if std.isArray(v=headers) then headers else [headers] },
          '#withHeadersMixin':: d.fn(help='"Headers, if any, that you want CloudFront to vary upon for this cache behavior. Specify * to include all headers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
          withHeadersMixin(headers): { headers+: if std.isArray(v=headers) then headers else [headers] },
          '#withQueryString':: d.fn(help='"Indicates whether you want CloudFront to forward query strings to the origin that is associated with this cache behavior."', args=[d.arg(name='queryString', type=d.T.boolean)]),
          withQueryString(queryString): { queryString: queryString },
          '#withQueryStringCacheKeys':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeys(queryStringCacheKeys): { queryStringCacheKeys: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
          '#withQueryStringCacheKeysMixin':: d.fn(help='"When specified, along with a value of true for query_string, all query strings are forwarded, however only the query string keys listed in this argument are cached. When omitted with a value of true for query_string, all query string keys are cached."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='queryStringCacheKeys', type=d.T.array)]),
          withQueryStringCacheKeysMixin(queryStringCacheKeys): { queryStringCacheKeys+: if std.isArray(v=queryStringCacheKeys) then queryStringCacheKeys else [queryStringCacheKeys] },
        },
        '#functionAssociation':: d.obj(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."'),
        functionAssociation: {
          '#functionArnRef':: d.obj(help='"Reference to a Function in cloudfront to populate functionArn."'),
          functionArnRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { functionArnRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { functionArnRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { functionArnRef+: { name: name } },
          },
          '#functionArnSelector':: d.obj(help='"Selector for a Function in cloudfront to populate functionArn."'),
          functionArnSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { functionArnSelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { functionArnSelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { functionArnSelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { functionArnSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { functionArnSelector+: { matchLabels+: matchLabels } },
          },
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withFunctionArn':: d.fn(help='"ARN of the CloudFront function."', args=[d.arg(name='functionArn', type=d.T.string)]),
          withFunctionArn(functionArn): { functionArn: functionArn },
        },
        '#grpcConfig':: d.obj(help='"A config block that sets the grpc config."'),
        grpcConfig: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
        },
        '#lambdaFunctionAssociation':: d.obj(help='"A config block that triggers a lambda function with specific actions (maximum 4)."'),
        lambdaFunctionAssociation: {
          '#lambdaArnRef':: d.obj(help='"Reference to a Function in lambda to populate lambdaArn."'),
          lambdaArnRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { lambdaArnRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { lambdaArnRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { lambdaArnRef+: { name: name } },
          },
          '#lambdaArnSelector':: d.obj(help='"Selector for a Function in lambda to populate lambdaArn."'),
          lambdaArnSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { lambdaArnSelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { lambdaArnSelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { lambdaArnSelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { lambdaArnSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { lambdaArnSelector+: { matchLabels+: matchLabels } },
          },
          '#withEventType':: d.fn(help='"Specific event to trigger this function. Valid values: viewer-request, origin-request, viewer-response, origin-response."', args=[d.arg(name='eventType', type=d.T.string)]),
          withEventType(eventType): { eventType: eventType },
          '#withIncludeBody':: d.fn(help='"When set to true it exposes the request body to the lambda function. Defaults to false. Valid values: true, false."', args=[d.arg(name='includeBody', type=d.T.boolean)]),
          withIncludeBody(includeBody): { includeBody: includeBody },
          '#withLambdaArn':: d.fn(help='"ARN of the Lambda function."', args=[d.arg(name='lambdaArn', type=d.T.string)]),
          withLambdaArn(lambdaArn): { lambdaArn: lambdaArn },
        },
        '#withAllowedMethods':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethods(allowedMethods): { allowedMethods: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withAllowedMethodsMixin':: d.fn(help='"Controls which HTTP methods CloudFront processes and forwards to your Amazon S3 bucket or your custom origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='allowedMethods', type=d.T.array)]),
        withAllowedMethodsMixin(allowedMethods): { allowedMethods+: if std.isArray(v=allowedMethods) then allowedMethods else [allowedMethods] },
        '#withCachePolicyId':: d.fn(help='"Unique identifier of the cache policy that is attached to the cache behavior. If configuring the default_cache_behavior either cache_policy_id or forwarded_values must be set."', args=[d.arg(name='cachePolicyId', type=d.T.string)]),
        withCachePolicyId(cachePolicyId): { cachePolicyId: cachePolicyId },
        '#withCachedMethods':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethods(cachedMethods): { cachedMethods: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCachedMethodsMixin':: d.fn(help='"Controls whether CloudFront caches the response to requests using the specified HTTP methods."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cachedMethods', type=d.T.array)]),
        withCachedMethodsMixin(cachedMethods): { cachedMethods+: if std.isArray(v=cachedMethods) then cachedMethods else [cachedMethods] },
        '#withCompress':: d.fn(help='"Whether you want CloudFront to automatically compress content for web requests that include Accept-Encoding: gzip in the request header (default: false)."', args=[d.arg(name='compress', type=d.T.boolean)]),
        withCompress(compress): { compress: compress },
        '#withDefaultTtl':: d.fn(help='"Default amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request in the absence of an Cache-Control max-age or Expires header. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='defaultTtl', type=d.T.number)]),
        withDefaultTtl(defaultTtl): { defaultTtl: defaultTtl },
        '#withFieldLevelEncryptionId':: d.fn(help='"Field level encryption configuration ID."', args=[d.arg(name='fieldLevelEncryptionId', type=d.T.string)]),
        withFieldLevelEncryptionId(fieldLevelEncryptionId): { fieldLevelEncryptionId: fieldLevelEncryptionId },
        '#withForwardedValues':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValues(forwardedValues): { forwardedValues: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withForwardedValuesMixin':: d.fn(help='"The forwarded values configuration that specifies how CloudFront handles query strings, cookies and headers (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='forwardedValues', type=d.T.array)]),
        withForwardedValuesMixin(forwardedValues): { forwardedValues+: if std.isArray(v=forwardedValues) then forwardedValues else [forwardedValues] },
        '#withFunctionAssociation':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociation(functionAssociation): { functionAssociation: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withFunctionAssociationMixin':: d.fn(help='"A config block that triggers a cloudfront function with specific actions (maximum 2)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='functionAssociation', type=d.T.array)]),
        withFunctionAssociationMixin(functionAssociation): { functionAssociation+: if std.isArray(v=functionAssociation) then functionAssociation else [functionAssociation] },
        '#withGrpcConfig':: d.fn(help='"A config block that sets the grpc config."', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfig(grpcConfig): { grpcConfig: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withGrpcConfigMixin':: d.fn(help='"A config block that sets the grpc config."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='grpcConfig', type=d.T.array)]),
        withGrpcConfigMixin(grpcConfig): { grpcConfig+: if std.isArray(v=grpcConfig) then grpcConfig else [grpcConfig] },
        '#withLambdaFunctionAssociation':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociation(lambdaFunctionAssociation): { lambdaFunctionAssociation: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withLambdaFunctionAssociationMixin':: d.fn(help='"A config block that triggers a lambda function with specific actions (maximum 4)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lambdaFunctionAssociation', type=d.T.array)]),
        withLambdaFunctionAssociationMixin(lambdaFunctionAssociation): { lambdaFunctionAssociation+: if std.isArray(v=lambdaFunctionAssociation) then lambdaFunctionAssociation else [lambdaFunctionAssociation] },
        '#withMaxTtl':: d.fn(help='"Maximum amount of time (in seconds) that an object is in a CloudFront cache before CloudFront forwards another request to your origin to determine whether the object has been updated. Only effective in the presence of Cache-Control max-age, Cache-Control s-maxage, and Expires headers. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='maxTtl', type=d.T.number)]),
        withMaxTtl(maxTtl): { maxTtl: maxTtl },
        '#withMinTtl':: d.fn(help='"Minimum amount of time that you want objects to stay in CloudFront caches before CloudFront queries your origin to see whether the object has been updated. Defaults to 0 seconds. The TTL defined in Cache Policy overrides this configuration."', args=[d.arg(name='minTtl', type=d.T.number)]),
        withMinTtl(minTtl): { minTtl: minTtl },
        '#withOriginRequestPolicyId':: d.fn(help='"Unique identifier of the origin request policy that is attached to the behavior."', args=[d.arg(name='originRequestPolicyId', type=d.T.string)]),
        withOriginRequestPolicyId(originRequestPolicyId): { originRequestPolicyId: originRequestPolicyId },
        '#withPathPattern':: d.fn(help='"Pattern (for example, images/*.jpg) that specifies which requests you want this cache behavior to apply to."', args=[d.arg(name='pathPattern', type=d.T.string)]),
        withPathPattern(pathPattern): { pathPattern: pathPattern },
        '#withRealtimeLogConfigArn':: d.fn(help='"ARN of the real-time log configuration that is attached to this cache behavior."', args=[d.arg(name='realtimeLogConfigArn', type=d.T.string)]),
        withRealtimeLogConfigArn(realtimeLogConfigArn): { realtimeLogConfigArn: realtimeLogConfigArn },
        '#withResponseHeadersPolicyId':: d.fn(help='"Identifier for a response headers policy."', args=[d.arg(name='responseHeadersPolicyId', type=d.T.string)]),
        withResponseHeadersPolicyId(responseHeadersPolicyId): { responseHeadersPolicyId: responseHeadersPolicyId },
        '#withSmoothStreaming':: d.fn(help='"Indicates whether you want to distribute media files in Microsoft Smooth Streaming format using the origin that is associated with this cache behavior."', args=[d.arg(name='smoothStreaming', type=d.T.boolean)]),
        withSmoothStreaming(smoothStreaming): { smoothStreaming: smoothStreaming },
        '#withTargetOriginId':: d.fn(help='"Value of ID for the origin that you want CloudFront to route requests to when a request matches the path pattern either for a cache behavior or for the default cache behavior."', args=[d.arg(name='targetOriginId', type=d.T.string)]),
        withTargetOriginId(targetOriginId): { targetOriginId: targetOriginId },
        '#withTrustedKeyGroups':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroups(trustedKeyGroups): { trustedKeyGroups: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedKeyGroupsMixin':: d.fn(help='"List of key group IDs that CloudFront can use to validate signed URLs or signed cookies. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedKeyGroups', type=d.T.array)]),
        withTrustedKeyGroupsMixin(trustedKeyGroups): { trustedKeyGroups+: if std.isArray(v=trustedKeyGroups) then trustedKeyGroups else [trustedKeyGroups] },
        '#withTrustedSigners':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSigners(trustedSigners): { trustedSigners: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withTrustedSignersMixin':: d.fn(help='"List of AWS account IDs (or self) that you want to allow to create signed URLs for private content. See the CloudFront User Guide for more information about this feature."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedSigners', type=d.T.array)]),
        withTrustedSignersMixin(trustedSigners): { trustedSigners+: if std.isArray(v=trustedSigners) then trustedSigners else [trustedSigners] },
        '#withViewerProtocolPolicy':: d.fn(help='"Use this element to specify the protocol that users can use to access the files in the origin specified by TargetOriginId when a request matches the path pattern in PathPattern. One of allow-all, https-only, or redirect-to-https."', args=[d.arg(name='viewerProtocolPolicy', type=d.T.string)]),
        withViewerProtocolPolicy(viewerProtocolPolicy): { viewerProtocolPolicy: viewerProtocolPolicy },
      },
      '#origin':: d.obj(help='"One or more origins for this distribution (multiples allowed)."'),
      origin: {
        '#customHeader':: d.obj(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."'),
        customHeader: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#customOriginConfig':: d.obj(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."'),
        customOriginConfig: {
          '#withHttpPort':: d.fn(help='"HTTP port the custom origin listens on."', args=[d.arg(name='httpPort', type=d.T.number)]),
          withHttpPort(httpPort): { httpPort: httpPort },
          '#withHttpsPort':: d.fn(help='"HTTPS port the custom origin listens on."', args=[d.arg(name='httpsPort', type=d.T.number)]),
          withHttpsPort(httpsPort): { httpsPort: httpsPort },
          '#withOriginKeepaliveTimeout':: d.fn(help='"The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5."', args=[d.arg(name='originKeepaliveTimeout', type=d.T.number)]),
          withOriginKeepaliveTimeout(originKeepaliveTimeout): { originKeepaliveTimeout: originKeepaliveTimeout },
          '#withOriginProtocolPolicy':: d.fn(help='"Origin protocol policy to apply to your origin. One of http-only, https-only, or match-viewer."', args=[d.arg(name='originProtocolPolicy', type=d.T.string)]),
          withOriginProtocolPolicy(originProtocolPolicy): { originProtocolPolicy: originProtocolPolicy },
          '#withOriginReadTimeout':: d.fn(help='"The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30."', args=[d.arg(name='originReadTimeout', type=d.T.number)]),
          withOriginReadTimeout(originReadTimeout): { originReadTimeout: originReadTimeout },
          '#withOriginSslProtocols':: d.fn(help='"List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide."', args=[d.arg(name='originSslProtocols', type=d.T.array)]),
          withOriginSslProtocols(originSslProtocols): { originSslProtocols: if std.isArray(v=originSslProtocols) then originSslProtocols else [originSslProtocols] },
          '#withOriginSslProtocolsMixin':: d.fn(help='"List of SSL/TLS protocols that CloudFront can use when connecting to your origin over HTTPS. Valid values: SSLv3, TLSv1, TLSv1.1, TLSv1.2. For more information, see Minimum Origin SSL Protocol in the Amazon CloudFront Developer Guide."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originSslProtocols', type=d.T.array)]),
          withOriginSslProtocolsMixin(originSslProtocols): { originSslProtocols+: if std.isArray(v=originSslProtocols) then originSslProtocols else [originSslProtocols] },
        },
        '#originAccessControlIdRef':: d.obj(help='"Reference to a OriginAccessControl in cloudfront to populate originAccessControlId."'),
        originAccessControlIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { originAccessControlIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { originAccessControlIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { originAccessControlIdRef+: { name: name } },
        },
        '#originAccessControlIdSelector':: d.obj(help='"Selector for a OriginAccessControl in cloudfront to populate originAccessControlId."'),
        originAccessControlIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { originAccessControlIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { originAccessControlIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { originAccessControlIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { originAccessControlIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { originAccessControlIdSelector+: { matchLabels+: matchLabels } },
        },
        '#originShield':: d.obj(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."'),
        originShield: {
          '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
          '#withOriginShieldRegion':: d.fn(help='"AWS Region for Origin Shield. To specify a region, use the region code, not the region name. For example, specify the US East (Ohio) region as us-east-2."', args=[d.arg(name='originShieldRegion', type=d.T.string)]),
          withOriginShieldRegion(originShieldRegion): { originShieldRegion: originShieldRegion },
        },
        '#s3OriginConfig':: d.obj(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."'),
        s3OriginConfig: {
          '#originAccessIdentityRef':: d.obj(help='"Reference to a OriginAccessIdentity in cloudfront to populate originAccessIdentity."'),
          originAccessIdentityRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { originAccessIdentityRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { originAccessIdentityRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { originAccessIdentityRef+: { name: name } },
          },
          '#originAccessIdentitySelector':: d.obj(help='"Selector for a OriginAccessIdentity in cloudfront to populate originAccessIdentity."'),
          originAccessIdentitySelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { originAccessIdentitySelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { originAccessIdentitySelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference\\nas the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { originAccessIdentitySelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { originAccessIdentitySelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { originAccessIdentitySelector+: { matchLabels+: matchLabels } },
          },
          '#withOriginAccessIdentity':: d.fn(help='"The CloudFront origin access identity to associate with the origin."', args=[d.arg(name='originAccessIdentity', type=d.T.string)]),
          withOriginAccessIdentity(originAccessIdentity): { originAccessIdentity: originAccessIdentity },
        },
        '#vpcOriginConfig':: d.obj(help='"The VPC origin configuration."'),
        vpcOriginConfig: {
          '#withOriginKeepaliveTimeout':: d.fn(help='"The Custom KeepAlive timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 5."', args=[d.arg(name='originKeepaliveTimeout', type=d.T.number)]),
          withOriginKeepaliveTimeout(originKeepaliveTimeout): { originKeepaliveTimeout: originKeepaliveTimeout },
          '#withOriginReadTimeout':: d.fn(help='"The Custom Read timeout, in seconds. By default, AWS enforces an upper limit of 60. But you can request an increase. Defaults to 30."', args=[d.arg(name='originReadTimeout', type=d.T.number)]),
          withOriginReadTimeout(originReadTimeout): { originReadTimeout: originReadTimeout },
          '#withVpcOriginId':: d.fn(help='"The VPC origin ID."', args=[d.arg(name='vpcOriginId', type=d.T.string)]),
          withVpcOriginId(vpcOriginId): { vpcOriginId: vpcOriginId },
        },
        '#withConnectionAttempts':: d.fn(help='"Number of times that CloudFront attempts to connect to the origin. Must be between 1-3. Defaults to 3."', args=[d.arg(name='connectionAttempts', type=d.T.number)]),
        withConnectionAttempts(connectionAttempts): { connectionAttempts: connectionAttempts },
        '#withConnectionTimeout':: d.fn(help='"Number of seconds that CloudFront waits when trying to establish a connection to the origin. Must be between 1-10. Defaults to 10."', args=[d.arg(name='connectionTimeout', type=d.T.number)]),
        withConnectionTimeout(connectionTimeout): { connectionTimeout: connectionTimeout },
        '#withCustomHeader':: d.fn(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."', args=[d.arg(name='customHeader', type=d.T.array)]),
        withCustomHeader(customHeader): { customHeader: if std.isArray(v=customHeader) then customHeader else [customHeader] },
        '#withCustomHeaderMixin':: d.fn(help='"One or more sub-resources with name and value parameters that specify header data that will be sent to the origin (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customHeader', type=d.T.array)]),
        withCustomHeaderMixin(customHeader): { customHeader+: if std.isArray(v=customHeader) then customHeader else [customHeader] },
        '#withCustomOriginConfig':: d.fn(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."', args=[d.arg(name='customOriginConfig', type=d.T.array)]),
        withCustomOriginConfig(customOriginConfig): { customOriginConfig: if std.isArray(v=customOriginConfig) then customOriginConfig else [customOriginConfig] },
        '#withCustomOriginConfigMixin':: d.fn(help='"The CloudFront custom origin configuration information. If an S3 origin is required, use origin_access_control_id or s3_origin_config instead."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customOriginConfig', type=d.T.array)]),
        withCustomOriginConfigMixin(customOriginConfig): { customOriginConfig+: if std.isArray(v=customOriginConfig) then customOriginConfig else [customOriginConfig] },
        '#withDomainName':: d.fn(help='"DNS domain name of either the S3 bucket, or web site of your custom origin."', args=[d.arg(name='domainName', type=d.T.string)]),
        withDomainName(domainName): { domainName: domainName },
        '#withOriginAccessControlId':: d.fn(help='"Unique identifier of a CloudFront origin access control for this origin."', args=[d.arg(name='originAccessControlId', type=d.T.string)]),
        withOriginAccessControlId(originAccessControlId): { originAccessControlId: originAccessControlId },
        '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
        withOriginId(originId): { originId: originId },
        '#withOriginPath':: d.fn(help='"Optional element that causes CloudFront to request your content from a directory in your Amazon S3 bucket or your custom origin."', args=[d.arg(name='originPath', type=d.T.string)]),
        withOriginPath(originPath): { originPath: originPath },
        '#withOriginShield':: d.fn(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."', args=[d.arg(name='originShield', type=d.T.array)]),
        withOriginShield(originShield): { originShield: if std.isArray(v=originShield) then originShield else [originShield] },
        '#withOriginShieldMixin':: d.fn(help='"CloudFront Origin Shield configuration information. Using Origin Shield can help reduce the load on your origin. For more information, see Using Origin Shield in the Amazon CloudFront Developer Guide."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originShield', type=d.T.array)]),
        withOriginShieldMixin(originShield): { originShield+: if std.isArray(v=originShield) then originShield else [originShield] },
        '#withResponseCompletionTimeout':: d.fn(help='"Time (in seconds) that a request from CloudFront to the origin can stay open and wait for a response. Must be integer greater than or equal to the value of origin_read_timeout. If omitted or explicitly set to 0, no maximum value is enforced."', args=[d.arg(name='responseCompletionTimeout', type=d.T.number)]),
        withResponseCompletionTimeout(responseCompletionTimeout): { responseCompletionTimeout: responseCompletionTimeout },
        '#withS3OriginConfig':: d.fn(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."', args=[d.arg(name='s3OriginConfig', type=d.T.array)]),
        withS3OriginConfig(s3OriginConfig): { s3OriginConfig: if std.isArray(v=s3OriginConfig) then s3OriginConfig else [s3OriginConfig] },
        '#withS3OriginConfigMixin':: d.fn(help='"CloudFront S3 origin configuration information. If a custom origin is required, use custom_origin_config instead."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='s3OriginConfig', type=d.T.array)]),
        withS3OriginConfigMixin(s3OriginConfig): { s3OriginConfig+: if std.isArray(v=s3OriginConfig) then s3OriginConfig else [s3OriginConfig] },
        '#withVpcOriginConfig':: d.fn(help='"The VPC origin configuration."', args=[d.arg(name='vpcOriginConfig', type=d.T.array)]),
        withVpcOriginConfig(vpcOriginConfig): { vpcOriginConfig: if std.isArray(v=vpcOriginConfig) then vpcOriginConfig else [vpcOriginConfig] },
        '#withVpcOriginConfigMixin':: d.fn(help='"The VPC origin configuration."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='vpcOriginConfig', type=d.T.array)]),
        withVpcOriginConfigMixin(vpcOriginConfig): { vpcOriginConfig+: if std.isArray(v=vpcOriginConfig) then vpcOriginConfig else [vpcOriginConfig] },
      },
      '#originGroup':: d.obj(help='"One or more origin_group for this distribution (multiples allowed)."'),
      originGroup: {
        '#failoverCriteria':: d.obj(help='"The failover criteria for when to failover to the secondary origin."'),
        failoverCriteria: {
          '#withStatusCodes':: d.fn(help='"List of HTTP status codes for the origin group."', args=[d.arg(name='statusCodes', type=d.T.array)]),
          withStatusCodes(statusCodes): { statusCodes: if std.isArray(v=statusCodes) then statusCodes else [statusCodes] },
          '#withStatusCodesMixin':: d.fn(help='"List of HTTP status codes for the origin group."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='statusCodes', type=d.T.array)]),
          withStatusCodesMixin(statusCodes): { statusCodes+: if std.isArray(v=statusCodes) then statusCodes else [statusCodes] },
        },
        '#member':: d.obj(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."'),
        member: {
          '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
          withOriginId(originId): { originId: originId },
        },
        '#withFailoverCriteria':: d.fn(help='"The failover criteria for when to failover to the secondary origin."', args=[d.arg(name='failoverCriteria', type=d.T.array)]),
        withFailoverCriteria(failoverCriteria): { failoverCriteria: if std.isArray(v=failoverCriteria) then failoverCriteria else [failoverCriteria] },
        '#withFailoverCriteriaMixin':: d.fn(help='"The failover criteria for when to failover to the secondary origin."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='failoverCriteria', type=d.T.array)]),
        withFailoverCriteriaMixin(failoverCriteria): { failoverCriteria+: if std.isArray(v=failoverCriteria) then failoverCriteria else [failoverCriteria] },
        '#withMember':: d.fn(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."', args=[d.arg(name='member', type=d.T.array)]),
        withMember(member): { member: if std.isArray(v=member) then member else [member] },
        '#withMemberMixin':: d.fn(help='"Ordered member configuration blocks assigned to the origin group, where the first member is the primary origin. You must specify two members."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='member', type=d.T.array)]),
        withMemberMixin(member): { member+: if std.isArray(v=member) then member else [member] },
        '#withOriginId':: d.fn(help='"Unique identifier for the origin."', args=[d.arg(name='originId', type=d.T.string)]),
        withOriginId(originId): { originId: originId },
      },
      '#restrictions':: d.obj(help='"The restriction configuration for this distribution (maximum one)."'),
      restrictions: {
        '#geoRestriction':: d.obj(help=''),
        geoRestriction: {
          '#withLocations':: d.fn(help='"ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used."', args=[d.arg(name='locations', type=d.T.array)]),
          withLocations(locations): { locations: if std.isArray(v=locations) then locations else [locations] },
          '#withLocationsMixin':: d.fn(help='"ISO 3166-1-alpha-2 codes for which you want CloudFront either to distribute your content (whitelist) or not distribute your content (blacklist). If the type is specified as none an empty array can be used."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='locations', type=d.T.array)]),
          withLocationsMixin(locations): { locations+: if std.isArray(v=locations) then locations else [locations] },
          '#withRestrictionType':: d.fn(help='"Method that you want to use to restrict distribution of your content by country: none, whitelist, or blacklist."', args=[d.arg(name='restrictionType', type=d.T.string)]),
          withRestrictionType(restrictionType): { restrictionType: restrictionType },
        },
        '#withGeoRestriction':: d.fn(help='', args=[d.arg(name='geoRestriction', type=d.T.array)]),
        withGeoRestriction(geoRestriction): { geoRestriction: if std.isArray(v=geoRestriction) then geoRestriction else [geoRestriction] },
        '#withGeoRestrictionMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='geoRestriction', type=d.T.array)]),
        withGeoRestrictionMixin(geoRestriction): { geoRestriction+: if std.isArray(v=geoRestriction) then geoRestriction else [geoRestriction] },
      },
      '#viewerCertificate':: d.obj(help='"The SSL configuration for this distribution (maximum one)."'),
      viewerCertificate: {
        '#withAcmCertificateArn':: d.fn(help='"ARN of the AWS Certificate Manager certificate that you wish to use with this distribution. Specify this, cloudfront_default_certificate, or iam_certificate_id.  The ACM certificate must be in  US-EAST-1."', args=[d.arg(name='acmCertificateArn', type=d.T.string)]),
        withAcmCertificateArn(acmCertificateArn): { acmCertificateArn: acmCertificateArn },
        '#withCloudfrontDefaultCertificate':: d.fn(help="\"true if you want viewers to use HTTPS to request your objects and you're using the CloudFront domain name for your distribution. Specify this, acm_certificate_arn, or iam_certificate_id.\"", args=[d.arg(name='cloudfrontDefaultCertificate', type=d.T.boolean)]),
        withCloudfrontDefaultCertificate(cloudfrontDefaultCertificate): { cloudfrontDefaultCertificate: cloudfrontDefaultCertificate },
        '#withIamCertificateId':: d.fn(help='"IAM certificate identifier of the custom viewer certificate for this distribution if you are using a custom domain. Specify this, acm_certificate_arn, or cloudfront_default_certificate."', args=[d.arg(name='iamCertificateId', type=d.T.string)]),
        withIamCertificateId(iamCertificateId): { iamCertificateId: iamCertificateId },
        '#withMinimumProtocolVersion':: d.fn(help='"Minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. Can only be set if cloudfront_default_certificate = false. See all possible values in this table under \\"Security policy.\\" Some examples include: TLSv1.2_2019 and TLSv1.2_2021. Default: TLSv1. NOTE: If you are using a custom certificate (specified with acm_certificate_arn or iam_certificate_id), and have specified sni-only in ssl_support_method, TLSv1 or later must be specified. If you have specified vip in ssl_support_method, only SSLv3 or TLSv1 can be specified. If you have specified cloudfront_default_certificate, TLSv1 must be specified."', args=[d.arg(name='minimumProtocolVersion', type=d.T.string)]),
        withMinimumProtocolVersion(minimumProtocolVersion): { minimumProtocolVersion: minimumProtocolVersion },
        '#withSslSupportMethod':: d.fn(help='"How you want CloudFront to serve HTTPS requests. One of vip, sni-only, or static-ip. Required if you specify acm_certificate_arn or iam_certificate_id. NOTE: vip causes CloudFront to use a dedicated IP address and may incur extra charges."', args=[d.arg(name='sslSupportMethod', type=d.T.string)]),
        withSslSupportMethod(sslSupportMethod): { sslSupportMethod: sslSupportMethod },
      },
      '#withAliases':: d.fn(help='"Extra CNAMEs (alternate domain names), if any, for this distribution."', args=[d.arg(name='aliases', type=d.T.array)]),
      withAliases(aliases): { spec+: { initProvider+: { aliases: if std.isArray(v=aliases) then aliases else [aliases] } } },
      '#withAliasesMixin':: d.fn(help='"Extra CNAMEs (alternate domain names), if any, for this distribution."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='aliases', type=d.T.array)]),
      withAliasesMixin(aliases): { spec+: { initProvider+: { aliases+: if std.isArray(v=aliases) then aliases else [aliases] } } },
      '#withAnycastIpListId':: d.fn(help='"ID of the Anycast static IP list that is associated with the distribution."', args=[d.arg(name='anycastIpListId', type=d.T.string)]),
      withAnycastIpListId(anycastIpListId): { spec+: { initProvider+: { anycastIpListId: anycastIpListId } } },
      '#withComment':: d.fn(help='"Any comments you want to include about the distribution."', args=[d.arg(name='comment', type=d.T.string)]),
      withComment(comment): { spec+: { initProvider+: { comment: comment } } },
      '#withContinuousDeploymentPolicyId':: d.fn(help='"Identifier of a continuous deployment policy. This argument should only be set on a production distribution. See the aws_cloudfront_continuous_deployment_policy resource for additional details."', args=[d.arg(name='continuousDeploymentPolicyId', type=d.T.string)]),
      withContinuousDeploymentPolicyId(continuousDeploymentPolicyId): { spec+: { initProvider+: { continuousDeploymentPolicyId: continuousDeploymentPolicyId } } },
      '#withCustomErrorResponse':: d.fn(help='"One or more custom error response elements (multiples allowed)."', args=[d.arg(name='customErrorResponse', type=d.T.array)]),
      withCustomErrorResponse(customErrorResponse): { spec+: { initProvider+: { customErrorResponse: if std.isArray(v=customErrorResponse) then customErrorResponse else [customErrorResponse] } } },
      '#withCustomErrorResponseMixin':: d.fn(help='"One or more custom error response elements (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customErrorResponse', type=d.T.array)]),
      withCustomErrorResponseMixin(customErrorResponse): { spec+: { initProvider+: { customErrorResponse+: if std.isArray(v=customErrorResponse) then customErrorResponse else [customErrorResponse] } } },
      '#withDefaultCacheBehavior':: d.fn(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."', args=[d.arg(name='defaultCacheBehavior', type=d.T.array)]),
      withDefaultCacheBehavior(defaultCacheBehavior): { spec+: { initProvider+: { defaultCacheBehavior: if std.isArray(v=defaultCacheBehavior) then defaultCacheBehavior else [defaultCacheBehavior] } } },
      '#withDefaultCacheBehaviorMixin':: d.fn(help='"Default cache behavior for this distribution (maximum one). Requires either cache_policy_id (preferred) or forwarded_values (deprecated) be set."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='defaultCacheBehavior', type=d.T.array)]),
      withDefaultCacheBehaviorMixin(defaultCacheBehavior): { spec+: { initProvider+: { defaultCacheBehavior+: if std.isArray(v=defaultCacheBehavior) then defaultCacheBehavior else [defaultCacheBehavior] } } },
      '#withDefaultRootObject':: d.fn(help='"Object that you want CloudFront to return (for example, index.html) when an end user requests the root URL."', args=[d.arg(name='defaultRootObject', type=d.T.string)]),
      withDefaultRootObject(defaultRootObject): { spec+: { initProvider+: { defaultRootObject: defaultRootObject } } },
      '#withEnabled':: d.fn(help='"Whether the distribution is enabled to accept end user requests for content."', args=[d.arg(name='enabled', type=d.T.boolean)]),
      withEnabled(enabled): { spec+: { initProvider+: { enabled: enabled } } },
      '#withHttpVersion':: d.fn(help='"Maximum HTTP version to support on the distribution. Allowed values are http1.1, http2, http2and3 and http3. The default is http2."', args=[d.arg(name='httpVersion', type=d.T.string)]),
      withHttpVersion(httpVersion): { spec+: { initProvider+: { httpVersion: httpVersion } } },
      '#withIsIpv6Enabled':: d.fn(help='"Whether the IPv6 is enabled for the distribution."', args=[d.arg(name='isIpv6Enabled', type=d.T.boolean)]),
      withIsIpv6Enabled(isIpv6Enabled): { spec+: { initProvider+: { isIpv6Enabled: isIpv6Enabled } } },
      '#withLoggingConfig':: d.fn(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."', args=[d.arg(name='loggingConfig', type=d.T.array)]),
      withLoggingConfig(loggingConfig): { spec+: { initProvider+: { loggingConfig: if std.isArray(v=loggingConfig) then loggingConfig else [loggingConfig] } } },
      '#withLoggingConfigMixin':: d.fn(help='"The logging configuration that controls how logs are written to your distribution (maximum one). AWS provides two versions of access logs for CloudFront: Legacy and v2. This argument configures legacy version standard logs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='loggingConfig', type=d.T.array)]),
      withLoggingConfigMixin(loggingConfig): { spec+: { initProvider+: { loggingConfig+: if std.isArray(v=loggingConfig) then loggingConfig else [loggingConfig] } } },
      '#withOrderedCacheBehavior':: d.fn(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."', args=[d.arg(name='orderedCacheBehavior', type=d.T.array)]),
      withOrderedCacheBehavior(orderedCacheBehavior): { spec+: { initProvider+: { orderedCacheBehavior: if std.isArray(v=orderedCacheBehavior) then orderedCacheBehavior else [orderedCacheBehavior] } } },
      '#withOrderedCacheBehaviorMixin':: d.fn(help='"Ordered list of cache behaviors resource for this distribution. List from top to bottom in order of precedence. The topmost cache behavior will have precedence 0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='orderedCacheBehavior', type=d.T.array)]),
      withOrderedCacheBehaviorMixin(orderedCacheBehavior): { spec+: { initProvider+: { orderedCacheBehavior+: if std.isArray(v=orderedCacheBehavior) then orderedCacheBehavior else [orderedCacheBehavior] } } },
      '#withOrigin':: d.fn(help='"One or more origins for this distribution (multiples allowed)."', args=[d.arg(name='origin', type=d.T.array)]),
      withOrigin(origin): { spec+: { initProvider+: { origin: if std.isArray(v=origin) then origin else [origin] } } },
      '#withOriginGroup':: d.fn(help='"One or more origin_group for this distribution (multiples allowed)."', args=[d.arg(name='originGroup', type=d.T.array)]),
      withOriginGroup(originGroup): { spec+: { initProvider+: { originGroup: if std.isArray(v=originGroup) then originGroup else [originGroup] } } },
      '#withOriginGroupMixin':: d.fn(help='"One or more origin_group for this distribution (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='originGroup', type=d.T.array)]),
      withOriginGroupMixin(originGroup): { spec+: { initProvider+: { originGroup+: if std.isArray(v=originGroup) then originGroup else [originGroup] } } },
      '#withOriginMixin':: d.fn(help='"One or more origins for this distribution (multiples allowed)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='origin', type=d.T.array)]),
      withOriginMixin(origin): { spec+: { initProvider+: { origin+: if std.isArray(v=origin) then origin else [origin] } } },
      '#withPriceClass':: d.fn(help='"Price class for this distribution. One of PriceClass_All, PriceClass_200, PriceClass_100."', args=[d.arg(name='priceClass', type=d.T.string)]),
      withPriceClass(priceClass): { spec+: { initProvider+: { priceClass: priceClass } } },
      '#withRestrictions':: d.fn(help='"The restriction configuration for this distribution (maximum one)."', args=[d.arg(name='restrictions', type=d.T.array)]),
      withRestrictions(restrictions): { spec+: { initProvider+: { restrictions: if std.isArray(v=restrictions) then restrictions else [restrictions] } } },
      '#withRestrictionsMixin':: d.fn(help='"The restriction configuration for this distribution (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='restrictions', type=d.T.array)]),
      withRestrictionsMixin(restrictions): { spec+: { initProvider+: { restrictions+: if std.isArray(v=restrictions) then restrictions else [restrictions] } } },
      '#withRetainOnDelete':: d.fn(help='"If this is set, the distribution needs to be deleted manually afterwards. Default: false."', args=[d.arg(name='retainOnDelete', type=d.T.boolean)]),
      withRetainOnDelete(retainOnDelete): { spec+: { initProvider+: { retainOnDelete: retainOnDelete } } },
      '#withStaging':: d.fn(help='"A Boolean that indicates whether this is a staging distribution. Defaults to false."', args=[d.arg(name='staging', type=d.T.boolean)]),
      withStaging(staging): { spec+: { initProvider+: { staging: staging } } },
      '#withTags':: d.fn(help='"Key-value map of resource tags."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { initProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"Key-value map of resource tags."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { initProvider+: { tags+: tags } } },
      '#withViewerCertificate':: d.fn(help='"The SSL configuration for this distribution (maximum one)."', args=[d.arg(name='viewerCertificate', type=d.T.array)]),
      withViewerCertificate(viewerCertificate): { spec+: { initProvider+: { viewerCertificate: if std.isArray(v=viewerCertificate) then viewerCertificate else [viewerCertificate] } } },
      '#withViewerCertificateMixin':: d.fn(help='"The SSL configuration for this distribution (maximum one)."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='viewerCertificate', type=d.T.array)]),
      withViewerCertificateMixin(viewerCertificate): { spec+: { initProvider+: { viewerCertificate+: if std.isArray(v=viewerCertificate) then viewerCertificate else [viewerCertificate] } } },
      '#withWaitForDeployment':: d.fn(help='"If enabled, the resource will wait for the distribution status to change from InProgress to Deployed. Setting this tofalse will skip the process. Default: true."', args=[d.arg(name='waitForDeployment', type=d.T.boolean)]),
      withWaitForDeployment(waitForDeployment): { spec+: { initProvider+: { waitForDeployment: waitForDeployment } } },
      '#withWebAclId':: d.fn(help='"Unique identifier that specifies the AWS WAF web ACL, if any, to associate with this distribution. To specify a web ACL created using the latest version of AWS WAF (WAFv2), use the ACL ARN, for example aws_wafv2_web_acl.example.arn. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example aws_waf_web_acl.example.id. The WAF Web ACL must exist in the WAF Global (CloudFront) region and the credentials configuring this argument must have waf:GetWebACL permissions assigned."', args=[d.arg(name='webAclId', type=d.T.string)]),
      withWebAclId(webAclId): { spec+: { initProvider+: { webAclId: webAclId } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to\\ncreate, observe, update, and delete this managed resource should be\\nconfigured."'),
    providerConfigRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerConfigRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerConfigRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#withDeletionPolicy':: d.fn(help='"DeletionPolicy specifies what will happen to the underlying external\\nwhen this managed resource is deleted - either \\"Delete\\" or \\"Orphan\\" the\\nexternal resource.\\nThis field is planned to be deprecated in favor of the ManagementPolicies\\nfield in a future release. Currently, both could be set independently and\\nnon-default values would be honored if the feature flag is enabled.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223"', args=[d.arg(name='deletionPolicy', type=d.T.string)]),
    withDeletionPolicy(deletionPolicy): { spec+: { deletionPolicy: deletionPolicy } },
    '#withManagementPolicies':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPolicies(managementPolicies): { spec+: { managementPolicies: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#withManagementPoliciesMixin':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPoliciesMixin(managementPolicies): { spec+: { managementPolicies+: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a\\nSecret to which any connection details for this managed resource should\\nbe written. Connection details frequently include the endpoint, username,\\nand password required to connect to the managed resource."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { writeConnectionSecretToRef+: { namespace: namespace } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
