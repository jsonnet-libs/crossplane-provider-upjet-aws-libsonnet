{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='insight', url='', help='"Insight is the Schema for the Insights API. Provides a Security Hub custom insight resource."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of Insight', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'securityhub.aws.upbound.io/v1beta1',
    kind: 'Insight',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"InsightSpec defines the desired state of Insight"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#filters':: d.obj(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."'),
      filters: {
        '#awsAccountId':: d.obj(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."'),
        awsAccountId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#companyName':: d.obj(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."'),
        companyName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#complianceStatus':: d.obj(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."'),
        complianceStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#confidence':: d.obj(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\""),
        confidence: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#createdAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."'),
        createdAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#criticality':: d.obj(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."'),
        criticality: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#description':: d.obj(help="\"A finding's description. See String Filter below for more details.\""),
        description: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsConfidence':: d.obj(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."'),
        findingProviderFieldsConfidence: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#findingProviderFieldsCriticality':: d.obj(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."'),
        findingProviderFieldsCriticality: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#findingProviderFieldsRelatedFindingsId':: d.obj(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."'),
        findingProviderFieldsRelatedFindingsId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsRelatedFindingsProductArn':: d.obj(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."'),
        findingProviderFieldsRelatedFindingsProductArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsSeverityLabel':: d.obj(help='"The finding provider value for the severity label. See String Filter below for more details."'),
        findingProviderFieldsSeverityLabel: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsSeverityOriginal':: d.obj(help="\"The finding provider's original value for the severity. See String Filter below for more details.\""),
        findingProviderFieldsSeverityOriginal: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsTypes':: d.obj(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."'),
        findingProviderFieldsTypes: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#firstObservedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."'),
        firstObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#generatorId':: d.obj(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."'),
        generatorId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#id':: d.obj(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."'),
        id: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#keyword':: d.obj(help='"A keyword for a finding. See Keyword Filter below for more details."'),
        keyword: {
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#lastObservedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."'),
        lastObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#malwareName':: d.obj(help='"The name of the malware that was observed. See String Filter below for more details."'),
        malwareName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwarePath':: d.obj(help='"The filesystem path of the malware that was observed. See String Filter below for more details."'),
        malwarePath: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwareState':: d.obj(help='"The state of the malware that was observed. See String Filter below for more details."'),
        malwareState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwareType':: d.obj(help='"The type of the malware that was observed. See String Filter below for more details."'),
        malwareType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkDestinationDomain':: d.obj(help='"The destination domain of network-related information about a finding. See String Filter below for more details."'),
        networkDestinationDomain: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkDestinationIpv4':: d.obj(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkDestinationIpv4: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkDestinationIpv6':: d.obj(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkDestinationIpv6: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkDestinationPort':: d.obj(help='"The destination port of network-related information about a finding. See Number Filter below for more details."'),
        networkDestinationPort: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#networkDirection':: d.obj(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."'),
        networkDirection: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkProtocol':: d.obj(help='"The protocol of network-related information about a finding. See String Filter below for more details."'),
        networkProtocol: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourceDomain':: d.obj(help='"The source domain of network-related information about a finding. See String Filter below for more details."'),
        networkSourceDomain: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourceIpv4':: d.obj(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkSourceIpv4: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkSourceIpv6':: d.obj(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkSourceIpv6: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkSourceMac':: d.obj(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."'),
        networkSourceMac: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourcePort':: d.obj(help='"The source port of network-related information about a finding. See Number Filter below for more details."'),
        networkSourcePort: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#noteText':: d.obj(help='"The text of a note. See String Filter below for more details."'),
        noteText: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#noteUpdatedAt':: d.obj(help='"The timestamp of when the note was updated. See Date Filter below for more details."'),
        noteUpdatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#noteUpdatedBy':: d.obj(help='"The principal that created a note. See String Filter below for more details."'),
        noteUpdatedBy: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processLaunchedAt':: d.obj(help='"The date/time that the process was launched. See Date Filter below for more details."'),
        processLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#processName':: d.obj(help='"The name of the process. See String Filter below for more details."'),
        processName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processParentPid':: d.obj(help='"The parent process ID. See Number Filter below for more details."'),
        processParentPid: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#processPath':: d.obj(help='"The path to the process executable. See String Filter below for more details."'),
        processPath: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processPid':: d.obj(help='"The process ID. See Number Filter below for more details."'),
        processPid: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#processTerminatedAt':: d.obj(help='"The date/time that the process was terminated. See Date Filter below for more details."'),
        processTerminatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#productArn':: d.obj(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\""),
        productArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#productFields':: d.obj(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\""),
        productFields: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#productName':: d.obj(help='"The name of the solution (product) that generates findings. See String Filter below for more details."'),
        productName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#recommendationText':: d.obj(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."'),
        recommendationText: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#recordState':: d.obj(help='"The updated record state for the finding. See String Filter below for more details."'),
        recordState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#relatedFindingsId':: d.obj(help='"The solution-generated identifier for a related finding. See String Filter below for more details."'),
        relatedFindingsId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#relatedFindingsProductArn':: d.obj(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."'),
        relatedFindingsProductArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceIamInstanceProfileArn':: d.obj(help='"The IAM profile ARN of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceIamInstanceProfileArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceImageId':: d.obj(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceImageId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceIpv4Addresses':: d.obj(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."'),
        resourceAwsEc2InstanceIpv4Addresses: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#resourceAwsEc2InstanceIpv6Addresses':: d.obj(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."'),
        resourceAwsEc2InstanceIpv6Addresses: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#resourceAwsEc2InstanceKeyName':: d.obj(help='"The key name associated with the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceKeyName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceLaunchedAt':: d.obj(help='"The date and time the instance was launched. See Date Filter below for more details."'),
        resourceAwsEc2InstanceLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceAwsEc2InstanceSubnetId':: d.obj(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."'),
        resourceAwsEc2InstanceSubnetId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceType':: d.obj(help='"The instance type of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceVpcId':: d.obj(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."'),
        resourceAwsEc2InstanceVpcId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsIamAccessKeyCreatedAt':: d.obj(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."'),
        resourceAwsIamAccessKeyCreatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceAwsIamAccessKeyStatus':: d.obj(help='"The status of the IAM access key related to a finding. See String Filter below for more details."'),
        resourceAwsIamAccessKeyStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsIamAccessKeyUserName':: d.obj(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."'),
        resourceAwsIamAccessKeyUserName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsS3BucketOwnerId':: d.obj(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."'),
        resourceAwsS3BucketOwnerId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsS3BucketOwnerName':: d.obj(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."'),
        resourceAwsS3BucketOwnerName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerImageId':: d.obj(help='"The identifier of the image related to a finding. See String Filter below for more details."'),
        resourceContainerImageId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerImageName':: d.obj(help='"The name of the image related to a finding. See String Filter below for more details."'),
        resourceContainerImageName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerLaunchedAt':: d.obj(help='"The date/time that the container was started. See Date Filter below for more details."'),
        resourceContainerLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceContainerName':: d.obj(help='"The name of the container related to a finding. See String Filter below for more details."'),
        resourceContainerName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceDetailsOther':: d.obj(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\""),
        resourceDetailsOther: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceId':: d.obj(help='"The canonical identifier for the given resource type. See String Filter below for more details."'),
        resourceId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourcePartition':: d.obj(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."'),
        resourcePartition: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceRegion':: d.obj(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."'),
        resourceRegion: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceTags':: d.obj(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."'),
        resourceTags: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceType':: d.obj(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."'),
        resourceType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#severityLabel':: d.obj(help="\"The label of a finding's severity. See String Filter below for more details.\""),
        severityLabel: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#sourceUrl':: d.obj(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\""),
        sourceUrl: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorCategory':: d.obj(help='"The category of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorCategory: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorLastObservedAt':: d.obj(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."'),
        threatIntelIndicatorLastObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#threatIntelIndicatorSource':: d.obj(help='"The source of the threat intelligence. See String Filter below for more details."'),
        threatIntelIndicatorSource: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorSourceUrl':: d.obj(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."'),
        threatIntelIndicatorSourceUrl: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorType':: d.obj(help='"The type of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorValue':: d.obj(help='"The value of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorValue: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#title':: d.obj(help="\"A finding's title. See String Filter below for more details.\""),
        title: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#type':: d.obj(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."'),
        type: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#updatedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."'),
        updatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#userDefinedValues':: d.obj(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."'),
        userDefinedValues: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#verificationState':: d.obj(help='"The veracity of a finding. See String Filter below for more details."'),
        verificationState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withAwsAccountId':: d.fn(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."', args=[d.arg(name='awsAccountId', type=d.T.array)]),
        withAwsAccountId(awsAccountId): { awsAccountId: if std.isArray(v=awsAccountId) then awsAccountId else [awsAccountId] },
        '#withAwsAccountIdMixin':: d.fn(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='awsAccountId', type=d.T.array)]),
        withAwsAccountIdMixin(awsAccountId): { awsAccountId+: if std.isArray(v=awsAccountId) then awsAccountId else [awsAccountId] },
        '#withCompanyName':: d.fn(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."', args=[d.arg(name='companyName', type=d.T.array)]),
        withCompanyName(companyName): { companyName: if std.isArray(v=companyName) then companyName else [companyName] },
        '#withCompanyNameMixin':: d.fn(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='companyName', type=d.T.array)]),
        withCompanyNameMixin(companyName): { companyName+: if std.isArray(v=companyName) then companyName else [companyName] },
        '#withComplianceStatus':: d.fn(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."', args=[d.arg(name='complianceStatus', type=d.T.array)]),
        withComplianceStatus(complianceStatus): { complianceStatus: if std.isArray(v=complianceStatus) then complianceStatus else [complianceStatus] },
        '#withComplianceStatusMixin':: d.fn(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='complianceStatus', type=d.T.array)]),
        withComplianceStatusMixin(complianceStatus): { complianceStatus+: if std.isArray(v=complianceStatus) then complianceStatus else [complianceStatus] },
        '#withConfidence':: d.fn(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\"", args=[d.arg(name='confidence', type=d.T.array)]),
        withConfidence(confidence): { confidence: if std.isArray(v=confidence) then confidence else [confidence] },
        '#withConfidenceMixin':: d.fn(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='confidence', type=d.T.array)]),
        withConfidenceMixin(confidence): { confidence+: if std.isArray(v=confidence) then confidence else [confidence] },
        '#withCreatedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='createdAt', type=d.T.array)]),
        withCreatedAt(createdAt): { createdAt: if std.isArray(v=createdAt) then createdAt else [createdAt] },
        '#withCreatedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='createdAt', type=d.T.array)]),
        withCreatedAtMixin(createdAt): { createdAt+: if std.isArray(v=createdAt) then createdAt else [createdAt] },
        '#withCriticality':: d.fn(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."', args=[d.arg(name='criticality', type=d.T.array)]),
        withCriticality(criticality): { criticality: if std.isArray(v=criticality) then criticality else [criticality] },
        '#withCriticalityMixin':: d.fn(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='criticality', type=d.T.array)]),
        withCriticalityMixin(criticality): { criticality+: if std.isArray(v=criticality) then criticality else [criticality] },
        '#withDescription':: d.fn(help="\"A finding's description. See String Filter below for more details.\"", args=[d.arg(name='description', type=d.T.array)]),
        withDescription(description): { description: if std.isArray(v=description) then description else [description] },
        '#withDescriptionMixin':: d.fn(help="\"A finding's description. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='description', type=d.T.array)]),
        withDescriptionMixin(description): { description+: if std.isArray(v=description) then description else [description] },
        '#withFindingProviderFieldsConfidence':: d.fn(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."', args=[d.arg(name='findingProviderFieldsConfidence', type=d.T.array)]),
        withFindingProviderFieldsConfidence(findingProviderFieldsConfidence): { findingProviderFieldsConfidence: if std.isArray(v=findingProviderFieldsConfidence) then findingProviderFieldsConfidence else [findingProviderFieldsConfidence] },
        '#withFindingProviderFieldsConfidenceMixin':: d.fn(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsConfidence', type=d.T.array)]),
        withFindingProviderFieldsConfidenceMixin(findingProviderFieldsConfidence): { findingProviderFieldsConfidence+: if std.isArray(v=findingProviderFieldsConfidence) then findingProviderFieldsConfidence else [findingProviderFieldsConfidence] },
        '#withFindingProviderFieldsCriticality':: d.fn(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."', args=[d.arg(name='findingProviderFieldsCriticality', type=d.T.array)]),
        withFindingProviderFieldsCriticality(findingProviderFieldsCriticality): { findingProviderFieldsCriticality: if std.isArray(v=findingProviderFieldsCriticality) then findingProviderFieldsCriticality else [findingProviderFieldsCriticality] },
        '#withFindingProviderFieldsCriticalityMixin':: d.fn(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsCriticality', type=d.T.array)]),
        withFindingProviderFieldsCriticalityMixin(findingProviderFieldsCriticality): { findingProviderFieldsCriticality+: if std.isArray(v=findingProviderFieldsCriticality) then findingProviderFieldsCriticality else [findingProviderFieldsCriticality] },
        '#withFindingProviderFieldsRelatedFindingsId':: d.fn(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsRelatedFindingsId', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsId(findingProviderFieldsRelatedFindingsId): { findingProviderFieldsRelatedFindingsId: if std.isArray(v=findingProviderFieldsRelatedFindingsId) then findingProviderFieldsRelatedFindingsId else [findingProviderFieldsRelatedFindingsId] },
        '#withFindingProviderFieldsRelatedFindingsIdMixin':: d.fn(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsRelatedFindingsId', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsIdMixin(findingProviderFieldsRelatedFindingsId): { findingProviderFieldsRelatedFindingsId+: if std.isArray(v=findingProviderFieldsRelatedFindingsId) then findingProviderFieldsRelatedFindingsId else [findingProviderFieldsRelatedFindingsId] },
        '#withFindingProviderFieldsRelatedFindingsProductArn':: d.fn(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsRelatedFindingsProductArn', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsProductArn(findingProviderFieldsRelatedFindingsProductArn): { findingProviderFieldsRelatedFindingsProductArn: if std.isArray(v=findingProviderFieldsRelatedFindingsProductArn) then findingProviderFieldsRelatedFindingsProductArn else [findingProviderFieldsRelatedFindingsProductArn] },
        '#withFindingProviderFieldsRelatedFindingsProductArnMixin':: d.fn(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsRelatedFindingsProductArn', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsProductArnMixin(findingProviderFieldsRelatedFindingsProductArn): { findingProviderFieldsRelatedFindingsProductArn+: if std.isArray(v=findingProviderFieldsRelatedFindingsProductArn) then findingProviderFieldsRelatedFindingsProductArn else [findingProviderFieldsRelatedFindingsProductArn] },
        '#withFindingProviderFieldsSeverityLabel':: d.fn(help='"The finding provider value for the severity label. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsSeverityLabel', type=d.T.array)]),
        withFindingProviderFieldsSeverityLabel(findingProviderFieldsSeverityLabel): { findingProviderFieldsSeverityLabel: if std.isArray(v=findingProviderFieldsSeverityLabel) then findingProviderFieldsSeverityLabel else [findingProviderFieldsSeverityLabel] },
        '#withFindingProviderFieldsSeverityLabelMixin':: d.fn(help='"The finding provider value for the severity label. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsSeverityLabel', type=d.T.array)]),
        withFindingProviderFieldsSeverityLabelMixin(findingProviderFieldsSeverityLabel): { findingProviderFieldsSeverityLabel+: if std.isArray(v=findingProviderFieldsSeverityLabel) then findingProviderFieldsSeverityLabel else [findingProviderFieldsSeverityLabel] },
        '#withFindingProviderFieldsSeverityOriginal':: d.fn(help="\"The finding provider's original value for the severity. See String Filter below for more details.\"", args=[d.arg(name='findingProviderFieldsSeverityOriginal', type=d.T.array)]),
        withFindingProviderFieldsSeverityOriginal(findingProviderFieldsSeverityOriginal): { findingProviderFieldsSeverityOriginal: if std.isArray(v=findingProviderFieldsSeverityOriginal) then findingProviderFieldsSeverityOriginal else [findingProviderFieldsSeverityOriginal] },
        '#withFindingProviderFieldsSeverityOriginalMixin':: d.fn(help="\"The finding provider's original value for the severity. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='findingProviderFieldsSeverityOriginal', type=d.T.array)]),
        withFindingProviderFieldsSeverityOriginalMixin(findingProviderFieldsSeverityOriginal): { findingProviderFieldsSeverityOriginal+: if std.isArray(v=findingProviderFieldsSeverityOriginal) then findingProviderFieldsSeverityOriginal else [findingProviderFieldsSeverityOriginal] },
        '#withFindingProviderFieldsTypes':: d.fn(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsTypes', type=d.T.array)]),
        withFindingProviderFieldsTypes(findingProviderFieldsTypes): { findingProviderFieldsTypes: if std.isArray(v=findingProviderFieldsTypes) then findingProviderFieldsTypes else [findingProviderFieldsTypes] },
        '#withFindingProviderFieldsTypesMixin':: d.fn(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsTypes', type=d.T.array)]),
        withFindingProviderFieldsTypesMixin(findingProviderFieldsTypes): { findingProviderFieldsTypes+: if std.isArray(v=findingProviderFieldsTypes) then findingProviderFieldsTypes else [findingProviderFieldsTypes] },
        '#withFirstObservedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='firstObservedAt', type=d.T.array)]),
        withFirstObservedAt(firstObservedAt): { firstObservedAt: if std.isArray(v=firstObservedAt) then firstObservedAt else [firstObservedAt] },
        '#withFirstObservedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='firstObservedAt', type=d.T.array)]),
        withFirstObservedAtMixin(firstObservedAt): { firstObservedAt+: if std.isArray(v=firstObservedAt) then firstObservedAt else [firstObservedAt] },
        '#withGeneratorId':: d.fn(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."', args=[d.arg(name='generatorId', type=d.T.array)]),
        withGeneratorId(generatorId): { generatorId: if std.isArray(v=generatorId) then generatorId else [generatorId] },
        '#withGeneratorIdMixin':: d.fn(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='generatorId', type=d.T.array)]),
        withGeneratorIdMixin(generatorId): { generatorId+: if std.isArray(v=generatorId) then generatorId else [generatorId] },
        '#withId':: d.fn(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."', args=[d.arg(name='id', type=d.T.array)]),
        withId(id): { id: if std.isArray(v=id) then id else [id] },
        '#withIdMixin':: d.fn(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='id', type=d.T.array)]),
        withIdMixin(id): { id+: if std.isArray(v=id) then id else [id] },
        '#withKeyword':: d.fn(help='"A keyword for a finding. See Keyword Filter below for more details."', args=[d.arg(name='keyword', type=d.T.array)]),
        withKeyword(keyword): { keyword: if std.isArray(v=keyword) then keyword else [keyword] },
        '#withKeywordMixin':: d.fn(help='"A keyword for a finding. See Keyword Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='keyword', type=d.T.array)]),
        withKeywordMixin(keyword): { keyword+: if std.isArray(v=keyword) then keyword else [keyword] },
        '#withLastObservedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='lastObservedAt', type=d.T.array)]),
        withLastObservedAt(lastObservedAt): { lastObservedAt: if std.isArray(v=lastObservedAt) then lastObservedAt else [lastObservedAt] },
        '#withLastObservedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lastObservedAt', type=d.T.array)]),
        withLastObservedAtMixin(lastObservedAt): { lastObservedAt+: if std.isArray(v=lastObservedAt) then lastObservedAt else [lastObservedAt] },
        '#withMalwareName':: d.fn(help='"The name of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareName', type=d.T.array)]),
        withMalwareName(malwareName): { malwareName: if std.isArray(v=malwareName) then malwareName else [malwareName] },
        '#withMalwareNameMixin':: d.fn(help='"The name of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareName', type=d.T.array)]),
        withMalwareNameMixin(malwareName): { malwareName+: if std.isArray(v=malwareName) then malwareName else [malwareName] },
        '#withMalwarePath':: d.fn(help='"The filesystem path of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwarePath', type=d.T.array)]),
        withMalwarePath(malwarePath): { malwarePath: if std.isArray(v=malwarePath) then malwarePath else [malwarePath] },
        '#withMalwarePathMixin':: d.fn(help='"The filesystem path of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwarePath', type=d.T.array)]),
        withMalwarePathMixin(malwarePath): { malwarePath+: if std.isArray(v=malwarePath) then malwarePath else [malwarePath] },
        '#withMalwareState':: d.fn(help='"The state of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareState', type=d.T.array)]),
        withMalwareState(malwareState): { malwareState: if std.isArray(v=malwareState) then malwareState else [malwareState] },
        '#withMalwareStateMixin':: d.fn(help='"The state of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareState', type=d.T.array)]),
        withMalwareStateMixin(malwareState): { malwareState+: if std.isArray(v=malwareState) then malwareState else [malwareState] },
        '#withMalwareType':: d.fn(help='"The type of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareType', type=d.T.array)]),
        withMalwareType(malwareType): { malwareType: if std.isArray(v=malwareType) then malwareType else [malwareType] },
        '#withMalwareTypeMixin':: d.fn(help='"The type of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareType', type=d.T.array)]),
        withMalwareTypeMixin(malwareType): { malwareType+: if std.isArray(v=malwareType) then malwareType else [malwareType] },
        '#withNetworkDestinationDomain':: d.fn(help='"The destination domain of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkDestinationDomain', type=d.T.array)]),
        withNetworkDestinationDomain(networkDestinationDomain): { networkDestinationDomain: if std.isArray(v=networkDestinationDomain) then networkDestinationDomain else [networkDestinationDomain] },
        '#withNetworkDestinationDomainMixin':: d.fn(help='"The destination domain of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationDomain', type=d.T.array)]),
        withNetworkDestinationDomainMixin(networkDestinationDomain): { networkDestinationDomain+: if std.isArray(v=networkDestinationDomain) then networkDestinationDomain else [networkDestinationDomain] },
        '#withNetworkDestinationIpv4':: d.fn(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkDestinationIpv4', type=d.T.array)]),
        withNetworkDestinationIpv4(networkDestinationIpv4): { networkDestinationIpv4: if std.isArray(v=networkDestinationIpv4) then networkDestinationIpv4 else [networkDestinationIpv4] },
        '#withNetworkDestinationIpv4Mixin':: d.fn(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationIpv4', type=d.T.array)]),
        withNetworkDestinationIpv4Mixin(networkDestinationIpv4): { networkDestinationIpv4+: if std.isArray(v=networkDestinationIpv4) then networkDestinationIpv4 else [networkDestinationIpv4] },
        '#withNetworkDestinationIpv6':: d.fn(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkDestinationIpv6', type=d.T.array)]),
        withNetworkDestinationIpv6(networkDestinationIpv6): { networkDestinationIpv6: if std.isArray(v=networkDestinationIpv6) then networkDestinationIpv6 else [networkDestinationIpv6] },
        '#withNetworkDestinationIpv6Mixin':: d.fn(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationIpv6', type=d.T.array)]),
        withNetworkDestinationIpv6Mixin(networkDestinationIpv6): { networkDestinationIpv6+: if std.isArray(v=networkDestinationIpv6) then networkDestinationIpv6 else [networkDestinationIpv6] },
        '#withNetworkDestinationPort':: d.fn(help='"The destination port of network-related information about a finding. See Number Filter below for more details."', args=[d.arg(name='networkDestinationPort', type=d.T.array)]),
        withNetworkDestinationPort(networkDestinationPort): { networkDestinationPort: if std.isArray(v=networkDestinationPort) then networkDestinationPort else [networkDestinationPort] },
        '#withNetworkDestinationPortMixin':: d.fn(help='"The destination port of network-related information about a finding. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationPort', type=d.T.array)]),
        withNetworkDestinationPortMixin(networkDestinationPort): { networkDestinationPort+: if std.isArray(v=networkDestinationPort) then networkDestinationPort else [networkDestinationPort] },
        '#withNetworkDirection':: d.fn(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."', args=[d.arg(name='networkDirection', type=d.T.array)]),
        withNetworkDirection(networkDirection): { networkDirection: if std.isArray(v=networkDirection) then networkDirection else [networkDirection] },
        '#withNetworkDirectionMixin':: d.fn(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDirection', type=d.T.array)]),
        withNetworkDirectionMixin(networkDirection): { networkDirection+: if std.isArray(v=networkDirection) then networkDirection else [networkDirection] },
        '#withNetworkProtocol':: d.fn(help='"The protocol of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkProtocol', type=d.T.array)]),
        withNetworkProtocol(networkProtocol): { networkProtocol: if std.isArray(v=networkProtocol) then networkProtocol else [networkProtocol] },
        '#withNetworkProtocolMixin':: d.fn(help='"The protocol of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkProtocol', type=d.T.array)]),
        withNetworkProtocolMixin(networkProtocol): { networkProtocol+: if std.isArray(v=networkProtocol) then networkProtocol else [networkProtocol] },
        '#withNetworkSourceDomain':: d.fn(help='"The source domain of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkSourceDomain', type=d.T.array)]),
        withNetworkSourceDomain(networkSourceDomain): { networkSourceDomain: if std.isArray(v=networkSourceDomain) then networkSourceDomain else [networkSourceDomain] },
        '#withNetworkSourceDomainMixin':: d.fn(help='"The source domain of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceDomain', type=d.T.array)]),
        withNetworkSourceDomainMixin(networkSourceDomain): { networkSourceDomain+: if std.isArray(v=networkSourceDomain) then networkSourceDomain else [networkSourceDomain] },
        '#withNetworkSourceIpv4':: d.fn(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkSourceIpv4', type=d.T.array)]),
        withNetworkSourceIpv4(networkSourceIpv4): { networkSourceIpv4: if std.isArray(v=networkSourceIpv4) then networkSourceIpv4 else [networkSourceIpv4] },
        '#withNetworkSourceIpv4Mixin':: d.fn(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceIpv4', type=d.T.array)]),
        withNetworkSourceIpv4Mixin(networkSourceIpv4): { networkSourceIpv4+: if std.isArray(v=networkSourceIpv4) then networkSourceIpv4 else [networkSourceIpv4] },
        '#withNetworkSourceIpv6':: d.fn(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkSourceIpv6', type=d.T.array)]),
        withNetworkSourceIpv6(networkSourceIpv6): { networkSourceIpv6: if std.isArray(v=networkSourceIpv6) then networkSourceIpv6 else [networkSourceIpv6] },
        '#withNetworkSourceIpv6Mixin':: d.fn(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceIpv6', type=d.T.array)]),
        withNetworkSourceIpv6Mixin(networkSourceIpv6): { networkSourceIpv6+: if std.isArray(v=networkSourceIpv6) then networkSourceIpv6 else [networkSourceIpv6] },
        '#withNetworkSourceMac':: d.fn(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkSourceMac', type=d.T.array)]),
        withNetworkSourceMac(networkSourceMac): { networkSourceMac: if std.isArray(v=networkSourceMac) then networkSourceMac else [networkSourceMac] },
        '#withNetworkSourceMacMixin':: d.fn(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceMac', type=d.T.array)]),
        withNetworkSourceMacMixin(networkSourceMac): { networkSourceMac+: if std.isArray(v=networkSourceMac) then networkSourceMac else [networkSourceMac] },
        '#withNetworkSourcePort':: d.fn(help='"The source port of network-related information about a finding. See Number Filter below for more details."', args=[d.arg(name='networkSourcePort', type=d.T.array)]),
        withNetworkSourcePort(networkSourcePort): { networkSourcePort: if std.isArray(v=networkSourcePort) then networkSourcePort else [networkSourcePort] },
        '#withNetworkSourcePortMixin':: d.fn(help='"The source port of network-related information about a finding. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourcePort', type=d.T.array)]),
        withNetworkSourcePortMixin(networkSourcePort): { networkSourcePort+: if std.isArray(v=networkSourcePort) then networkSourcePort else [networkSourcePort] },
        '#withNoteText':: d.fn(help='"The text of a note. See String Filter below for more details."', args=[d.arg(name='noteText', type=d.T.array)]),
        withNoteText(noteText): { noteText: if std.isArray(v=noteText) then noteText else [noteText] },
        '#withNoteTextMixin':: d.fn(help='"The text of a note. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteText', type=d.T.array)]),
        withNoteTextMixin(noteText): { noteText+: if std.isArray(v=noteText) then noteText else [noteText] },
        '#withNoteUpdatedAt':: d.fn(help='"The timestamp of when the note was updated. See Date Filter below for more details."', args=[d.arg(name='noteUpdatedAt', type=d.T.array)]),
        withNoteUpdatedAt(noteUpdatedAt): { noteUpdatedAt: if std.isArray(v=noteUpdatedAt) then noteUpdatedAt else [noteUpdatedAt] },
        '#withNoteUpdatedAtMixin':: d.fn(help='"The timestamp of when the note was updated. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteUpdatedAt', type=d.T.array)]),
        withNoteUpdatedAtMixin(noteUpdatedAt): { noteUpdatedAt+: if std.isArray(v=noteUpdatedAt) then noteUpdatedAt else [noteUpdatedAt] },
        '#withNoteUpdatedBy':: d.fn(help='"The principal that created a note. See String Filter below for more details."', args=[d.arg(name='noteUpdatedBy', type=d.T.array)]),
        withNoteUpdatedBy(noteUpdatedBy): { noteUpdatedBy: if std.isArray(v=noteUpdatedBy) then noteUpdatedBy else [noteUpdatedBy] },
        '#withNoteUpdatedByMixin':: d.fn(help='"The principal that created a note. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteUpdatedBy', type=d.T.array)]),
        withNoteUpdatedByMixin(noteUpdatedBy): { noteUpdatedBy+: if std.isArray(v=noteUpdatedBy) then noteUpdatedBy else [noteUpdatedBy] },
        '#withProcessLaunchedAt':: d.fn(help='"The date/time that the process was launched. See Date Filter below for more details."', args=[d.arg(name='processLaunchedAt', type=d.T.array)]),
        withProcessLaunchedAt(processLaunchedAt): { processLaunchedAt: if std.isArray(v=processLaunchedAt) then processLaunchedAt else [processLaunchedAt] },
        '#withProcessLaunchedAtMixin':: d.fn(help='"The date/time that the process was launched. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processLaunchedAt', type=d.T.array)]),
        withProcessLaunchedAtMixin(processLaunchedAt): { processLaunchedAt+: if std.isArray(v=processLaunchedAt) then processLaunchedAt else [processLaunchedAt] },
        '#withProcessName':: d.fn(help='"The name of the process. See String Filter below for more details."', args=[d.arg(name='processName', type=d.T.array)]),
        withProcessName(processName): { processName: if std.isArray(v=processName) then processName else [processName] },
        '#withProcessNameMixin':: d.fn(help='"The name of the process. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processName', type=d.T.array)]),
        withProcessNameMixin(processName): { processName+: if std.isArray(v=processName) then processName else [processName] },
        '#withProcessParentPid':: d.fn(help='"The parent process ID. See Number Filter below for more details."', args=[d.arg(name='processParentPid', type=d.T.array)]),
        withProcessParentPid(processParentPid): { processParentPid: if std.isArray(v=processParentPid) then processParentPid else [processParentPid] },
        '#withProcessParentPidMixin':: d.fn(help='"The parent process ID. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processParentPid', type=d.T.array)]),
        withProcessParentPidMixin(processParentPid): { processParentPid+: if std.isArray(v=processParentPid) then processParentPid else [processParentPid] },
        '#withProcessPath':: d.fn(help='"The path to the process executable. See String Filter below for more details."', args=[d.arg(name='processPath', type=d.T.array)]),
        withProcessPath(processPath): { processPath: if std.isArray(v=processPath) then processPath else [processPath] },
        '#withProcessPathMixin':: d.fn(help='"The path to the process executable. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processPath', type=d.T.array)]),
        withProcessPathMixin(processPath): { processPath+: if std.isArray(v=processPath) then processPath else [processPath] },
        '#withProcessPid':: d.fn(help='"The process ID. See Number Filter below for more details."', args=[d.arg(name='processPid', type=d.T.array)]),
        withProcessPid(processPid): { processPid: if std.isArray(v=processPid) then processPid else [processPid] },
        '#withProcessPidMixin':: d.fn(help='"The process ID. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processPid', type=d.T.array)]),
        withProcessPidMixin(processPid): { processPid+: if std.isArray(v=processPid) then processPid else [processPid] },
        '#withProcessTerminatedAt':: d.fn(help='"The date/time that the process was terminated. See Date Filter below for more details."', args=[d.arg(name='processTerminatedAt', type=d.T.array)]),
        withProcessTerminatedAt(processTerminatedAt): { processTerminatedAt: if std.isArray(v=processTerminatedAt) then processTerminatedAt else [processTerminatedAt] },
        '#withProcessTerminatedAtMixin':: d.fn(help='"The date/time that the process was terminated. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processTerminatedAt', type=d.T.array)]),
        withProcessTerminatedAtMixin(processTerminatedAt): { processTerminatedAt+: if std.isArray(v=processTerminatedAt) then processTerminatedAt else [processTerminatedAt] },
        '#withProductArn':: d.fn(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\"", args=[d.arg(name='productArn', type=d.T.array)]),
        withProductArn(productArn): { productArn: if std.isArray(v=productArn) then productArn else [productArn] },
        '#withProductArnMixin':: d.fn(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='productArn', type=d.T.array)]),
        withProductArnMixin(productArn): { productArn+: if std.isArray(v=productArn) then productArn else [productArn] },
        '#withProductFields':: d.fn(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\"", args=[d.arg(name='productFields', type=d.T.array)]),
        withProductFields(productFields): { productFields: if std.isArray(v=productFields) then productFields else [productFields] },
        '#withProductFieldsMixin':: d.fn(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='productFields', type=d.T.array)]),
        withProductFieldsMixin(productFields): { productFields+: if std.isArray(v=productFields) then productFields else [productFields] },
        '#withProductName':: d.fn(help='"The name of the solution (product) that generates findings. See String Filter below for more details."', args=[d.arg(name='productName', type=d.T.array)]),
        withProductName(productName): { productName: if std.isArray(v=productName) then productName else [productName] },
        '#withProductNameMixin':: d.fn(help='"The name of the solution (product) that generates findings. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='productName', type=d.T.array)]),
        withProductNameMixin(productName): { productName+: if std.isArray(v=productName) then productName else [productName] },
        '#withRecommendationText':: d.fn(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."', args=[d.arg(name='recommendationText', type=d.T.array)]),
        withRecommendationText(recommendationText): { recommendationText: if std.isArray(v=recommendationText) then recommendationText else [recommendationText] },
        '#withRecommendationTextMixin':: d.fn(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='recommendationText', type=d.T.array)]),
        withRecommendationTextMixin(recommendationText): { recommendationText+: if std.isArray(v=recommendationText) then recommendationText else [recommendationText] },
        '#withRecordState':: d.fn(help='"The updated record state for the finding. See String Filter below for more details."', args=[d.arg(name='recordState', type=d.T.array)]),
        withRecordState(recordState): { recordState: if std.isArray(v=recordState) then recordState else [recordState] },
        '#withRecordStateMixin':: d.fn(help='"The updated record state for the finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='recordState', type=d.T.array)]),
        withRecordStateMixin(recordState): { recordState+: if std.isArray(v=recordState) then recordState else [recordState] },
        '#withRelatedFindingsId':: d.fn(help='"The solution-generated identifier for a related finding. See String Filter below for more details."', args=[d.arg(name='relatedFindingsId', type=d.T.array)]),
        withRelatedFindingsId(relatedFindingsId): { relatedFindingsId: if std.isArray(v=relatedFindingsId) then relatedFindingsId else [relatedFindingsId] },
        '#withRelatedFindingsIdMixin':: d.fn(help='"The solution-generated identifier for a related finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='relatedFindingsId', type=d.T.array)]),
        withRelatedFindingsIdMixin(relatedFindingsId): { relatedFindingsId+: if std.isArray(v=relatedFindingsId) then relatedFindingsId else [relatedFindingsId] },
        '#withRelatedFindingsProductArn':: d.fn(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."', args=[d.arg(name='relatedFindingsProductArn', type=d.T.array)]),
        withRelatedFindingsProductArn(relatedFindingsProductArn): { relatedFindingsProductArn: if std.isArray(v=relatedFindingsProductArn) then relatedFindingsProductArn else [relatedFindingsProductArn] },
        '#withRelatedFindingsProductArnMixin':: d.fn(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='relatedFindingsProductArn', type=d.T.array)]),
        withRelatedFindingsProductArnMixin(relatedFindingsProductArn): { relatedFindingsProductArn+: if std.isArray(v=relatedFindingsProductArn) then relatedFindingsProductArn else [relatedFindingsProductArn] },
        '#withResourceAwsEc2InstanceIamInstanceProfileArn':: d.fn(help='"The IAM profile ARN of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIamInstanceProfileArn', type=d.T.array)]),
        withResourceAwsEc2InstanceIamInstanceProfileArn(resourceAwsEc2InstanceIamInstanceProfileArn): { resourceAwsEc2InstanceIamInstanceProfileArn: if std.isArray(v=resourceAwsEc2InstanceIamInstanceProfileArn) then resourceAwsEc2InstanceIamInstanceProfileArn else [resourceAwsEc2InstanceIamInstanceProfileArn] },
        '#withResourceAwsEc2InstanceIamInstanceProfileArnMixin':: d.fn(help='"The IAM profile ARN of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIamInstanceProfileArn', type=d.T.array)]),
        withResourceAwsEc2InstanceIamInstanceProfileArnMixin(resourceAwsEc2InstanceIamInstanceProfileArn): { resourceAwsEc2InstanceIamInstanceProfileArn+: if std.isArray(v=resourceAwsEc2InstanceIamInstanceProfileArn) then resourceAwsEc2InstanceIamInstanceProfileArn else [resourceAwsEc2InstanceIamInstanceProfileArn] },
        '#withResourceAwsEc2InstanceImageId':: d.fn(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceImageId', type=d.T.array)]),
        withResourceAwsEc2InstanceImageId(resourceAwsEc2InstanceImageId): { resourceAwsEc2InstanceImageId: if std.isArray(v=resourceAwsEc2InstanceImageId) then resourceAwsEc2InstanceImageId else [resourceAwsEc2InstanceImageId] },
        '#withResourceAwsEc2InstanceImageIdMixin':: d.fn(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceImageId', type=d.T.array)]),
        withResourceAwsEc2InstanceImageIdMixin(resourceAwsEc2InstanceImageId): { resourceAwsEc2InstanceImageId+: if std.isArray(v=resourceAwsEc2InstanceImageId) then resourceAwsEc2InstanceImageId else [resourceAwsEc2InstanceImageId] },
        '#withResourceAwsEc2InstanceIpv4Addresses':: d.fn(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIpv4Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv4Addresses(resourceAwsEc2InstanceIpv4Addresses): { resourceAwsEc2InstanceIpv4Addresses: if std.isArray(v=resourceAwsEc2InstanceIpv4Addresses) then resourceAwsEc2InstanceIpv4Addresses else [resourceAwsEc2InstanceIpv4Addresses] },
        '#withResourceAwsEc2InstanceIpv4AddressesMixin':: d.fn(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIpv4Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv4AddressesMixin(resourceAwsEc2InstanceIpv4Addresses): { resourceAwsEc2InstanceIpv4Addresses+: if std.isArray(v=resourceAwsEc2InstanceIpv4Addresses) then resourceAwsEc2InstanceIpv4Addresses else [resourceAwsEc2InstanceIpv4Addresses] },
        '#withResourceAwsEc2InstanceIpv6Addresses':: d.fn(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIpv6Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv6Addresses(resourceAwsEc2InstanceIpv6Addresses): { resourceAwsEc2InstanceIpv6Addresses: if std.isArray(v=resourceAwsEc2InstanceIpv6Addresses) then resourceAwsEc2InstanceIpv6Addresses else [resourceAwsEc2InstanceIpv6Addresses] },
        '#withResourceAwsEc2InstanceIpv6AddressesMixin':: d.fn(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIpv6Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv6AddressesMixin(resourceAwsEc2InstanceIpv6Addresses): { resourceAwsEc2InstanceIpv6Addresses+: if std.isArray(v=resourceAwsEc2InstanceIpv6Addresses) then resourceAwsEc2InstanceIpv6Addresses else [resourceAwsEc2InstanceIpv6Addresses] },
        '#withResourceAwsEc2InstanceKeyName':: d.fn(help='"The key name associated with the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceKeyName', type=d.T.array)]),
        withResourceAwsEc2InstanceKeyName(resourceAwsEc2InstanceKeyName): { resourceAwsEc2InstanceKeyName: if std.isArray(v=resourceAwsEc2InstanceKeyName) then resourceAwsEc2InstanceKeyName else [resourceAwsEc2InstanceKeyName] },
        '#withResourceAwsEc2InstanceKeyNameMixin':: d.fn(help='"The key name associated with the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceKeyName', type=d.T.array)]),
        withResourceAwsEc2InstanceKeyNameMixin(resourceAwsEc2InstanceKeyName): { resourceAwsEc2InstanceKeyName+: if std.isArray(v=resourceAwsEc2InstanceKeyName) then resourceAwsEc2InstanceKeyName else [resourceAwsEc2InstanceKeyName] },
        '#withResourceAwsEc2InstanceLaunchedAt':: d.fn(help='"The date and time the instance was launched. See Date Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceLaunchedAt', type=d.T.array)]),
        withResourceAwsEc2InstanceLaunchedAt(resourceAwsEc2InstanceLaunchedAt): { resourceAwsEc2InstanceLaunchedAt: if std.isArray(v=resourceAwsEc2InstanceLaunchedAt) then resourceAwsEc2InstanceLaunchedAt else [resourceAwsEc2InstanceLaunchedAt] },
        '#withResourceAwsEc2InstanceLaunchedAtMixin':: d.fn(help='"The date and time the instance was launched. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceLaunchedAt', type=d.T.array)]),
        withResourceAwsEc2InstanceLaunchedAtMixin(resourceAwsEc2InstanceLaunchedAt): { resourceAwsEc2InstanceLaunchedAt+: if std.isArray(v=resourceAwsEc2InstanceLaunchedAt) then resourceAwsEc2InstanceLaunchedAt else [resourceAwsEc2InstanceLaunchedAt] },
        '#withResourceAwsEc2InstanceSubnetId':: d.fn(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceSubnetId', type=d.T.array)]),
        withResourceAwsEc2InstanceSubnetId(resourceAwsEc2InstanceSubnetId): { resourceAwsEc2InstanceSubnetId: if std.isArray(v=resourceAwsEc2InstanceSubnetId) then resourceAwsEc2InstanceSubnetId else [resourceAwsEc2InstanceSubnetId] },
        '#withResourceAwsEc2InstanceSubnetIdMixin':: d.fn(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceSubnetId', type=d.T.array)]),
        withResourceAwsEc2InstanceSubnetIdMixin(resourceAwsEc2InstanceSubnetId): { resourceAwsEc2InstanceSubnetId+: if std.isArray(v=resourceAwsEc2InstanceSubnetId) then resourceAwsEc2InstanceSubnetId else [resourceAwsEc2InstanceSubnetId] },
        '#withResourceAwsEc2InstanceType':: d.fn(help='"The instance type of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceType', type=d.T.array)]),
        withResourceAwsEc2InstanceType(resourceAwsEc2InstanceType): { resourceAwsEc2InstanceType: if std.isArray(v=resourceAwsEc2InstanceType) then resourceAwsEc2InstanceType else [resourceAwsEc2InstanceType] },
        '#withResourceAwsEc2InstanceTypeMixin':: d.fn(help='"The instance type of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceType', type=d.T.array)]),
        withResourceAwsEc2InstanceTypeMixin(resourceAwsEc2InstanceType): { resourceAwsEc2InstanceType+: if std.isArray(v=resourceAwsEc2InstanceType) then resourceAwsEc2InstanceType else [resourceAwsEc2InstanceType] },
        '#withResourceAwsEc2InstanceVpcId':: d.fn(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceVpcId', type=d.T.array)]),
        withResourceAwsEc2InstanceVpcId(resourceAwsEc2InstanceVpcId): { resourceAwsEc2InstanceVpcId: if std.isArray(v=resourceAwsEc2InstanceVpcId) then resourceAwsEc2InstanceVpcId else [resourceAwsEc2InstanceVpcId] },
        '#withResourceAwsEc2InstanceVpcIdMixin':: d.fn(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceVpcId', type=d.T.array)]),
        withResourceAwsEc2InstanceVpcIdMixin(resourceAwsEc2InstanceVpcId): { resourceAwsEc2InstanceVpcId+: if std.isArray(v=resourceAwsEc2InstanceVpcId) then resourceAwsEc2InstanceVpcId else [resourceAwsEc2InstanceVpcId] },
        '#withResourceAwsIamAccessKeyCreatedAt':: d.fn(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyCreatedAt', type=d.T.array)]),
        withResourceAwsIamAccessKeyCreatedAt(resourceAwsIamAccessKeyCreatedAt): { resourceAwsIamAccessKeyCreatedAt: if std.isArray(v=resourceAwsIamAccessKeyCreatedAt) then resourceAwsIamAccessKeyCreatedAt else [resourceAwsIamAccessKeyCreatedAt] },
        '#withResourceAwsIamAccessKeyCreatedAtMixin':: d.fn(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyCreatedAt', type=d.T.array)]),
        withResourceAwsIamAccessKeyCreatedAtMixin(resourceAwsIamAccessKeyCreatedAt): { resourceAwsIamAccessKeyCreatedAt+: if std.isArray(v=resourceAwsIamAccessKeyCreatedAt) then resourceAwsIamAccessKeyCreatedAt else [resourceAwsIamAccessKeyCreatedAt] },
        '#withResourceAwsIamAccessKeyStatus':: d.fn(help='"The status of the IAM access key related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyStatus', type=d.T.array)]),
        withResourceAwsIamAccessKeyStatus(resourceAwsIamAccessKeyStatus): { resourceAwsIamAccessKeyStatus: if std.isArray(v=resourceAwsIamAccessKeyStatus) then resourceAwsIamAccessKeyStatus else [resourceAwsIamAccessKeyStatus] },
        '#withResourceAwsIamAccessKeyStatusMixin':: d.fn(help='"The status of the IAM access key related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyStatus', type=d.T.array)]),
        withResourceAwsIamAccessKeyStatusMixin(resourceAwsIamAccessKeyStatus): { resourceAwsIamAccessKeyStatus+: if std.isArray(v=resourceAwsIamAccessKeyStatus) then resourceAwsIamAccessKeyStatus else [resourceAwsIamAccessKeyStatus] },
        '#withResourceAwsIamAccessKeyUserName':: d.fn(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyUserName', type=d.T.array)]),
        withResourceAwsIamAccessKeyUserName(resourceAwsIamAccessKeyUserName): { resourceAwsIamAccessKeyUserName: if std.isArray(v=resourceAwsIamAccessKeyUserName) then resourceAwsIamAccessKeyUserName else [resourceAwsIamAccessKeyUserName] },
        '#withResourceAwsIamAccessKeyUserNameMixin':: d.fn(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyUserName', type=d.T.array)]),
        withResourceAwsIamAccessKeyUserNameMixin(resourceAwsIamAccessKeyUserName): { resourceAwsIamAccessKeyUserName+: if std.isArray(v=resourceAwsIamAccessKeyUserName) then resourceAwsIamAccessKeyUserName else [resourceAwsIamAccessKeyUserName] },
        '#withResourceAwsS3BucketOwnerId':: d.fn(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."', args=[d.arg(name='resourceAwsS3BucketOwnerId', type=d.T.array)]),
        withResourceAwsS3BucketOwnerId(resourceAwsS3BucketOwnerId): { resourceAwsS3BucketOwnerId: if std.isArray(v=resourceAwsS3BucketOwnerId) then resourceAwsS3BucketOwnerId else [resourceAwsS3BucketOwnerId] },
        '#withResourceAwsS3BucketOwnerIdMixin':: d.fn(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsS3BucketOwnerId', type=d.T.array)]),
        withResourceAwsS3BucketOwnerIdMixin(resourceAwsS3BucketOwnerId): { resourceAwsS3BucketOwnerId+: if std.isArray(v=resourceAwsS3BucketOwnerId) then resourceAwsS3BucketOwnerId else [resourceAwsS3BucketOwnerId] },
        '#withResourceAwsS3BucketOwnerName':: d.fn(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."', args=[d.arg(name='resourceAwsS3BucketOwnerName', type=d.T.array)]),
        withResourceAwsS3BucketOwnerName(resourceAwsS3BucketOwnerName): { resourceAwsS3BucketOwnerName: if std.isArray(v=resourceAwsS3BucketOwnerName) then resourceAwsS3BucketOwnerName else [resourceAwsS3BucketOwnerName] },
        '#withResourceAwsS3BucketOwnerNameMixin':: d.fn(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsS3BucketOwnerName', type=d.T.array)]),
        withResourceAwsS3BucketOwnerNameMixin(resourceAwsS3BucketOwnerName): { resourceAwsS3BucketOwnerName+: if std.isArray(v=resourceAwsS3BucketOwnerName) then resourceAwsS3BucketOwnerName else [resourceAwsS3BucketOwnerName] },
        '#withResourceContainerImageId':: d.fn(help='"The identifier of the image related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerImageId', type=d.T.array)]),
        withResourceContainerImageId(resourceContainerImageId): { resourceContainerImageId: if std.isArray(v=resourceContainerImageId) then resourceContainerImageId else [resourceContainerImageId] },
        '#withResourceContainerImageIdMixin':: d.fn(help='"The identifier of the image related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerImageId', type=d.T.array)]),
        withResourceContainerImageIdMixin(resourceContainerImageId): { resourceContainerImageId+: if std.isArray(v=resourceContainerImageId) then resourceContainerImageId else [resourceContainerImageId] },
        '#withResourceContainerImageName':: d.fn(help='"The name of the image related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerImageName', type=d.T.array)]),
        withResourceContainerImageName(resourceContainerImageName): { resourceContainerImageName: if std.isArray(v=resourceContainerImageName) then resourceContainerImageName else [resourceContainerImageName] },
        '#withResourceContainerImageNameMixin':: d.fn(help='"The name of the image related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerImageName', type=d.T.array)]),
        withResourceContainerImageNameMixin(resourceContainerImageName): { resourceContainerImageName+: if std.isArray(v=resourceContainerImageName) then resourceContainerImageName else [resourceContainerImageName] },
        '#withResourceContainerLaunchedAt':: d.fn(help='"The date/time that the container was started. See Date Filter below for more details."', args=[d.arg(name='resourceContainerLaunchedAt', type=d.T.array)]),
        withResourceContainerLaunchedAt(resourceContainerLaunchedAt): { resourceContainerLaunchedAt: if std.isArray(v=resourceContainerLaunchedAt) then resourceContainerLaunchedAt else [resourceContainerLaunchedAt] },
        '#withResourceContainerLaunchedAtMixin':: d.fn(help='"The date/time that the container was started. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerLaunchedAt', type=d.T.array)]),
        withResourceContainerLaunchedAtMixin(resourceContainerLaunchedAt): { resourceContainerLaunchedAt+: if std.isArray(v=resourceContainerLaunchedAt) then resourceContainerLaunchedAt else [resourceContainerLaunchedAt] },
        '#withResourceContainerName':: d.fn(help='"The name of the container related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerName', type=d.T.array)]),
        withResourceContainerName(resourceContainerName): { resourceContainerName: if std.isArray(v=resourceContainerName) then resourceContainerName else [resourceContainerName] },
        '#withResourceContainerNameMixin':: d.fn(help='"The name of the container related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerName', type=d.T.array)]),
        withResourceContainerNameMixin(resourceContainerName): { resourceContainerName+: if std.isArray(v=resourceContainerName) then resourceContainerName else [resourceContainerName] },
        '#withResourceDetailsOther':: d.fn(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\"", args=[d.arg(name='resourceDetailsOther', type=d.T.array)]),
        withResourceDetailsOther(resourceDetailsOther): { resourceDetailsOther: if std.isArray(v=resourceDetailsOther) then resourceDetailsOther else [resourceDetailsOther] },
        '#withResourceDetailsOtherMixin':: d.fn(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='resourceDetailsOther', type=d.T.array)]),
        withResourceDetailsOtherMixin(resourceDetailsOther): { resourceDetailsOther+: if std.isArray(v=resourceDetailsOther) then resourceDetailsOther else [resourceDetailsOther] },
        '#withResourceId':: d.fn(help='"The canonical identifier for the given resource type. See String Filter below for more details."', args=[d.arg(name='resourceId', type=d.T.array)]),
        withResourceId(resourceId): { resourceId: if std.isArray(v=resourceId) then resourceId else [resourceId] },
        '#withResourceIdMixin':: d.fn(help='"The canonical identifier for the given resource type. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceId', type=d.T.array)]),
        withResourceIdMixin(resourceId): { resourceId+: if std.isArray(v=resourceId) then resourceId else [resourceId] },
        '#withResourcePartition':: d.fn(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."', args=[d.arg(name='resourcePartition', type=d.T.array)]),
        withResourcePartition(resourcePartition): { resourcePartition: if std.isArray(v=resourcePartition) then resourcePartition else [resourcePartition] },
        '#withResourcePartitionMixin':: d.fn(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourcePartition', type=d.T.array)]),
        withResourcePartitionMixin(resourcePartition): { resourcePartition+: if std.isArray(v=resourcePartition) then resourcePartition else [resourcePartition] },
        '#withResourceRegion':: d.fn(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."', args=[d.arg(name='resourceRegion', type=d.T.array)]),
        withResourceRegion(resourceRegion): { resourceRegion: if std.isArray(v=resourceRegion) then resourceRegion else [resourceRegion] },
        '#withResourceRegionMixin':: d.fn(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceRegion', type=d.T.array)]),
        withResourceRegionMixin(resourceRegion): { resourceRegion+: if std.isArray(v=resourceRegion) then resourceRegion else [resourceRegion] },
        '#withResourceTags':: d.fn(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."', args=[d.arg(name='resourceTags', type=d.T.array)]),
        withResourceTags(resourceTags): { resourceTags: if std.isArray(v=resourceTags) then resourceTags else [resourceTags] },
        '#withResourceTagsMixin':: d.fn(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceTags', type=d.T.array)]),
        withResourceTagsMixin(resourceTags): { resourceTags+: if std.isArray(v=resourceTags) then resourceTags else [resourceTags] },
        '#withResourceType':: d.fn(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."', args=[d.arg(name='resourceType', type=d.T.array)]),
        withResourceType(resourceType): { resourceType: if std.isArray(v=resourceType) then resourceType else [resourceType] },
        '#withResourceTypeMixin':: d.fn(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceType', type=d.T.array)]),
        withResourceTypeMixin(resourceType): { resourceType+: if std.isArray(v=resourceType) then resourceType else [resourceType] },
        '#withSeverityLabel':: d.fn(help="\"The label of a finding's severity. See String Filter below for more details.\"", args=[d.arg(name='severityLabel', type=d.T.array)]),
        withSeverityLabel(severityLabel): { severityLabel: if std.isArray(v=severityLabel) then severityLabel else [severityLabel] },
        '#withSeverityLabelMixin':: d.fn(help="\"The label of a finding's severity. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='severityLabel', type=d.T.array)]),
        withSeverityLabelMixin(severityLabel): { severityLabel+: if std.isArray(v=severityLabel) then severityLabel else [severityLabel] },
        '#withSourceUrl':: d.fn(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\"", args=[d.arg(name='sourceUrl', type=d.T.array)]),
        withSourceUrl(sourceUrl): { sourceUrl: if std.isArray(v=sourceUrl) then sourceUrl else [sourceUrl] },
        '#withSourceUrlMixin':: d.fn(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='sourceUrl', type=d.T.array)]),
        withSourceUrlMixin(sourceUrl): { sourceUrl+: if std.isArray(v=sourceUrl) then sourceUrl else [sourceUrl] },
        '#withThreatIntelIndicatorCategory':: d.fn(help='"The category of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorCategory', type=d.T.array)]),
        withThreatIntelIndicatorCategory(threatIntelIndicatorCategory): { threatIntelIndicatorCategory: if std.isArray(v=threatIntelIndicatorCategory) then threatIntelIndicatorCategory else [threatIntelIndicatorCategory] },
        '#withThreatIntelIndicatorCategoryMixin':: d.fn(help='"The category of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorCategory', type=d.T.array)]),
        withThreatIntelIndicatorCategoryMixin(threatIntelIndicatorCategory): { threatIntelIndicatorCategory+: if std.isArray(v=threatIntelIndicatorCategory) then threatIntelIndicatorCategory else [threatIntelIndicatorCategory] },
        '#withThreatIntelIndicatorLastObservedAt':: d.fn(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."', args=[d.arg(name='threatIntelIndicatorLastObservedAt', type=d.T.array)]),
        withThreatIntelIndicatorLastObservedAt(threatIntelIndicatorLastObservedAt): { threatIntelIndicatorLastObservedAt: if std.isArray(v=threatIntelIndicatorLastObservedAt) then threatIntelIndicatorLastObservedAt else [threatIntelIndicatorLastObservedAt] },
        '#withThreatIntelIndicatorLastObservedAtMixin':: d.fn(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorLastObservedAt', type=d.T.array)]),
        withThreatIntelIndicatorLastObservedAtMixin(threatIntelIndicatorLastObservedAt): { threatIntelIndicatorLastObservedAt+: if std.isArray(v=threatIntelIndicatorLastObservedAt) then threatIntelIndicatorLastObservedAt else [threatIntelIndicatorLastObservedAt] },
        '#withThreatIntelIndicatorSource':: d.fn(help='"The source of the threat intelligence. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorSource', type=d.T.array)]),
        withThreatIntelIndicatorSource(threatIntelIndicatorSource): { threatIntelIndicatorSource: if std.isArray(v=threatIntelIndicatorSource) then threatIntelIndicatorSource else [threatIntelIndicatorSource] },
        '#withThreatIntelIndicatorSourceMixin':: d.fn(help='"The source of the threat intelligence. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorSource', type=d.T.array)]),
        withThreatIntelIndicatorSourceMixin(threatIntelIndicatorSource): { threatIntelIndicatorSource+: if std.isArray(v=threatIntelIndicatorSource) then threatIntelIndicatorSource else [threatIntelIndicatorSource] },
        '#withThreatIntelIndicatorSourceUrl':: d.fn(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorSourceUrl', type=d.T.array)]),
        withThreatIntelIndicatorSourceUrl(threatIntelIndicatorSourceUrl): { threatIntelIndicatorSourceUrl: if std.isArray(v=threatIntelIndicatorSourceUrl) then threatIntelIndicatorSourceUrl else [threatIntelIndicatorSourceUrl] },
        '#withThreatIntelIndicatorSourceUrlMixin':: d.fn(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorSourceUrl', type=d.T.array)]),
        withThreatIntelIndicatorSourceUrlMixin(threatIntelIndicatorSourceUrl): { threatIntelIndicatorSourceUrl+: if std.isArray(v=threatIntelIndicatorSourceUrl) then threatIntelIndicatorSourceUrl else [threatIntelIndicatorSourceUrl] },
        '#withThreatIntelIndicatorType':: d.fn(help='"The type of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorType', type=d.T.array)]),
        withThreatIntelIndicatorType(threatIntelIndicatorType): { threatIntelIndicatorType: if std.isArray(v=threatIntelIndicatorType) then threatIntelIndicatorType else [threatIntelIndicatorType] },
        '#withThreatIntelIndicatorTypeMixin':: d.fn(help='"The type of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorType', type=d.T.array)]),
        withThreatIntelIndicatorTypeMixin(threatIntelIndicatorType): { threatIntelIndicatorType+: if std.isArray(v=threatIntelIndicatorType) then threatIntelIndicatorType else [threatIntelIndicatorType] },
        '#withThreatIntelIndicatorValue':: d.fn(help='"The value of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorValue', type=d.T.array)]),
        withThreatIntelIndicatorValue(threatIntelIndicatorValue): { threatIntelIndicatorValue: if std.isArray(v=threatIntelIndicatorValue) then threatIntelIndicatorValue else [threatIntelIndicatorValue] },
        '#withThreatIntelIndicatorValueMixin':: d.fn(help='"The value of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorValue', type=d.T.array)]),
        withThreatIntelIndicatorValueMixin(threatIntelIndicatorValue): { threatIntelIndicatorValue+: if std.isArray(v=threatIntelIndicatorValue) then threatIntelIndicatorValue else [threatIntelIndicatorValue] },
        '#withTitle':: d.fn(help="\"A finding's title. See String Filter below for more details.\"", args=[d.arg(name='title', type=d.T.array)]),
        withTitle(title): { title: if std.isArray(v=title) then title else [title] },
        '#withTitleMixin':: d.fn(help="\"A finding's title. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='title', type=d.T.array)]),
        withTitleMixin(title): { title+: if std.isArray(v=title) then title else [title] },
        '#withType':: d.fn(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."', args=[d.arg(name='type', type=d.T.array)]),
        withType(type): { type: if std.isArray(v=type) then type else [type] },
        '#withTypeMixin':: d.fn(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='type', type=d.T.array)]),
        withTypeMixin(type): { type+: if std.isArray(v=type) then type else [type] },
        '#withUpdatedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."', args=[d.arg(name='updatedAt', type=d.T.array)]),
        withUpdatedAt(updatedAt): { updatedAt: if std.isArray(v=updatedAt) then updatedAt else [updatedAt] },
        '#withUpdatedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='updatedAt', type=d.T.array)]),
        withUpdatedAtMixin(updatedAt): { updatedAt+: if std.isArray(v=updatedAt) then updatedAt else [updatedAt] },
        '#withUserDefinedValues':: d.fn(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."', args=[d.arg(name='userDefinedValues', type=d.T.array)]),
        withUserDefinedValues(userDefinedValues): { userDefinedValues: if std.isArray(v=userDefinedValues) then userDefinedValues else [userDefinedValues] },
        '#withUserDefinedValuesMixin':: d.fn(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='userDefinedValues', type=d.T.array)]),
        withUserDefinedValuesMixin(userDefinedValues): { userDefinedValues+: if std.isArray(v=userDefinedValues) then userDefinedValues else [userDefinedValues] },
        '#withVerificationState':: d.fn(help='"The veracity of a finding. See String Filter below for more details."', args=[d.arg(name='verificationState', type=d.T.array)]),
        withVerificationState(verificationState): { verificationState: if std.isArray(v=verificationState) then verificationState else [verificationState] },
        '#withVerificationStateMixin':: d.fn(help='"The veracity of a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='verificationState', type=d.T.array)]),
        withVerificationStateMixin(verificationState): { verificationState+: if std.isArray(v=verificationState) then verificationState else [verificationState] },
        '#withWorkflowStatus':: d.fn(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."', args=[d.arg(name='workflowStatus', type=d.T.array)]),
        withWorkflowStatus(workflowStatus): { workflowStatus: if std.isArray(v=workflowStatus) then workflowStatus else [workflowStatus] },
        '#withWorkflowStatusMixin':: d.fn(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflowStatus', type=d.T.array)]),
        withWorkflowStatusMixin(workflowStatus): { workflowStatus+: if std.isArray(v=workflowStatus) then workflowStatus else [workflowStatus] },
        '#workflowStatus':: d.obj(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."'),
        workflowStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
      },
      '#withFilters':: d.fn(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."', args=[d.arg(name='filters', type=d.T.array)]),
      withFilters(filters): { spec+: { forProvider+: { filters: if std.isArray(v=filters) then filters else [filters] } } },
      '#withFiltersMixin':: d.fn(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='filters', type=d.T.array)]),
      withFiltersMixin(filters): { spec+: { forProvider+: { filters+: if std.isArray(v=filters) then filters else [filters] } } },
      '#withGroupByAttribute':: d.fn(help='"The attribute used to group the findings for the insight e.g., if an insight is grouped by ResourceId, then the insight produces a list of resource identifiers."', args=[d.arg(name='groupByAttribute', type=d.T.string)]),
      withGroupByAttribute(groupByAttribute): { spec+: { forProvider+: { groupByAttribute: groupByAttribute } } },
      '#withName':: d.fn(help='"The name of the custom insight."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { forProvider+: { name: name } } },
      '#withRegion':: d.fn(help="\"Region where this resource will be managed. Defaults to the Region set in the provider configuration.\\nRegion is the region you'd like your resource to be created in.\"", args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { spec+: { forProvider+: { region: region } } },
    },
    '#initProvider':: d.obj(help='"THIS IS A BETA FIELD. It will be honored\\nunless the Management Policies feature flag is disabled.\\nInitProvider holds the same fields as ForProvider, with the exception\\nof Identifier and other resource reference fields. The fields that are\\nin InitProvider are merged into ForProvider when the resource is created.\\nThe same fields are also added to the terraform ignore_changes hook, to\\navoid updating them after creation. This is useful for fields that are\\nrequired on creation, but we do not desire to update them after creation,\\nfor example because of an external controller is managing them, like an\\nautoscaler."'),
    initProvider: {
      '#filters':: d.obj(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."'),
      filters: {
        '#awsAccountId':: d.obj(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."'),
        awsAccountId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#companyName':: d.obj(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."'),
        companyName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#complianceStatus':: d.obj(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."'),
        complianceStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#confidence':: d.obj(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\""),
        confidence: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#createdAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."'),
        createdAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#criticality':: d.obj(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."'),
        criticality: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#description':: d.obj(help="\"A finding's description. See String Filter below for more details.\""),
        description: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsConfidence':: d.obj(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."'),
        findingProviderFieldsConfidence: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#findingProviderFieldsCriticality':: d.obj(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."'),
        findingProviderFieldsCriticality: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#findingProviderFieldsRelatedFindingsId':: d.obj(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."'),
        findingProviderFieldsRelatedFindingsId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsRelatedFindingsProductArn':: d.obj(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."'),
        findingProviderFieldsRelatedFindingsProductArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsSeverityLabel':: d.obj(help='"The finding provider value for the severity label. See String Filter below for more details."'),
        findingProviderFieldsSeverityLabel: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsSeverityOriginal':: d.obj(help="\"The finding provider's original value for the severity. See String Filter below for more details.\""),
        findingProviderFieldsSeverityOriginal: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#findingProviderFieldsTypes':: d.obj(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."'),
        findingProviderFieldsTypes: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#firstObservedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."'),
        firstObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#generatorId':: d.obj(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."'),
        generatorId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#id':: d.obj(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."'),
        id: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#keyword':: d.obj(help='"A keyword for a finding. See Keyword Filter below for more details."'),
        keyword: {
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#lastObservedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."'),
        lastObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#malwareName':: d.obj(help='"The name of the malware that was observed. See String Filter below for more details."'),
        malwareName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwarePath':: d.obj(help='"The filesystem path of the malware that was observed. See String Filter below for more details."'),
        malwarePath: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwareState':: d.obj(help='"The state of the malware that was observed. See String Filter below for more details."'),
        malwareState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#malwareType':: d.obj(help='"The type of the malware that was observed. See String Filter below for more details."'),
        malwareType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkDestinationDomain':: d.obj(help='"The destination domain of network-related information about a finding. See String Filter below for more details."'),
        networkDestinationDomain: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkDestinationIpv4':: d.obj(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkDestinationIpv4: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkDestinationIpv6':: d.obj(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkDestinationIpv6: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkDestinationPort':: d.obj(help='"The destination port of network-related information about a finding. See Number Filter below for more details."'),
        networkDestinationPort: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#networkDirection':: d.obj(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."'),
        networkDirection: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkProtocol':: d.obj(help='"The protocol of network-related information about a finding. See String Filter below for more details."'),
        networkProtocol: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourceDomain':: d.obj(help='"The source domain of network-related information about a finding. See String Filter below for more details."'),
        networkSourceDomain: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourceIpv4':: d.obj(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkSourceIpv4: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkSourceIpv6':: d.obj(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."'),
        networkSourceIpv6: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#networkSourceMac':: d.obj(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."'),
        networkSourceMac: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#networkSourcePort':: d.obj(help='"The source port of network-related information about a finding. See Number Filter below for more details."'),
        networkSourcePort: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#noteText':: d.obj(help='"The text of a note. See String Filter below for more details."'),
        noteText: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#noteUpdatedAt':: d.obj(help='"The timestamp of when the note was updated. See Date Filter below for more details."'),
        noteUpdatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#noteUpdatedBy':: d.obj(help='"The principal that created a note. See String Filter below for more details."'),
        noteUpdatedBy: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processLaunchedAt':: d.obj(help='"The date/time that the process was launched. See Date Filter below for more details."'),
        processLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#processName':: d.obj(help='"The name of the process. See String Filter below for more details."'),
        processName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processParentPid':: d.obj(help='"The parent process ID. See Number Filter below for more details."'),
        processParentPid: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#processPath':: d.obj(help='"The path to the process executable. See String Filter below for more details."'),
        processPath: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#processPid':: d.obj(help='"The process ID. See Number Filter below for more details."'),
        processPid: {
          '#withEq':: d.fn(help='"The equal-to condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='eq', type=d.T.string)]),
          withEq(eq): { eq: eq },
          '#withGte':: d.fn(help='"The greater-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='gte', type=d.T.string)]),
          withGte(gte): { gte: gte },
          '#withLte':: d.fn(help='"The less-than-equal condition to be applied to a single field when querying for findings, provided as a String."', args=[d.arg(name='lte', type=d.T.string)]),
          withLte(lte): { lte: lte },
        },
        '#processTerminatedAt':: d.obj(help='"The date/time that the process was terminated. See Date Filter below for more details."'),
        processTerminatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#productArn':: d.obj(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\""),
        productArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#productFields':: d.obj(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\""),
        productFields: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#productName':: d.obj(help='"The name of the solution (product) that generates findings. See String Filter below for more details."'),
        productName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#recommendationText':: d.obj(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."'),
        recommendationText: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#recordState':: d.obj(help='"The updated record state for the finding. See String Filter below for more details."'),
        recordState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#relatedFindingsId':: d.obj(help='"The solution-generated identifier for a related finding. See String Filter below for more details."'),
        relatedFindingsId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#relatedFindingsProductArn':: d.obj(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."'),
        relatedFindingsProductArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceIamInstanceProfileArn':: d.obj(help='"The IAM profile ARN of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceIamInstanceProfileArn: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceImageId':: d.obj(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceImageId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceIpv4Addresses':: d.obj(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."'),
        resourceAwsEc2InstanceIpv4Addresses: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#resourceAwsEc2InstanceIpv6Addresses':: d.obj(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."'),
        resourceAwsEc2InstanceIpv6Addresses: {
          '#withCidr':: d.fn(help="\"A finding's CIDR value.\"", args=[d.arg(name='cidr', type=d.T.string)]),
          withCidr(cidr): { cidr: cidr },
        },
        '#resourceAwsEc2InstanceKeyName':: d.obj(help='"The key name associated with the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceKeyName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceLaunchedAt':: d.obj(help='"The date and time the instance was launched. See Date Filter below for more details."'),
        resourceAwsEc2InstanceLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceAwsEc2InstanceSubnetId':: d.obj(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."'),
        resourceAwsEc2InstanceSubnetId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceType':: d.obj(help='"The instance type of the instance. See String Filter below for more details."'),
        resourceAwsEc2InstanceType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsEc2InstanceVpcId':: d.obj(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."'),
        resourceAwsEc2InstanceVpcId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsIamAccessKeyCreatedAt':: d.obj(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."'),
        resourceAwsIamAccessKeyCreatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceAwsIamAccessKeyStatus':: d.obj(help='"The status of the IAM access key related to a finding. See String Filter below for more details."'),
        resourceAwsIamAccessKeyStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsIamAccessKeyUserName':: d.obj(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."'),
        resourceAwsIamAccessKeyUserName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsS3BucketOwnerId':: d.obj(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."'),
        resourceAwsS3BucketOwnerId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceAwsS3BucketOwnerName':: d.obj(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."'),
        resourceAwsS3BucketOwnerName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerImageId':: d.obj(help='"The identifier of the image related to a finding. See String Filter below for more details."'),
        resourceContainerImageId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerImageName':: d.obj(help='"The name of the image related to a finding. See String Filter below for more details."'),
        resourceContainerImageName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceContainerLaunchedAt':: d.obj(help='"The date/time that the container was started. See Date Filter below for more details."'),
        resourceContainerLaunchedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#resourceContainerName':: d.obj(help='"The name of the container related to a finding. See String Filter below for more details."'),
        resourceContainerName: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceDetailsOther':: d.obj(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\""),
        resourceDetailsOther: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceId':: d.obj(help='"The canonical identifier for the given resource type. See String Filter below for more details."'),
        resourceId: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourcePartition':: d.obj(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."'),
        resourcePartition: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceRegion':: d.obj(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."'),
        resourceRegion: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceTags':: d.obj(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."'),
        resourceTags: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#resourceType':: d.obj(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."'),
        resourceType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#severityLabel':: d.obj(help="\"The label of a finding's severity. See String Filter below for more details.\""),
        severityLabel: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#sourceUrl':: d.obj(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\""),
        sourceUrl: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorCategory':: d.obj(help='"The category of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorCategory: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorLastObservedAt':: d.obj(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."'),
        threatIntelIndicatorLastObservedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#threatIntelIndicatorSource':: d.obj(help='"The source of the threat intelligence. See String Filter below for more details."'),
        threatIntelIndicatorSource: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorSourceUrl':: d.obj(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."'),
        threatIntelIndicatorSourceUrl: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorType':: d.obj(help='"The type of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorType: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#threatIntelIndicatorValue':: d.obj(help='"The value of a threat intelligence indicator. See String Filter below for more details."'),
        threatIntelIndicatorValue: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#title':: d.obj(help="\"A finding's title. See String Filter below for more details.\""),
        title: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#type':: d.obj(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."'),
        type: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#updatedAt':: d.obj(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."'),
        updatedAt: {
          '#dateRange':: d.obj(help='"A configuration block of the date range for the date filter. See date_range below for more details."'),
          dateRange: {
            '#withUnit':: d.fn(help='"A date range unit for the date filter. Valid values: DAYS."', args=[d.arg(name='unit', type=d.T.string)]),
            withUnit(unit): { unit: unit },
            '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDateRange':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRange(dateRange): { dateRange: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withDateRangeMixin':: d.fn(help='"A configuration block of the date range for the date filter. See date_range below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dateRange', type=d.T.array)]),
          withDateRangeMixin(dateRange): { dateRange+: if std.isArray(v=dateRange) then dateRange else [dateRange] },
          '#withEnd':: d.fn(help='"An end date for the date filter. Required with start if date_range is not specified."', args=[d.arg(name='end', type=d.T.string)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"A start date for the date filter. Required with end if date_range is not specified."', args=[d.arg(name='start', type=d.T.string)]),
          withStart(start): { start: start },
        },
        '#userDefinedValues':: d.obj(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."'),
        userDefinedValues: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withKey':: d.fn(help='"The key of the map filter. For example, for ResourceTags, Key identifies the name of the tag. For UserDefinedFields, Key is the name of the field."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#verificationState':: d.obj(help='"The veracity of a finding. See String Filter below for more details."'),
        verificationState: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withAwsAccountId':: d.fn(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."', args=[d.arg(name='awsAccountId', type=d.T.array)]),
        withAwsAccountId(awsAccountId): { awsAccountId: if std.isArray(v=awsAccountId) then awsAccountId else [awsAccountId] },
        '#withAwsAccountIdMixin':: d.fn(help='"AWS account ID that a finding is generated in. See String_Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='awsAccountId', type=d.T.array)]),
        withAwsAccountIdMixin(awsAccountId): { awsAccountId+: if std.isArray(v=awsAccountId) then awsAccountId else [awsAccountId] },
        '#withCompanyName':: d.fn(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."', args=[d.arg(name='companyName', type=d.T.array)]),
        withCompanyName(companyName): { companyName: if std.isArray(v=companyName) then companyName else [companyName] },
        '#withCompanyNameMixin':: d.fn(help='"The name of the findings provider (company) that owns the solution (product) that generates findings. See String_Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='companyName', type=d.T.array)]),
        withCompanyNameMixin(companyName): { companyName+: if std.isArray(v=companyName) then companyName else [companyName] },
        '#withComplianceStatus':: d.fn(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."', args=[d.arg(name='complianceStatus', type=d.T.array)]),
        withComplianceStatus(complianceStatus): { complianceStatus: if std.isArray(v=complianceStatus) then complianceStatus else [complianceStatus] },
        '#withComplianceStatusMixin':: d.fn(help='"Exclusive to findings that are generated as the result of a check run against a specific rule in a supported standard, such as CIS AWS Foundations. Contains security standard-related finding details. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='complianceStatus', type=d.T.array)]),
        withComplianceStatusMixin(complianceStatus): { complianceStatus+: if std.isArray(v=complianceStatus) then complianceStatus else [complianceStatus] },
        '#withConfidence':: d.fn(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\"", args=[d.arg(name='confidence', type=d.T.array)]),
        withConfidence(confidence): { confidence: if std.isArray(v=confidence) then confidence else [confidence] },
        '#withConfidenceMixin':: d.fn(help="\"A finding's confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='confidence', type=d.T.array)]),
        withConfidenceMixin(confidence): { confidence+: if std.isArray(v=confidence) then confidence else [confidence] },
        '#withCreatedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='createdAt', type=d.T.array)]),
        withCreatedAt(createdAt): { createdAt: if std.isArray(v=createdAt) then createdAt else [createdAt] },
        '#withCreatedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider captured the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='createdAt', type=d.T.array)]),
        withCreatedAtMixin(createdAt): { createdAt+: if std.isArray(v=createdAt) then createdAt else [createdAt] },
        '#withCriticality':: d.fn(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."', args=[d.arg(name='criticality', type=d.T.array)]),
        withCriticality(criticality): { criticality: if std.isArray(v=criticality) then criticality else [criticality] },
        '#withCriticalityMixin':: d.fn(help='"The level of importance assigned to the resources associated with the finding. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='criticality', type=d.T.array)]),
        withCriticalityMixin(criticality): { criticality+: if std.isArray(v=criticality) then criticality else [criticality] },
        '#withDescription':: d.fn(help="\"A finding's description. See String Filter below for more details.\"", args=[d.arg(name='description', type=d.T.array)]),
        withDescription(description): { description: if std.isArray(v=description) then description else [description] },
        '#withDescriptionMixin':: d.fn(help="\"A finding's description. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='description', type=d.T.array)]),
        withDescriptionMixin(description): { description+: if std.isArray(v=description) then description else [description] },
        '#withFindingProviderFieldsConfidence':: d.fn(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."', args=[d.arg(name='findingProviderFieldsConfidence', type=d.T.array)]),
        withFindingProviderFieldsConfidence(findingProviderFieldsConfidence): { findingProviderFieldsConfidence: if std.isArray(v=findingProviderFieldsConfidence) then findingProviderFieldsConfidence else [findingProviderFieldsConfidence] },
        '#withFindingProviderFieldsConfidenceMixin':: d.fn(help='"The finding provider value for the finding confidence. Confidence is defined as the likelihood that a finding accurately identifies the behavior or issue that it was intended to identify. Confidence is scored on a 0-100 basis using a ratio scale, where 0 means zero percent confidence and 100 means 100 percent confidence. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsConfidence', type=d.T.array)]),
        withFindingProviderFieldsConfidenceMixin(findingProviderFieldsConfidence): { findingProviderFieldsConfidence+: if std.isArray(v=findingProviderFieldsConfidence) then findingProviderFieldsConfidence else [findingProviderFieldsConfidence] },
        '#withFindingProviderFieldsCriticality':: d.fn(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."', args=[d.arg(name='findingProviderFieldsCriticality', type=d.T.array)]),
        withFindingProviderFieldsCriticality(findingProviderFieldsCriticality): { findingProviderFieldsCriticality: if std.isArray(v=findingProviderFieldsCriticality) then findingProviderFieldsCriticality else [findingProviderFieldsCriticality] },
        '#withFindingProviderFieldsCriticalityMixin':: d.fn(help='"The finding provider value for the level of importance assigned to the resources associated with the findings. A score of 0 means that the underlying resources have no criticality, and a score of 100 is reserved for the most critical resources. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsCriticality', type=d.T.array)]),
        withFindingProviderFieldsCriticalityMixin(findingProviderFieldsCriticality): { findingProviderFieldsCriticality+: if std.isArray(v=findingProviderFieldsCriticality) then findingProviderFieldsCriticality else [findingProviderFieldsCriticality] },
        '#withFindingProviderFieldsRelatedFindingsId':: d.fn(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsRelatedFindingsId', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsId(findingProviderFieldsRelatedFindingsId): { findingProviderFieldsRelatedFindingsId: if std.isArray(v=findingProviderFieldsRelatedFindingsId) then findingProviderFieldsRelatedFindingsId else [findingProviderFieldsRelatedFindingsId] },
        '#withFindingProviderFieldsRelatedFindingsIdMixin':: d.fn(help='"The finding identifier of a related finding that is identified by the finding provider. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsRelatedFindingsId', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsIdMixin(findingProviderFieldsRelatedFindingsId): { findingProviderFieldsRelatedFindingsId+: if std.isArray(v=findingProviderFieldsRelatedFindingsId) then findingProviderFieldsRelatedFindingsId else [findingProviderFieldsRelatedFindingsId] },
        '#withFindingProviderFieldsRelatedFindingsProductArn':: d.fn(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsRelatedFindingsProductArn', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsProductArn(findingProviderFieldsRelatedFindingsProductArn): { findingProviderFieldsRelatedFindingsProductArn: if std.isArray(v=findingProviderFieldsRelatedFindingsProductArn) then findingProviderFieldsRelatedFindingsProductArn else [findingProviderFieldsRelatedFindingsProductArn] },
        '#withFindingProviderFieldsRelatedFindingsProductArnMixin':: d.fn(help='"The ARN of the solution that generated a related finding that is identified by the finding provider. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsRelatedFindingsProductArn', type=d.T.array)]),
        withFindingProviderFieldsRelatedFindingsProductArnMixin(findingProviderFieldsRelatedFindingsProductArn): { findingProviderFieldsRelatedFindingsProductArn+: if std.isArray(v=findingProviderFieldsRelatedFindingsProductArn) then findingProviderFieldsRelatedFindingsProductArn else [findingProviderFieldsRelatedFindingsProductArn] },
        '#withFindingProviderFieldsSeverityLabel':: d.fn(help='"The finding provider value for the severity label. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsSeverityLabel', type=d.T.array)]),
        withFindingProviderFieldsSeverityLabel(findingProviderFieldsSeverityLabel): { findingProviderFieldsSeverityLabel: if std.isArray(v=findingProviderFieldsSeverityLabel) then findingProviderFieldsSeverityLabel else [findingProviderFieldsSeverityLabel] },
        '#withFindingProviderFieldsSeverityLabelMixin':: d.fn(help='"The finding provider value for the severity label. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsSeverityLabel', type=d.T.array)]),
        withFindingProviderFieldsSeverityLabelMixin(findingProviderFieldsSeverityLabel): { findingProviderFieldsSeverityLabel+: if std.isArray(v=findingProviderFieldsSeverityLabel) then findingProviderFieldsSeverityLabel else [findingProviderFieldsSeverityLabel] },
        '#withFindingProviderFieldsSeverityOriginal':: d.fn(help="\"The finding provider's original value for the severity. See String Filter below for more details.\"", args=[d.arg(name='findingProviderFieldsSeverityOriginal', type=d.T.array)]),
        withFindingProviderFieldsSeverityOriginal(findingProviderFieldsSeverityOriginal): { findingProviderFieldsSeverityOriginal: if std.isArray(v=findingProviderFieldsSeverityOriginal) then findingProviderFieldsSeverityOriginal else [findingProviderFieldsSeverityOriginal] },
        '#withFindingProviderFieldsSeverityOriginalMixin':: d.fn(help="\"The finding provider's original value for the severity. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='findingProviderFieldsSeverityOriginal', type=d.T.array)]),
        withFindingProviderFieldsSeverityOriginalMixin(findingProviderFieldsSeverityOriginal): { findingProviderFieldsSeverityOriginal+: if std.isArray(v=findingProviderFieldsSeverityOriginal) then findingProviderFieldsSeverityOriginal else [findingProviderFieldsSeverityOriginal] },
        '#withFindingProviderFieldsTypes':: d.fn(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."', args=[d.arg(name='findingProviderFieldsTypes', type=d.T.array)]),
        withFindingProviderFieldsTypes(findingProviderFieldsTypes): { findingProviderFieldsTypes: if std.isArray(v=findingProviderFieldsTypes) then findingProviderFieldsTypes else [findingProviderFieldsTypes] },
        '#withFindingProviderFieldsTypesMixin':: d.fn(help='"One or more finding types that the finding provider assigned to the finding. Uses the format of namespace/category/classifier that classify a finding. Valid namespace values include: Software and Configuration Checks, TTPs, Effects, Unusual Behaviors, and Sensitive Data Identifications. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='findingProviderFieldsTypes', type=d.T.array)]),
        withFindingProviderFieldsTypesMixin(findingProviderFieldsTypes): { findingProviderFieldsTypes+: if std.isArray(v=findingProviderFieldsTypes) then findingProviderFieldsTypes else [findingProviderFieldsTypes] },
        '#withFirstObservedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='firstObservedAt', type=d.T.array)]),
        withFirstObservedAt(firstObservedAt): { firstObservedAt: if std.isArray(v=firstObservedAt) then firstObservedAt else [firstObservedAt] },
        '#withFirstObservedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider first observed the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='firstObservedAt', type=d.T.array)]),
        withFirstObservedAtMixin(firstObservedAt): { firstObservedAt+: if std.isArray(v=firstObservedAt) then firstObservedAt else [firstObservedAt] },
        '#withGeneratorId':: d.fn(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."', args=[d.arg(name='generatorId', type=d.T.array)]),
        withGeneratorId(generatorId): { generatorId: if std.isArray(v=generatorId) then generatorId else [generatorId] },
        '#withGeneratorIdMixin':: d.fn(help='"The identifier for the solution-specific component (a discrete unit of logic) that generated a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='generatorId', type=d.T.array)]),
        withGeneratorIdMixin(generatorId): { generatorId+: if std.isArray(v=generatorId) then generatorId else [generatorId] },
        '#withId':: d.fn(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."', args=[d.arg(name='id', type=d.T.array)]),
        withId(id): { id: if std.isArray(v=id) then id else [id] },
        '#withIdMixin':: d.fn(help='"The security findings provider-specific identifier for a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='id', type=d.T.array)]),
        withIdMixin(id): { id+: if std.isArray(v=id) then id else [id] },
        '#withKeyword':: d.fn(help='"A keyword for a finding. See Keyword Filter below for more details."', args=[d.arg(name='keyword', type=d.T.array)]),
        withKeyword(keyword): { keyword: if std.isArray(v=keyword) then keyword else [keyword] },
        '#withKeywordMixin':: d.fn(help='"A keyword for a finding. See Keyword Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='keyword', type=d.T.array)]),
        withKeywordMixin(keyword): { keyword+: if std.isArray(v=keyword) then keyword else [keyword] },
        '#withLastObservedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."', args=[d.arg(name='lastObservedAt', type=d.T.array)]),
        withLastObservedAt(lastObservedAt): { lastObservedAt: if std.isArray(v=lastObservedAt) then lastObservedAt else [lastObservedAt] },
        '#withLastObservedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider most recently observed the potential security issue that a finding captured. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='lastObservedAt', type=d.T.array)]),
        withLastObservedAtMixin(lastObservedAt): { lastObservedAt+: if std.isArray(v=lastObservedAt) then lastObservedAt else [lastObservedAt] },
        '#withMalwareName':: d.fn(help='"The name of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareName', type=d.T.array)]),
        withMalwareName(malwareName): { malwareName: if std.isArray(v=malwareName) then malwareName else [malwareName] },
        '#withMalwareNameMixin':: d.fn(help='"The name of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareName', type=d.T.array)]),
        withMalwareNameMixin(malwareName): { malwareName+: if std.isArray(v=malwareName) then malwareName else [malwareName] },
        '#withMalwarePath':: d.fn(help='"The filesystem path of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwarePath', type=d.T.array)]),
        withMalwarePath(malwarePath): { malwarePath: if std.isArray(v=malwarePath) then malwarePath else [malwarePath] },
        '#withMalwarePathMixin':: d.fn(help='"The filesystem path of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwarePath', type=d.T.array)]),
        withMalwarePathMixin(malwarePath): { malwarePath+: if std.isArray(v=malwarePath) then malwarePath else [malwarePath] },
        '#withMalwareState':: d.fn(help='"The state of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareState', type=d.T.array)]),
        withMalwareState(malwareState): { malwareState: if std.isArray(v=malwareState) then malwareState else [malwareState] },
        '#withMalwareStateMixin':: d.fn(help='"The state of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareState', type=d.T.array)]),
        withMalwareStateMixin(malwareState): { malwareState+: if std.isArray(v=malwareState) then malwareState else [malwareState] },
        '#withMalwareType':: d.fn(help='"The type of the malware that was observed. See String Filter below for more details."', args=[d.arg(name='malwareType', type=d.T.array)]),
        withMalwareType(malwareType): { malwareType: if std.isArray(v=malwareType) then malwareType else [malwareType] },
        '#withMalwareTypeMixin':: d.fn(help='"The type of the malware that was observed. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='malwareType', type=d.T.array)]),
        withMalwareTypeMixin(malwareType): { malwareType+: if std.isArray(v=malwareType) then malwareType else [malwareType] },
        '#withNetworkDestinationDomain':: d.fn(help='"The destination domain of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkDestinationDomain', type=d.T.array)]),
        withNetworkDestinationDomain(networkDestinationDomain): { networkDestinationDomain: if std.isArray(v=networkDestinationDomain) then networkDestinationDomain else [networkDestinationDomain] },
        '#withNetworkDestinationDomainMixin':: d.fn(help='"The destination domain of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationDomain', type=d.T.array)]),
        withNetworkDestinationDomainMixin(networkDestinationDomain): { networkDestinationDomain+: if std.isArray(v=networkDestinationDomain) then networkDestinationDomain else [networkDestinationDomain] },
        '#withNetworkDestinationIpv4':: d.fn(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkDestinationIpv4', type=d.T.array)]),
        withNetworkDestinationIpv4(networkDestinationIpv4): { networkDestinationIpv4: if std.isArray(v=networkDestinationIpv4) then networkDestinationIpv4 else [networkDestinationIpv4] },
        '#withNetworkDestinationIpv4Mixin':: d.fn(help='"The destination IPv4 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationIpv4', type=d.T.array)]),
        withNetworkDestinationIpv4Mixin(networkDestinationIpv4): { networkDestinationIpv4+: if std.isArray(v=networkDestinationIpv4) then networkDestinationIpv4 else [networkDestinationIpv4] },
        '#withNetworkDestinationIpv6':: d.fn(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkDestinationIpv6', type=d.T.array)]),
        withNetworkDestinationIpv6(networkDestinationIpv6): { networkDestinationIpv6: if std.isArray(v=networkDestinationIpv6) then networkDestinationIpv6 else [networkDestinationIpv6] },
        '#withNetworkDestinationIpv6Mixin':: d.fn(help='"The destination IPv6 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationIpv6', type=d.T.array)]),
        withNetworkDestinationIpv6Mixin(networkDestinationIpv6): { networkDestinationIpv6+: if std.isArray(v=networkDestinationIpv6) then networkDestinationIpv6 else [networkDestinationIpv6] },
        '#withNetworkDestinationPort':: d.fn(help='"The destination port of network-related information about a finding. See Number Filter below for more details."', args=[d.arg(name='networkDestinationPort', type=d.T.array)]),
        withNetworkDestinationPort(networkDestinationPort): { networkDestinationPort: if std.isArray(v=networkDestinationPort) then networkDestinationPort else [networkDestinationPort] },
        '#withNetworkDestinationPortMixin':: d.fn(help='"The destination port of network-related information about a finding. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDestinationPort', type=d.T.array)]),
        withNetworkDestinationPortMixin(networkDestinationPort): { networkDestinationPort+: if std.isArray(v=networkDestinationPort) then networkDestinationPort else [networkDestinationPort] },
        '#withNetworkDirection':: d.fn(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."', args=[d.arg(name='networkDirection', type=d.T.array)]),
        withNetworkDirection(networkDirection): { networkDirection: if std.isArray(v=networkDirection) then networkDirection else [networkDirection] },
        '#withNetworkDirectionMixin':: d.fn(help='"Indicates the direction of network traffic associated with a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkDirection', type=d.T.array)]),
        withNetworkDirectionMixin(networkDirection): { networkDirection+: if std.isArray(v=networkDirection) then networkDirection else [networkDirection] },
        '#withNetworkProtocol':: d.fn(help='"The protocol of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkProtocol', type=d.T.array)]),
        withNetworkProtocol(networkProtocol): { networkProtocol: if std.isArray(v=networkProtocol) then networkProtocol else [networkProtocol] },
        '#withNetworkProtocolMixin':: d.fn(help='"The protocol of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkProtocol', type=d.T.array)]),
        withNetworkProtocolMixin(networkProtocol): { networkProtocol+: if std.isArray(v=networkProtocol) then networkProtocol else [networkProtocol] },
        '#withNetworkSourceDomain':: d.fn(help='"The source domain of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkSourceDomain', type=d.T.array)]),
        withNetworkSourceDomain(networkSourceDomain): { networkSourceDomain: if std.isArray(v=networkSourceDomain) then networkSourceDomain else [networkSourceDomain] },
        '#withNetworkSourceDomainMixin':: d.fn(help='"The source domain of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceDomain', type=d.T.array)]),
        withNetworkSourceDomainMixin(networkSourceDomain): { networkSourceDomain+: if std.isArray(v=networkSourceDomain) then networkSourceDomain else [networkSourceDomain] },
        '#withNetworkSourceIpv4':: d.fn(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkSourceIpv4', type=d.T.array)]),
        withNetworkSourceIpv4(networkSourceIpv4): { networkSourceIpv4: if std.isArray(v=networkSourceIpv4) then networkSourceIpv4 else [networkSourceIpv4] },
        '#withNetworkSourceIpv4Mixin':: d.fn(help='"The source IPv4 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceIpv4', type=d.T.array)]),
        withNetworkSourceIpv4Mixin(networkSourceIpv4): { networkSourceIpv4+: if std.isArray(v=networkSourceIpv4) then networkSourceIpv4 else [networkSourceIpv4] },
        '#withNetworkSourceIpv6':: d.fn(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."', args=[d.arg(name='networkSourceIpv6', type=d.T.array)]),
        withNetworkSourceIpv6(networkSourceIpv6): { networkSourceIpv6: if std.isArray(v=networkSourceIpv6) then networkSourceIpv6 else [networkSourceIpv6] },
        '#withNetworkSourceIpv6Mixin':: d.fn(help='"The source IPv6 address of network-related information about a finding. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceIpv6', type=d.T.array)]),
        withNetworkSourceIpv6Mixin(networkSourceIpv6): { networkSourceIpv6+: if std.isArray(v=networkSourceIpv6) then networkSourceIpv6 else [networkSourceIpv6] },
        '#withNetworkSourceMac':: d.fn(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."', args=[d.arg(name='networkSourceMac', type=d.T.array)]),
        withNetworkSourceMac(networkSourceMac): { networkSourceMac: if std.isArray(v=networkSourceMac) then networkSourceMac else [networkSourceMac] },
        '#withNetworkSourceMacMixin':: d.fn(help='"The source media access control (MAC) address of network-related information about a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourceMac', type=d.T.array)]),
        withNetworkSourceMacMixin(networkSourceMac): { networkSourceMac+: if std.isArray(v=networkSourceMac) then networkSourceMac else [networkSourceMac] },
        '#withNetworkSourcePort':: d.fn(help='"The source port of network-related information about a finding. See Number Filter below for more details."', args=[d.arg(name='networkSourcePort', type=d.T.array)]),
        withNetworkSourcePort(networkSourcePort): { networkSourcePort: if std.isArray(v=networkSourcePort) then networkSourcePort else [networkSourcePort] },
        '#withNetworkSourcePortMixin':: d.fn(help='"The source port of network-related information about a finding. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='networkSourcePort', type=d.T.array)]),
        withNetworkSourcePortMixin(networkSourcePort): { networkSourcePort+: if std.isArray(v=networkSourcePort) then networkSourcePort else [networkSourcePort] },
        '#withNoteText':: d.fn(help='"The text of a note. See String Filter below for more details."', args=[d.arg(name='noteText', type=d.T.array)]),
        withNoteText(noteText): { noteText: if std.isArray(v=noteText) then noteText else [noteText] },
        '#withNoteTextMixin':: d.fn(help='"The text of a note. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteText', type=d.T.array)]),
        withNoteTextMixin(noteText): { noteText+: if std.isArray(v=noteText) then noteText else [noteText] },
        '#withNoteUpdatedAt':: d.fn(help='"The timestamp of when the note was updated. See Date Filter below for more details."', args=[d.arg(name='noteUpdatedAt', type=d.T.array)]),
        withNoteUpdatedAt(noteUpdatedAt): { noteUpdatedAt: if std.isArray(v=noteUpdatedAt) then noteUpdatedAt else [noteUpdatedAt] },
        '#withNoteUpdatedAtMixin':: d.fn(help='"The timestamp of when the note was updated. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteUpdatedAt', type=d.T.array)]),
        withNoteUpdatedAtMixin(noteUpdatedAt): { noteUpdatedAt+: if std.isArray(v=noteUpdatedAt) then noteUpdatedAt else [noteUpdatedAt] },
        '#withNoteUpdatedBy':: d.fn(help='"The principal that created a note. See String Filter below for more details."', args=[d.arg(name='noteUpdatedBy', type=d.T.array)]),
        withNoteUpdatedBy(noteUpdatedBy): { noteUpdatedBy: if std.isArray(v=noteUpdatedBy) then noteUpdatedBy else [noteUpdatedBy] },
        '#withNoteUpdatedByMixin':: d.fn(help='"The principal that created a note. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='noteUpdatedBy', type=d.T.array)]),
        withNoteUpdatedByMixin(noteUpdatedBy): { noteUpdatedBy+: if std.isArray(v=noteUpdatedBy) then noteUpdatedBy else [noteUpdatedBy] },
        '#withProcessLaunchedAt':: d.fn(help='"The date/time that the process was launched. See Date Filter below for more details."', args=[d.arg(name='processLaunchedAt', type=d.T.array)]),
        withProcessLaunchedAt(processLaunchedAt): { processLaunchedAt: if std.isArray(v=processLaunchedAt) then processLaunchedAt else [processLaunchedAt] },
        '#withProcessLaunchedAtMixin':: d.fn(help='"The date/time that the process was launched. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processLaunchedAt', type=d.T.array)]),
        withProcessLaunchedAtMixin(processLaunchedAt): { processLaunchedAt+: if std.isArray(v=processLaunchedAt) then processLaunchedAt else [processLaunchedAt] },
        '#withProcessName':: d.fn(help='"The name of the process. See String Filter below for more details."', args=[d.arg(name='processName', type=d.T.array)]),
        withProcessName(processName): { processName: if std.isArray(v=processName) then processName else [processName] },
        '#withProcessNameMixin':: d.fn(help='"The name of the process. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processName', type=d.T.array)]),
        withProcessNameMixin(processName): { processName+: if std.isArray(v=processName) then processName else [processName] },
        '#withProcessParentPid':: d.fn(help='"The parent process ID. See Number Filter below for more details."', args=[d.arg(name='processParentPid', type=d.T.array)]),
        withProcessParentPid(processParentPid): { processParentPid: if std.isArray(v=processParentPid) then processParentPid else [processParentPid] },
        '#withProcessParentPidMixin':: d.fn(help='"The parent process ID. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processParentPid', type=d.T.array)]),
        withProcessParentPidMixin(processParentPid): { processParentPid+: if std.isArray(v=processParentPid) then processParentPid else [processParentPid] },
        '#withProcessPath':: d.fn(help='"The path to the process executable. See String Filter below for more details."', args=[d.arg(name='processPath', type=d.T.array)]),
        withProcessPath(processPath): { processPath: if std.isArray(v=processPath) then processPath else [processPath] },
        '#withProcessPathMixin':: d.fn(help='"The path to the process executable. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processPath', type=d.T.array)]),
        withProcessPathMixin(processPath): { processPath+: if std.isArray(v=processPath) then processPath else [processPath] },
        '#withProcessPid':: d.fn(help='"The process ID. See Number Filter below for more details."', args=[d.arg(name='processPid', type=d.T.array)]),
        withProcessPid(processPid): { processPid: if std.isArray(v=processPid) then processPid else [processPid] },
        '#withProcessPidMixin':: d.fn(help='"The process ID. See Number Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processPid', type=d.T.array)]),
        withProcessPidMixin(processPid): { processPid+: if std.isArray(v=processPid) then processPid else [processPid] },
        '#withProcessTerminatedAt':: d.fn(help='"The date/time that the process was terminated. See Date Filter below for more details."', args=[d.arg(name='processTerminatedAt', type=d.T.array)]),
        withProcessTerminatedAt(processTerminatedAt): { processTerminatedAt: if std.isArray(v=processTerminatedAt) then processTerminatedAt else [processTerminatedAt] },
        '#withProcessTerminatedAtMixin':: d.fn(help='"The date/time that the process was terminated. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='processTerminatedAt', type=d.T.array)]),
        withProcessTerminatedAtMixin(processTerminatedAt): { processTerminatedAt+: if std.isArray(v=processTerminatedAt) then processTerminatedAt else [processTerminatedAt] },
        '#withProductArn':: d.fn(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\"", args=[d.arg(name='productArn', type=d.T.array)]),
        withProductArn(productArn): { productArn: if std.isArray(v=productArn) then productArn else [productArn] },
        '#withProductArnMixin':: d.fn(help="\"The ARN generated by Security Hub that uniquely identifies a third-party company (security findings provider) after this provider's product (solution that generates findings) is registered with Security Hub. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='productArn', type=d.T.array)]),
        withProductArnMixin(productArn): { productArn+: if std.isArray(v=productArn) then productArn else [productArn] },
        '#withProductFields':: d.fn(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\"", args=[d.arg(name='productFields', type=d.T.array)]),
        withProductFields(productFields): { productFields: if std.isArray(v=productFields) then productFields else [productFields] },
        '#withProductFieldsMixin':: d.fn(help="\"A data type where security-findings providers can include additional solution-specific details that aren't part of the defined AwsSecurityFinding format. See Map Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='productFields', type=d.T.array)]),
        withProductFieldsMixin(productFields): { productFields+: if std.isArray(v=productFields) then productFields else [productFields] },
        '#withProductName':: d.fn(help='"The name of the solution (product) that generates findings. See String Filter below for more details."', args=[d.arg(name='productName', type=d.T.array)]),
        withProductName(productName): { productName: if std.isArray(v=productName) then productName else [productName] },
        '#withProductNameMixin':: d.fn(help='"The name of the solution (product) that generates findings. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='productName', type=d.T.array)]),
        withProductNameMixin(productName): { productName+: if std.isArray(v=productName) then productName else [productName] },
        '#withRecommendationText':: d.fn(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."', args=[d.arg(name='recommendationText', type=d.T.array)]),
        withRecommendationText(recommendationText): { recommendationText: if std.isArray(v=recommendationText) then recommendationText else [recommendationText] },
        '#withRecommendationTextMixin':: d.fn(help='"The recommendation of what to do about the issue described in a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='recommendationText', type=d.T.array)]),
        withRecommendationTextMixin(recommendationText): { recommendationText+: if std.isArray(v=recommendationText) then recommendationText else [recommendationText] },
        '#withRecordState':: d.fn(help='"The updated record state for the finding. See String Filter below for more details."', args=[d.arg(name='recordState', type=d.T.array)]),
        withRecordState(recordState): { recordState: if std.isArray(v=recordState) then recordState else [recordState] },
        '#withRecordStateMixin':: d.fn(help='"The updated record state for the finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='recordState', type=d.T.array)]),
        withRecordStateMixin(recordState): { recordState+: if std.isArray(v=recordState) then recordState else [recordState] },
        '#withRelatedFindingsId':: d.fn(help='"The solution-generated identifier for a related finding. See String Filter below for more details."', args=[d.arg(name='relatedFindingsId', type=d.T.array)]),
        withRelatedFindingsId(relatedFindingsId): { relatedFindingsId: if std.isArray(v=relatedFindingsId) then relatedFindingsId else [relatedFindingsId] },
        '#withRelatedFindingsIdMixin':: d.fn(help='"The solution-generated identifier for a related finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='relatedFindingsId', type=d.T.array)]),
        withRelatedFindingsIdMixin(relatedFindingsId): { relatedFindingsId+: if std.isArray(v=relatedFindingsId) then relatedFindingsId else [relatedFindingsId] },
        '#withRelatedFindingsProductArn':: d.fn(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."', args=[d.arg(name='relatedFindingsProductArn', type=d.T.array)]),
        withRelatedFindingsProductArn(relatedFindingsProductArn): { relatedFindingsProductArn: if std.isArray(v=relatedFindingsProductArn) then relatedFindingsProductArn else [relatedFindingsProductArn] },
        '#withRelatedFindingsProductArnMixin':: d.fn(help='"The ARN of the solution that generated a related finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='relatedFindingsProductArn', type=d.T.array)]),
        withRelatedFindingsProductArnMixin(relatedFindingsProductArn): { relatedFindingsProductArn+: if std.isArray(v=relatedFindingsProductArn) then relatedFindingsProductArn else [relatedFindingsProductArn] },
        '#withResourceAwsEc2InstanceIamInstanceProfileArn':: d.fn(help='"The IAM profile ARN of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIamInstanceProfileArn', type=d.T.array)]),
        withResourceAwsEc2InstanceIamInstanceProfileArn(resourceAwsEc2InstanceIamInstanceProfileArn): { resourceAwsEc2InstanceIamInstanceProfileArn: if std.isArray(v=resourceAwsEc2InstanceIamInstanceProfileArn) then resourceAwsEc2InstanceIamInstanceProfileArn else [resourceAwsEc2InstanceIamInstanceProfileArn] },
        '#withResourceAwsEc2InstanceIamInstanceProfileArnMixin':: d.fn(help='"The IAM profile ARN of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIamInstanceProfileArn', type=d.T.array)]),
        withResourceAwsEc2InstanceIamInstanceProfileArnMixin(resourceAwsEc2InstanceIamInstanceProfileArn): { resourceAwsEc2InstanceIamInstanceProfileArn+: if std.isArray(v=resourceAwsEc2InstanceIamInstanceProfileArn) then resourceAwsEc2InstanceIamInstanceProfileArn else [resourceAwsEc2InstanceIamInstanceProfileArn] },
        '#withResourceAwsEc2InstanceImageId':: d.fn(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceImageId', type=d.T.array)]),
        withResourceAwsEc2InstanceImageId(resourceAwsEc2InstanceImageId): { resourceAwsEc2InstanceImageId: if std.isArray(v=resourceAwsEc2InstanceImageId) then resourceAwsEc2InstanceImageId else [resourceAwsEc2InstanceImageId] },
        '#withResourceAwsEc2InstanceImageIdMixin':: d.fn(help='"The Amazon Machine Image (AMI) ID of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceImageId', type=d.T.array)]),
        withResourceAwsEc2InstanceImageIdMixin(resourceAwsEc2InstanceImageId): { resourceAwsEc2InstanceImageId+: if std.isArray(v=resourceAwsEc2InstanceImageId) then resourceAwsEc2InstanceImageId else [resourceAwsEc2InstanceImageId] },
        '#withResourceAwsEc2InstanceIpv4Addresses':: d.fn(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIpv4Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv4Addresses(resourceAwsEc2InstanceIpv4Addresses): { resourceAwsEc2InstanceIpv4Addresses: if std.isArray(v=resourceAwsEc2InstanceIpv4Addresses) then resourceAwsEc2InstanceIpv4Addresses else [resourceAwsEc2InstanceIpv4Addresses] },
        '#withResourceAwsEc2InstanceIpv4AddressesMixin':: d.fn(help='"The IPv4 addresses associated with the instance. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIpv4Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv4AddressesMixin(resourceAwsEc2InstanceIpv4Addresses): { resourceAwsEc2InstanceIpv4Addresses+: if std.isArray(v=resourceAwsEc2InstanceIpv4Addresses) then resourceAwsEc2InstanceIpv4Addresses else [resourceAwsEc2InstanceIpv4Addresses] },
        '#withResourceAwsEc2InstanceIpv6Addresses':: d.fn(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceIpv6Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv6Addresses(resourceAwsEc2InstanceIpv6Addresses): { resourceAwsEc2InstanceIpv6Addresses: if std.isArray(v=resourceAwsEc2InstanceIpv6Addresses) then resourceAwsEc2InstanceIpv6Addresses else [resourceAwsEc2InstanceIpv6Addresses] },
        '#withResourceAwsEc2InstanceIpv6AddressesMixin':: d.fn(help='"The IPv6 addresses associated with the instance. See Ip Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceIpv6Addresses', type=d.T.array)]),
        withResourceAwsEc2InstanceIpv6AddressesMixin(resourceAwsEc2InstanceIpv6Addresses): { resourceAwsEc2InstanceIpv6Addresses+: if std.isArray(v=resourceAwsEc2InstanceIpv6Addresses) then resourceAwsEc2InstanceIpv6Addresses else [resourceAwsEc2InstanceIpv6Addresses] },
        '#withResourceAwsEc2InstanceKeyName':: d.fn(help='"The key name associated with the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceKeyName', type=d.T.array)]),
        withResourceAwsEc2InstanceKeyName(resourceAwsEc2InstanceKeyName): { resourceAwsEc2InstanceKeyName: if std.isArray(v=resourceAwsEc2InstanceKeyName) then resourceAwsEc2InstanceKeyName else [resourceAwsEc2InstanceKeyName] },
        '#withResourceAwsEc2InstanceKeyNameMixin':: d.fn(help='"The key name associated with the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceKeyName', type=d.T.array)]),
        withResourceAwsEc2InstanceKeyNameMixin(resourceAwsEc2InstanceKeyName): { resourceAwsEc2InstanceKeyName+: if std.isArray(v=resourceAwsEc2InstanceKeyName) then resourceAwsEc2InstanceKeyName else [resourceAwsEc2InstanceKeyName] },
        '#withResourceAwsEc2InstanceLaunchedAt':: d.fn(help='"The date and time the instance was launched. See Date Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceLaunchedAt', type=d.T.array)]),
        withResourceAwsEc2InstanceLaunchedAt(resourceAwsEc2InstanceLaunchedAt): { resourceAwsEc2InstanceLaunchedAt: if std.isArray(v=resourceAwsEc2InstanceLaunchedAt) then resourceAwsEc2InstanceLaunchedAt else [resourceAwsEc2InstanceLaunchedAt] },
        '#withResourceAwsEc2InstanceLaunchedAtMixin':: d.fn(help='"The date and time the instance was launched. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceLaunchedAt', type=d.T.array)]),
        withResourceAwsEc2InstanceLaunchedAtMixin(resourceAwsEc2InstanceLaunchedAt): { resourceAwsEc2InstanceLaunchedAt+: if std.isArray(v=resourceAwsEc2InstanceLaunchedAt) then resourceAwsEc2InstanceLaunchedAt else [resourceAwsEc2InstanceLaunchedAt] },
        '#withResourceAwsEc2InstanceSubnetId':: d.fn(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceSubnetId', type=d.T.array)]),
        withResourceAwsEc2InstanceSubnetId(resourceAwsEc2InstanceSubnetId): { resourceAwsEc2InstanceSubnetId: if std.isArray(v=resourceAwsEc2InstanceSubnetId) then resourceAwsEc2InstanceSubnetId else [resourceAwsEc2InstanceSubnetId] },
        '#withResourceAwsEc2InstanceSubnetIdMixin':: d.fn(help='"The identifier of the subnet that the instance was launched in. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceSubnetId', type=d.T.array)]),
        withResourceAwsEc2InstanceSubnetIdMixin(resourceAwsEc2InstanceSubnetId): { resourceAwsEc2InstanceSubnetId+: if std.isArray(v=resourceAwsEc2InstanceSubnetId) then resourceAwsEc2InstanceSubnetId else [resourceAwsEc2InstanceSubnetId] },
        '#withResourceAwsEc2InstanceType':: d.fn(help='"The instance type of the instance. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceType', type=d.T.array)]),
        withResourceAwsEc2InstanceType(resourceAwsEc2InstanceType): { resourceAwsEc2InstanceType: if std.isArray(v=resourceAwsEc2InstanceType) then resourceAwsEc2InstanceType else [resourceAwsEc2InstanceType] },
        '#withResourceAwsEc2InstanceTypeMixin':: d.fn(help='"The instance type of the instance. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceType', type=d.T.array)]),
        withResourceAwsEc2InstanceTypeMixin(resourceAwsEc2InstanceType): { resourceAwsEc2InstanceType+: if std.isArray(v=resourceAwsEc2InstanceType) then resourceAwsEc2InstanceType else [resourceAwsEc2InstanceType] },
        '#withResourceAwsEc2InstanceVpcId':: d.fn(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."', args=[d.arg(name='resourceAwsEc2InstanceVpcId', type=d.T.array)]),
        withResourceAwsEc2InstanceVpcId(resourceAwsEc2InstanceVpcId): { resourceAwsEc2InstanceVpcId: if std.isArray(v=resourceAwsEc2InstanceVpcId) then resourceAwsEc2InstanceVpcId else [resourceAwsEc2InstanceVpcId] },
        '#withResourceAwsEc2InstanceVpcIdMixin':: d.fn(help='"The identifier of the VPC that the instance was launched in. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsEc2InstanceVpcId', type=d.T.array)]),
        withResourceAwsEc2InstanceVpcIdMixin(resourceAwsEc2InstanceVpcId): { resourceAwsEc2InstanceVpcId+: if std.isArray(v=resourceAwsEc2InstanceVpcId) then resourceAwsEc2InstanceVpcId else [resourceAwsEc2InstanceVpcId] },
        '#withResourceAwsIamAccessKeyCreatedAt':: d.fn(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyCreatedAt', type=d.T.array)]),
        withResourceAwsIamAccessKeyCreatedAt(resourceAwsIamAccessKeyCreatedAt): { resourceAwsIamAccessKeyCreatedAt: if std.isArray(v=resourceAwsIamAccessKeyCreatedAt) then resourceAwsIamAccessKeyCreatedAt else [resourceAwsIamAccessKeyCreatedAt] },
        '#withResourceAwsIamAccessKeyCreatedAtMixin':: d.fn(help='"The creation date/time of the IAM access key related to a finding. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyCreatedAt', type=d.T.array)]),
        withResourceAwsIamAccessKeyCreatedAtMixin(resourceAwsIamAccessKeyCreatedAt): { resourceAwsIamAccessKeyCreatedAt+: if std.isArray(v=resourceAwsIamAccessKeyCreatedAt) then resourceAwsIamAccessKeyCreatedAt else [resourceAwsIamAccessKeyCreatedAt] },
        '#withResourceAwsIamAccessKeyStatus':: d.fn(help='"The status of the IAM access key related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyStatus', type=d.T.array)]),
        withResourceAwsIamAccessKeyStatus(resourceAwsIamAccessKeyStatus): { resourceAwsIamAccessKeyStatus: if std.isArray(v=resourceAwsIamAccessKeyStatus) then resourceAwsIamAccessKeyStatus else [resourceAwsIamAccessKeyStatus] },
        '#withResourceAwsIamAccessKeyStatusMixin':: d.fn(help='"The status of the IAM access key related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyStatus', type=d.T.array)]),
        withResourceAwsIamAccessKeyStatusMixin(resourceAwsIamAccessKeyStatus): { resourceAwsIamAccessKeyStatus+: if std.isArray(v=resourceAwsIamAccessKeyStatus) then resourceAwsIamAccessKeyStatus else [resourceAwsIamAccessKeyStatus] },
        '#withResourceAwsIamAccessKeyUserName':: d.fn(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceAwsIamAccessKeyUserName', type=d.T.array)]),
        withResourceAwsIamAccessKeyUserName(resourceAwsIamAccessKeyUserName): { resourceAwsIamAccessKeyUserName: if std.isArray(v=resourceAwsIamAccessKeyUserName) then resourceAwsIamAccessKeyUserName else [resourceAwsIamAccessKeyUserName] },
        '#withResourceAwsIamAccessKeyUserNameMixin':: d.fn(help='"The user associated with the IAM access key related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsIamAccessKeyUserName', type=d.T.array)]),
        withResourceAwsIamAccessKeyUserNameMixin(resourceAwsIamAccessKeyUserName): { resourceAwsIamAccessKeyUserName+: if std.isArray(v=resourceAwsIamAccessKeyUserName) then resourceAwsIamAccessKeyUserName else [resourceAwsIamAccessKeyUserName] },
        '#withResourceAwsS3BucketOwnerId':: d.fn(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."', args=[d.arg(name='resourceAwsS3BucketOwnerId', type=d.T.array)]),
        withResourceAwsS3BucketOwnerId(resourceAwsS3BucketOwnerId): { resourceAwsS3BucketOwnerId: if std.isArray(v=resourceAwsS3BucketOwnerId) then resourceAwsS3BucketOwnerId else [resourceAwsS3BucketOwnerId] },
        '#withResourceAwsS3BucketOwnerIdMixin':: d.fn(help='"The canonical user ID of the owner of the S3 bucket. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsS3BucketOwnerId', type=d.T.array)]),
        withResourceAwsS3BucketOwnerIdMixin(resourceAwsS3BucketOwnerId): { resourceAwsS3BucketOwnerId+: if std.isArray(v=resourceAwsS3BucketOwnerId) then resourceAwsS3BucketOwnerId else [resourceAwsS3BucketOwnerId] },
        '#withResourceAwsS3BucketOwnerName':: d.fn(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."', args=[d.arg(name='resourceAwsS3BucketOwnerName', type=d.T.array)]),
        withResourceAwsS3BucketOwnerName(resourceAwsS3BucketOwnerName): { resourceAwsS3BucketOwnerName: if std.isArray(v=resourceAwsS3BucketOwnerName) then resourceAwsS3BucketOwnerName else [resourceAwsS3BucketOwnerName] },
        '#withResourceAwsS3BucketOwnerNameMixin':: d.fn(help='"The display name of the owner of the S3 bucket. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceAwsS3BucketOwnerName', type=d.T.array)]),
        withResourceAwsS3BucketOwnerNameMixin(resourceAwsS3BucketOwnerName): { resourceAwsS3BucketOwnerName+: if std.isArray(v=resourceAwsS3BucketOwnerName) then resourceAwsS3BucketOwnerName else [resourceAwsS3BucketOwnerName] },
        '#withResourceContainerImageId':: d.fn(help='"The identifier of the image related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerImageId', type=d.T.array)]),
        withResourceContainerImageId(resourceContainerImageId): { resourceContainerImageId: if std.isArray(v=resourceContainerImageId) then resourceContainerImageId else [resourceContainerImageId] },
        '#withResourceContainerImageIdMixin':: d.fn(help='"The identifier of the image related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerImageId', type=d.T.array)]),
        withResourceContainerImageIdMixin(resourceContainerImageId): { resourceContainerImageId+: if std.isArray(v=resourceContainerImageId) then resourceContainerImageId else [resourceContainerImageId] },
        '#withResourceContainerImageName':: d.fn(help='"The name of the image related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerImageName', type=d.T.array)]),
        withResourceContainerImageName(resourceContainerImageName): { resourceContainerImageName: if std.isArray(v=resourceContainerImageName) then resourceContainerImageName else [resourceContainerImageName] },
        '#withResourceContainerImageNameMixin':: d.fn(help='"The name of the image related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerImageName', type=d.T.array)]),
        withResourceContainerImageNameMixin(resourceContainerImageName): { resourceContainerImageName+: if std.isArray(v=resourceContainerImageName) then resourceContainerImageName else [resourceContainerImageName] },
        '#withResourceContainerLaunchedAt':: d.fn(help='"The date/time that the container was started. See Date Filter below for more details."', args=[d.arg(name='resourceContainerLaunchedAt', type=d.T.array)]),
        withResourceContainerLaunchedAt(resourceContainerLaunchedAt): { resourceContainerLaunchedAt: if std.isArray(v=resourceContainerLaunchedAt) then resourceContainerLaunchedAt else [resourceContainerLaunchedAt] },
        '#withResourceContainerLaunchedAtMixin':: d.fn(help='"The date/time that the container was started. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerLaunchedAt', type=d.T.array)]),
        withResourceContainerLaunchedAtMixin(resourceContainerLaunchedAt): { resourceContainerLaunchedAt+: if std.isArray(v=resourceContainerLaunchedAt) then resourceContainerLaunchedAt else [resourceContainerLaunchedAt] },
        '#withResourceContainerName':: d.fn(help='"The name of the container related to a finding. See String Filter below for more details."', args=[d.arg(name='resourceContainerName', type=d.T.array)]),
        withResourceContainerName(resourceContainerName): { resourceContainerName: if std.isArray(v=resourceContainerName) then resourceContainerName else [resourceContainerName] },
        '#withResourceContainerNameMixin':: d.fn(help='"The name of the container related to a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceContainerName', type=d.T.array)]),
        withResourceContainerNameMixin(resourceContainerName): { resourceContainerName+: if std.isArray(v=resourceContainerName) then resourceContainerName else [resourceContainerName] },
        '#withResourceDetailsOther':: d.fn(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\"", args=[d.arg(name='resourceDetailsOther', type=d.T.array)]),
        withResourceDetailsOther(resourceDetailsOther): { resourceDetailsOther: if std.isArray(v=resourceDetailsOther) then resourceDetailsOther else [resourceDetailsOther] },
        '#withResourceDetailsOtherMixin':: d.fn(help="\"The details of a resource that doesn't have a specific subfield for the resource type defined. See Map Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='resourceDetailsOther', type=d.T.array)]),
        withResourceDetailsOtherMixin(resourceDetailsOther): { resourceDetailsOther+: if std.isArray(v=resourceDetailsOther) then resourceDetailsOther else [resourceDetailsOther] },
        '#withResourceId':: d.fn(help='"The canonical identifier for the given resource type. See String Filter below for more details."', args=[d.arg(name='resourceId', type=d.T.array)]),
        withResourceId(resourceId): { resourceId: if std.isArray(v=resourceId) then resourceId else [resourceId] },
        '#withResourceIdMixin':: d.fn(help='"The canonical identifier for the given resource type. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceId', type=d.T.array)]),
        withResourceIdMixin(resourceId): { resourceId+: if std.isArray(v=resourceId) then resourceId else [resourceId] },
        '#withResourcePartition':: d.fn(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."', args=[d.arg(name='resourcePartition', type=d.T.array)]),
        withResourcePartition(resourcePartition): { resourcePartition: if std.isArray(v=resourcePartition) then resourcePartition else [resourcePartition] },
        '#withResourcePartitionMixin':: d.fn(help='"The canonical AWS partition name that the Region is assigned to. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourcePartition', type=d.T.array)]),
        withResourcePartitionMixin(resourcePartition): { resourcePartition+: if std.isArray(v=resourcePartition) then resourcePartition else [resourcePartition] },
        '#withResourceRegion':: d.fn(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."', args=[d.arg(name='resourceRegion', type=d.T.array)]),
        withResourceRegion(resourceRegion): { resourceRegion: if std.isArray(v=resourceRegion) then resourceRegion else [resourceRegion] },
        '#withResourceRegionMixin':: d.fn(help='"The canonical AWS external Region name where this resource is located. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceRegion', type=d.T.array)]),
        withResourceRegionMixin(resourceRegion): { resourceRegion+: if std.isArray(v=resourceRegion) then resourceRegion else [resourceRegion] },
        '#withResourceTags':: d.fn(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."', args=[d.arg(name='resourceTags', type=d.T.array)]),
        withResourceTags(resourceTags): { resourceTags: if std.isArray(v=resourceTags) then resourceTags else [resourceTags] },
        '#withResourceTagsMixin':: d.fn(help='"A list of AWS tags associated with a resource at the time the finding was processed. See Map Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceTags', type=d.T.array)]),
        withResourceTagsMixin(resourceTags): { resourceTags+: if std.isArray(v=resourceTags) then resourceTags else [resourceTags] },
        '#withResourceType':: d.fn(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."', args=[d.arg(name='resourceType', type=d.T.array)]),
        withResourceType(resourceType): { resourceType: if std.isArray(v=resourceType) then resourceType else [resourceType] },
        '#withResourceTypeMixin':: d.fn(help='"Specifies the type of the resource that details are provided for. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceType', type=d.T.array)]),
        withResourceTypeMixin(resourceType): { resourceType+: if std.isArray(v=resourceType) then resourceType else [resourceType] },
        '#withSeverityLabel':: d.fn(help="\"The label of a finding's severity. See String Filter below for more details.\"", args=[d.arg(name='severityLabel', type=d.T.array)]),
        withSeverityLabel(severityLabel): { severityLabel: if std.isArray(v=severityLabel) then severityLabel else [severityLabel] },
        '#withSeverityLabelMixin':: d.fn(help="\"The label of a finding's severity. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='severityLabel', type=d.T.array)]),
        withSeverityLabelMixin(severityLabel): { severityLabel+: if std.isArray(v=severityLabel) then severityLabel else [severityLabel] },
        '#withSourceUrl':: d.fn(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\"", args=[d.arg(name='sourceUrl', type=d.T.array)]),
        withSourceUrl(sourceUrl): { sourceUrl: if std.isArray(v=sourceUrl) then sourceUrl else [sourceUrl] },
        '#withSourceUrlMixin':: d.fn(help="\"A URL that links to a page about the current finding in the security-findings provider's solution. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='sourceUrl', type=d.T.array)]),
        withSourceUrlMixin(sourceUrl): { sourceUrl+: if std.isArray(v=sourceUrl) then sourceUrl else [sourceUrl] },
        '#withThreatIntelIndicatorCategory':: d.fn(help='"The category of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorCategory', type=d.T.array)]),
        withThreatIntelIndicatorCategory(threatIntelIndicatorCategory): { threatIntelIndicatorCategory: if std.isArray(v=threatIntelIndicatorCategory) then threatIntelIndicatorCategory else [threatIntelIndicatorCategory] },
        '#withThreatIntelIndicatorCategoryMixin':: d.fn(help='"The category of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorCategory', type=d.T.array)]),
        withThreatIntelIndicatorCategoryMixin(threatIntelIndicatorCategory): { threatIntelIndicatorCategory+: if std.isArray(v=threatIntelIndicatorCategory) then threatIntelIndicatorCategory else [threatIntelIndicatorCategory] },
        '#withThreatIntelIndicatorLastObservedAt':: d.fn(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."', args=[d.arg(name='threatIntelIndicatorLastObservedAt', type=d.T.array)]),
        withThreatIntelIndicatorLastObservedAt(threatIntelIndicatorLastObservedAt): { threatIntelIndicatorLastObservedAt: if std.isArray(v=threatIntelIndicatorLastObservedAt) then threatIntelIndicatorLastObservedAt else [threatIntelIndicatorLastObservedAt] },
        '#withThreatIntelIndicatorLastObservedAtMixin':: d.fn(help='"The date/time of the last observation of a threat intelligence indicator. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorLastObservedAt', type=d.T.array)]),
        withThreatIntelIndicatorLastObservedAtMixin(threatIntelIndicatorLastObservedAt): { threatIntelIndicatorLastObservedAt+: if std.isArray(v=threatIntelIndicatorLastObservedAt) then threatIntelIndicatorLastObservedAt else [threatIntelIndicatorLastObservedAt] },
        '#withThreatIntelIndicatorSource':: d.fn(help='"The source of the threat intelligence. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorSource', type=d.T.array)]),
        withThreatIntelIndicatorSource(threatIntelIndicatorSource): { threatIntelIndicatorSource: if std.isArray(v=threatIntelIndicatorSource) then threatIntelIndicatorSource else [threatIntelIndicatorSource] },
        '#withThreatIntelIndicatorSourceMixin':: d.fn(help='"The source of the threat intelligence. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorSource', type=d.T.array)]),
        withThreatIntelIndicatorSourceMixin(threatIntelIndicatorSource): { threatIntelIndicatorSource+: if std.isArray(v=threatIntelIndicatorSource) then threatIntelIndicatorSource else [threatIntelIndicatorSource] },
        '#withThreatIntelIndicatorSourceUrl':: d.fn(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorSourceUrl', type=d.T.array)]),
        withThreatIntelIndicatorSourceUrl(threatIntelIndicatorSourceUrl): { threatIntelIndicatorSourceUrl: if std.isArray(v=threatIntelIndicatorSourceUrl) then threatIntelIndicatorSourceUrl else [threatIntelIndicatorSourceUrl] },
        '#withThreatIntelIndicatorSourceUrlMixin':: d.fn(help='"The URL for more details from the source of the threat intelligence. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorSourceUrl', type=d.T.array)]),
        withThreatIntelIndicatorSourceUrlMixin(threatIntelIndicatorSourceUrl): { threatIntelIndicatorSourceUrl+: if std.isArray(v=threatIntelIndicatorSourceUrl) then threatIntelIndicatorSourceUrl else [threatIntelIndicatorSourceUrl] },
        '#withThreatIntelIndicatorType':: d.fn(help='"The type of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorType', type=d.T.array)]),
        withThreatIntelIndicatorType(threatIntelIndicatorType): { threatIntelIndicatorType: if std.isArray(v=threatIntelIndicatorType) then threatIntelIndicatorType else [threatIntelIndicatorType] },
        '#withThreatIntelIndicatorTypeMixin':: d.fn(help='"The type of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorType', type=d.T.array)]),
        withThreatIntelIndicatorTypeMixin(threatIntelIndicatorType): { threatIntelIndicatorType+: if std.isArray(v=threatIntelIndicatorType) then threatIntelIndicatorType else [threatIntelIndicatorType] },
        '#withThreatIntelIndicatorValue':: d.fn(help='"The value of a threat intelligence indicator. See String Filter below for more details."', args=[d.arg(name='threatIntelIndicatorValue', type=d.T.array)]),
        withThreatIntelIndicatorValue(threatIntelIndicatorValue): { threatIntelIndicatorValue: if std.isArray(v=threatIntelIndicatorValue) then threatIntelIndicatorValue else [threatIntelIndicatorValue] },
        '#withThreatIntelIndicatorValueMixin':: d.fn(help='"The value of a threat intelligence indicator. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='threatIntelIndicatorValue', type=d.T.array)]),
        withThreatIntelIndicatorValueMixin(threatIntelIndicatorValue): { threatIntelIndicatorValue+: if std.isArray(v=threatIntelIndicatorValue) then threatIntelIndicatorValue else [threatIntelIndicatorValue] },
        '#withTitle':: d.fn(help="\"A finding's title. See String Filter below for more details.\"", args=[d.arg(name='title', type=d.T.array)]),
        withTitle(title): { title: if std.isArray(v=title) then title else [title] },
        '#withTitleMixin':: d.fn(help="\"A finding's title. See String Filter below for more details.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='title', type=d.T.array)]),
        withTitleMixin(title): { title+: if std.isArray(v=title) then title else [title] },
        '#withType':: d.fn(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."', args=[d.arg(name='type', type=d.T.array)]),
        withType(type): { type: if std.isArray(v=type) then type else [type] },
        '#withTypeMixin':: d.fn(help='"A finding type in the format of namespace/category/classifier that classifies a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='type', type=d.T.array)]),
        withTypeMixin(type): { type+: if std.isArray(v=type) then type else [type] },
        '#withUpdatedAt':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."', args=[d.arg(name='updatedAt', type=d.T.array)]),
        withUpdatedAt(updatedAt): { updatedAt: if std.isArray(v=updatedAt) then updatedAt else [updatedAt] },
        '#withUpdatedAtMixin':: d.fn(help='"An ISO8601-formatted timestamp that indicates when the security-findings provider last updated the finding record. See Date Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='updatedAt', type=d.T.array)]),
        withUpdatedAtMixin(updatedAt): { updatedAt+: if std.isArray(v=updatedAt) then updatedAt else [updatedAt] },
        '#withUserDefinedValues':: d.fn(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."', args=[d.arg(name='userDefinedValues', type=d.T.array)]),
        withUserDefinedValues(userDefinedValues): { userDefinedValues: if std.isArray(v=userDefinedValues) then userDefinedValues else [userDefinedValues] },
        '#withUserDefinedValuesMixin':: d.fn(help='"A list of name/value string pairs associated with the finding. These are custom, user-defined fields added to a finding. See Map Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='userDefinedValues', type=d.T.array)]),
        withUserDefinedValuesMixin(userDefinedValues): { userDefinedValues+: if std.isArray(v=userDefinedValues) then userDefinedValues else [userDefinedValues] },
        '#withVerificationState':: d.fn(help='"The veracity of a finding. See String Filter below for more details."', args=[d.arg(name='verificationState', type=d.T.array)]),
        withVerificationState(verificationState): { verificationState: if std.isArray(v=verificationState) then verificationState else [verificationState] },
        '#withVerificationStateMixin':: d.fn(help='"The veracity of a finding. See String Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='verificationState', type=d.T.array)]),
        withVerificationStateMixin(verificationState): { verificationState+: if std.isArray(v=verificationState) then verificationState else [verificationState] },
        '#withWorkflowStatus':: d.fn(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."', args=[d.arg(name='workflowStatus', type=d.T.array)]),
        withWorkflowStatus(workflowStatus): { workflowStatus: if std.isArray(v=workflowStatus) then workflowStatus else [workflowStatus] },
        '#withWorkflowStatusMixin':: d.fn(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflowStatus', type=d.T.array)]),
        withWorkflowStatusMixin(workflowStatus): { workflowStatus+: if std.isArray(v=workflowStatus) then workflowStatus else [workflowStatus] },
        '#workflowStatus':: d.obj(help='"The status of the investigation into a finding. See Workflow Status Filter below for more details."'),
        workflowStatus: {
          '#withComparison':: d.fn(help='"The condition to apply to a string value when querying for findings. Valid values include: EQUALS and NOT_EQUALS."', args=[d.arg(name='comparison', type=d.T.string)]),
          withComparison(comparison): { comparison: comparison },
          '#withValue':: d.fn(help='"A value for the keyword."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
      },
      '#withFilters':: d.fn(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."', args=[d.arg(name='filters', type=d.T.array)]),
      withFilters(filters): { spec+: { initProvider+: { filters: if std.isArray(v=filters) then filters else [filters] } } },
      '#withFiltersMixin':: d.fn(help='"A configuration block including one or more (up to 10 distinct) attributes used to filter the findings included in the insight. The insight only includes findings that match criteria defined in the filters. See filters below for more details."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='filters', type=d.T.array)]),
      withFiltersMixin(filters): { spec+: { initProvider+: { filters+: if std.isArray(v=filters) then filters else [filters] } } },
      '#withGroupByAttribute':: d.fn(help='"The attribute used to group the findings for the insight e.g., if an insight is grouped by ResourceId, then the insight produces a list of resource identifiers."', args=[d.arg(name='groupByAttribute', type=d.T.string)]),
      withGroupByAttribute(groupByAttribute): { spec+: { initProvider+: { groupByAttribute: groupByAttribute } } },
      '#withName':: d.fn(help='"The name of the custom insight."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { initProvider+: { name: name } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to\\ncreate, observe, update, and delete this managed resource should be\\nconfigured."'),
    providerConfigRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required.\\nThe default is 'Required', which means the reconcile will fail if the\\nreference cannot be resolved. 'Optional' means this reference will be\\na no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerConfigRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default\\nis 'IfNotPresent', which will attempt to resolve the reference only when\\nthe corresponding field is not present. Use 'Always' to resolve the\\nreference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerConfigRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#withDeletionPolicy':: d.fn(help='"DeletionPolicy specifies what will happen to the underlying external\\nwhen this managed resource is deleted - either \\"Delete\\" or \\"Orphan\\" the\\nexternal resource.\\nThis field is planned to be deprecated in favor of the ManagementPolicies\\nfield in a future release. Currently, both could be set independently and\\nnon-default values would be honored if the feature flag is enabled.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223"', args=[d.arg(name='deletionPolicy', type=d.T.string)]),
    withDeletionPolicy(deletionPolicy): { spec+: { deletionPolicy: deletionPolicy } },
    '#withManagementPolicies':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPolicies(managementPolicies): { spec+: { managementPolicies: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#withManagementPoliciesMixin':: d.fn(help='"THIS IS A BETA FIELD. It is on by default but can be opted out\\nthrough a Crossplane feature flag.\\nManagementPolicies specify the array of actions Crossplane is allowed to\\ntake on the managed and external resources.\\nThis field is planned to replace the DeletionPolicy field in a future\\nrelease. Currently, both could be set independently and non-default\\nvalues would be honored if the feature flag is enabled. If both are\\ncustom, the DeletionPolicy field will be ignored.\\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='managementPolicies', type=d.T.array)]),
    withManagementPoliciesMixin(managementPolicies): { spec+: { managementPolicies+: if std.isArray(v=managementPolicies) then managementPolicies else [managementPolicies] } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a\\nSecret to which any connection details for this managed resource should\\nbe written. Connection details frequently include the endpoint, username,\\nand password required to connect to the managed resource."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { writeConnectionSecretToRef+: { namespace: namespace } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
